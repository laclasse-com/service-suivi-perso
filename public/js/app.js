'use strict';
(function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.Sweetalert2 = t(); })(this, function () {
    "use strict";
    function e(e) { var t = function e() { for (var t = arguments.length, n = Array(t), o = 0; o < t; o++)
        n[o] = arguments[o]; return this instanceof e ? void Object.getPrototypeOf(e).apply(this, n) : new (Function.prototype.bind.apply(e, [null].concat(n))); }; return t.prototype = s(Object.create(e.prototype), { constructor: t }), "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t; }
    function t() { var e = Ae.innerParams.get(this), t = Ae.domCache.get(this); e.showConfirmButton || (V(t.confirmButton), !e.showCancelButton && V(t.actions)), O([t.popup, t.actions], k.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.cancelButton.disabled = !1; }
    function n(e) { e.inputValidator || Object.keys(Ee).forEach(function (t) { e.input === t && (e.inputValidator = e.expectRejections ? Ee[t] : Oe.adaptInputValidator(Ee[t])); }), e.target && ("string" != typeof e.target || document.querySelector(e.target)) && ("string" == typeof e.target || e.target.appendChild) || (g("Target parameter is not valid, defaulting to \"body\""), e.target = "body"); var t, n = N(), o = "string" == typeof e.target ? document.querySelector(e.target) : e.target; t = n && o && n.parentNode !== o.parentNode ? oe(e) : n || oe(e), e.width && (t.style.width = "number" == typeof e.width ? e.width + "px" : e.width), e.padding && (t.style.padding = "number" == typeof e.padding ? e.padding + "px" : e.padding), e.background && (t.style.background = e.background); for (var a = window.getComputedStyle(t).getPropertyValue("background-color"), r = t.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"), s = 0; s < r.length; s++)
        r[s].style.backgroundColor = a; var i = M(), l = W(), d = U().querySelector("#" + k.content), u = J(), c = Q(), p = Y(), m = G(), f = X(); if (e.titleText ? l.innerText = e.titleText : e.title && (l.innerHTML = e.title.split("\n").join("<br />")), "string" == typeof e.backdrop ? M().style.background = e.backdrop : !e.backdrop && L([document.documentElement, document.body], k["no-backdrop"]), e.html ? ie(e.html, d) : e.text ? (d.textContent = e.text, T(d)) : V(d), e.position in k ? L(i, k[e.position]) : (g("The \"position\" parameter is not valid, defaulting to \"center\""), L(i, k.center)), e.grow && "string" == typeof e.grow) {
        var b = "grow-" + e.grow;
        b in k && L(i, k[b]);
    } "function" == typeof e.animation && (e.animation = e.animation.call()), e.showCloseButton ? (m.setAttribute("aria-label", e.closeButtonAriaLabel), T(m)) : V(m), t.className = k.popup, e.toast ? (L([document.documentElement, document.body], k["toast-shown"]), L(t, k.toast)) : L(t, k.modal), e.customClass && L(t, e.customClass); var y = z(), v = parseInt(null === e.currentProgressStep ? Oe.getQueueStep() : e.currentProgressStep, 10); e.progressSteps && e.progressSteps.length ? (T(y), q(y), v >= e.progressSteps.length && g("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), e.progressSteps.forEach(function (t, n) { var o = document.createElement("li"); if (L(o, k.progresscircle), o.innerHTML = t, n === v && L(o, k.activeprogressstep), y.appendChild(o), n !== e.progressSteps.length - 1) {
        var i = document.createElement("li");
        L(i, k.progressline), e.progressStepsDistance && (i.style.width = e.progressStepsDistance), y.appendChild(i);
    } })) : V(y); for (var w = H(), C = 0; C < w.length; C++)
        V(w[C]); if (e.type) {
        var x = !1;
        for (var A in B)
            if (e.type === A) {
                x = !0;
                break;
            }
        if (!x)
            return h("Unknown alert type: " + e.type), !1;
        var E = t.querySelector("." + k.icon + "." + B[e.type]);
        T(E), e.animation && L(E, "swal2-animate-" + e.type + "-icon");
    } var S = K(); if (e.imageUrl ? (S.setAttribute("src", e.imageUrl), S.setAttribute("alt", e.imageAlt), T(S), e.imageWidth ? S.setAttribute("width", e.imageWidth) : S.removeAttribute("width"), e.imageHeight ? S.setAttribute("height", e.imageHeight) : S.removeAttribute("height"), S.className = k.image, e.imageClass && L(S, e.imageClass)) : V(S), e.showCancelButton ? p.style.display = "inline-block" : V(p), e.showConfirmButton ? j(c, "display") : V(c), e.showConfirmButton || e.showCancelButton ? T(u) : V(u), c.innerHTML = e.confirmButtonText, p.innerHTML = e.cancelButtonText, c.setAttribute("aria-label", e.confirmButtonAriaLabel), p.setAttribute("aria-label", e.cancelButtonAriaLabel), c.className = k.confirm, L(c, e.confirmButtonClass), p.className = k.cancel, L(p, e.cancelButtonClass), e.buttonsStyling) {
        L([c, p], k.styled), e.confirmButtonColor && (c.style.backgroundColor = e.confirmButtonColor), e.cancelButtonColor && (p.style.backgroundColor = e.cancelButtonColor);
        var P = window.getComputedStyle(c).getPropertyValue("background-color");
        c.style.borderLeftColor = P, c.style.borderRightColor = P;
    }
    else
        O([c, p], k.styled), c.style.backgroundColor = c.style.borderLeftColor = c.style.borderRightColor = "", p.style.backgroundColor = p.style.borderLeftColor = p.style.borderRightColor = ""; ie(e.footer, f), !0 === e.animation ? O(t, k.noanimation) : L(t, k.noanimation), e.showLoaderOnConfirm && !e.preConfirm && g("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"); }
    function o() { if ("undefined" != typeof window) {
        "undefined" == typeof Promise && h("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");
        for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        if ("undefined" == typeof t[0])
            return h("SweetAlert2 expects at least 1 attribute!"), !1;
        Le = this;
        var o = Object.freeze(this.constructor.argsToParams(t));
        Object.defineProperties(this, { params: { value: o, writable: !1, enumerable: !0 } });
        var i = this._main(this.params);
        Ae.promise.set(this, i);
    } }
    var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; }, i = function (e, t) { if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function"); }, r = function () { function e(e, t) { for (var n, o = 0; o < t.length; o++)
        n = t[o], n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n); } return function (t, n, o) { return n && e(t.prototype, n), o && e(t, o), t; }; }(), s = Object.assign || function (e) { for (var t, n = 1; n < arguments.length; n++)
        for (var o in t = arguments[n], t)
            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e; }, l = function e(t, n, o) { null === t && (t = Function.prototype); var i = Object.getOwnPropertyDescriptor(t, n); if (void 0 === i) {
        var a = Object.getPrototypeOf(t);
        return null === a ? void 0 : e(a, n, o);
    } if ("value" in i)
        return i.value; var r = i.get; return void 0 === r ? void 0 : r.call(o); }, d = function (e, t) { if ("function" != typeof t && null !== t)
        throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t); }, u = function (e, t) { if (!e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t && ("object" == typeof t || "function" == typeof t) ? t : e; }, c = function () { function e(e, t) { var n = [], o = !0, i = !1, a = void 0; try {
        for (var r, s = e[Symbol.iterator](); !(o = (r = s.next()).done) && (n.push(r.value), !(t && n.length === t)); o = !0)
            ;
    }
    catch (e) {
        i = !0, a = e;
    }
    finally {
        try {
            !o && s["return"] && s["return"]();
        }
        finally {
            if (i)
                throw a;
        }
    } return n; } return function (t, n) { if (Array.isArray(t))
        return t; if (Symbol.iterator in Object(t))
        return e(t, n); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; }(), p = "SweetAlert2:", m = function (e) { for (var t = [], n = 0; n < e.length; n++)
        -1 === t.indexOf(e[n]) && t.push(e[n]); return t; }, f = function (e) { var t = []; return "undefined" != typeof Map && e instanceof Map ? e.forEach(function (e, n) { t.push([n, e]); }) : Object.keys(e).forEach(function (n) { t.push([n, e[n]]); }), t; }, g = function (e) { console.warn(p + " " + e); }, h = function (e) { console.error(p + " " + e); }, b = [], y = function (e) { -1 !== b.indexOf(e) || (b.push(e), g(e)); }, v = function (e) { return "function" == typeof e ? e() : e; }, w = function (e) { return "object" === ("undefined" == typeof e ? "undefined" : a(e)) && "function" == typeof e.then; }, C = Object.freeze({ cancel: "cancel", backdrop: "overlay", close: "close", esc: "esc", timer: "timer" }), x = function (e) { var t = {}; for (var n in e)
        t[e[n]] = "swal2-" + e[n]; return t; }, k = x(["container", "shown", "iosfix", "popup", "modal", "no-backdrop", "toast", "toast-shown", "fade", "show", "hide", "noanimation", "close", "title", "header", "content", "actions", "confirm", "cancel", "footer", "icon", "icon-text", "image", "input", "has-input", "file", "range", "select", "radio", "checkbox", "textarea", "inputerror", "validationerror", "progresssteps", "activeprogressstep", "progresscircle", "progressline", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen"]), B = x(["success", "warning", "info", "question", "error"]), A = { previousActiveElement: null, previousBodyPadding: null }, E = function (e, t) { return !!e.classList && e.classList.contains(t); }, S = function (e) { if (e.focus(), "file" !== e.type) {
        var t = e.value;
        e.value = "", e.value = t;
    } }, P = function (e, t, n) { e && t && ("string" == typeof t && (t = t.split(/\s+/).filter(Boolean)), t.forEach(function (t) { e.forEach ? e.forEach(function (e) { n ? e.classList.add(t) : e.classList.remove(t); }) : n ? e.classList.add(t) : e.classList.remove(t); })); }, L = function (e, t) { P(e, t, !0); }, O = function (e, t) { P(e, t, !1); }, _ = function (e, t) { for (var n = 0; n < e.childNodes.length; n++)
        if (E(e.childNodes[n], t))
            return e.childNodes[n]; }, T = function (e) { e.style.opacity = "", e.style.display = e.id === k.content ? "block" : "flex"; }, V = function (e) { e.style.opacity = "", e.style.display = "none"; }, q = function (e) { for (; e.firstChild;)
        e.removeChild(e.firstChild); }, D = function (e) { return e && (e.offsetWidth || e.offsetHeight || e.getClientRects().length); }, j = function (e, t) { e.style.removeProperty ? e.style.removeProperty(t) : e.style.removeAttribute(t); }, R = function () { if (A.previousActiveElement && A.previousActiveElement.focus) {
        var e = window.scrollX, t = window.scrollY;
        A.previousActiveElement.focus(), "undefined" != typeof e && "undefined" != typeof t && window.scrollTo(e, t);
    } }, M = function () { return document.body.querySelector("." + k.container); }, I = function (e) { var t = M(); return t ? t.querySelector("." + e) : null; }, N = function () { return I(k.popup); }, H = function () { var e = N(); return e.querySelectorAll("." + k.icon); }, W = function () { return I(k.title); }, U = function () { return I(k.content); }, K = function () { return I(k.image); }, z = function () { return I(k.progresssteps); }, F = function () { return I(k.validationerror); }, Q = function () { return I(k.confirm); }, Y = function () { return I(k.cancel); }, J = function () { return I(k.actions); }, X = function () { return I(k.footer); }, G = function () { return I(k.close); }, Z = function () { var e = Array.prototype.slice.call(N().querySelectorAll("[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])")).sort(function (e, t) { return (e = parseInt(e.getAttribute("tabindex")), t = parseInt(t.getAttribute("tabindex")), e > t) ? 1 : e < t ? -1 : 0; }), t = Array.prototype.slice.call(N().querySelectorAll("a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex=\"0\"], [contenteditable], audio[controls], video[controls]")); return m(e.concat(t)); }, $ = function () { return !document.body.classList.contains(k["toast-shown"]); }, ee = function () { return document.body.classList.contains(k["toast-shown"]); }, te = function () { return "undefined" == typeof window || "undefined" == typeof document; }, ne = ("\n <div aria-labelledby=\"" + k.title + "\" aria-describedby=\"" + k.content + "\" class=\"" + k.popup + "\" tabindex=\"-1\">\n   <div class=\"" + k.header + "\">\n     <ul class=\"" + k.progresssteps + "\"></ul>\n     <div class=\"" + k.icon + " " + B.error + "\">\n       <span class=\"swal2-x-mark\"><span class=\"swal2-x-mark-line-left\"></span><span class=\"swal2-x-mark-line-right\"></span></span>\n     </div>\n     <div class=\"" + k.icon + " " + B.question + "\">\n       <span class=\"" + k["icon-text"] + "\">?</span>\n      </div>\n     <div class=\"" + k.icon + " " + B.warning + "\">\n       <span class=\"" + k["icon-text"] + "\">!</span>\n      </div>\n     <div class=\"" + k.icon + " " + B.info + "\">\n       <span class=\"" + k["icon-text"] + "\">i</span>\n      </div>\n     <div class=\"" + k.icon + " " + B.success + "\">\n       <div class=\"swal2-success-circular-line-left\"></div>\n       <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n       <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n       <div class=\"swal2-success-circular-line-right\"></div>\n     </div>\n     <img class=\"" + k.image + "\" />\n     <h2 class=\"" + k.title + "\" id=\"" + k.title + "\"></h2>\n     <button type=\"button\" class=\"" + k.close + "\">\xD7</button>\n   </div>\n   <div class=\"" + k.content + "\">\n     <div id=\"" + k.content + "\"></div>\n     <input class=\"" + k.input + "\" />\n     <input type=\"file\" class=\"" + k.file + "\" />\n     <div class=\"" + k.range + "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"" + k.select + "\"></select>\n     <div class=\"" + k.radio + "\"></div>\n     <label for=\"" + k.checkbox + "\" class=\"" + k.checkbox + "\">\n       <input type=\"checkbox\" />\n     </label>\n     <textarea class=\"" + k.textarea + "\"></textarea>\n     <div class=\"" + k.validationerror + "\" id=\"" + k.validationerror + "\"></div>\n   </div>\n   <div class=\"" + k.actions + "\">\n     <button type=\"button\" class=\"" + k.confirm + "\">OK</button>\n     <button type=\"button\" class=\"" + k.cancel + "\">Cancel</button>\n   </div>\n   <div class=\"" + k.footer + "\">\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, ""), oe = function (e) { var t = M(); if (t && (t.parentNode.removeChild(t), O([document.documentElement, document.body], [k["no-backdrop"], k["has-input"], k["toast-shown"]])), te())
        return void h("SweetAlert2 requires document to initialize"); var n = document.createElement("div"); n.className = k.container, n.innerHTML = ne; var o = "string" == typeof e.target ? document.querySelector(e.target) : e.target; o.appendChild(n); var i = N(), a = U(), r = _(a, k.input), s = _(a, k.file), l = a.querySelector("." + k.range + " input"), d = a.querySelector("." + k.range + " output"), u = _(a, k.select), c = a.querySelector("." + k.checkbox + " input"), p = _(a, k.textarea); i.setAttribute("role", e.toast ? "alert" : "dialog"), i.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || i.setAttribute("aria-modal", "true"); var m = function () { Oe.isVisible() && Oe.resetValidationError(); }; return r.oninput = m, s.onchange = m, u.onchange = m, c.onchange = m, p.oninput = m, l.oninput = function () { m(), d.value = l.value; }, l.onchange = function () { m(), l.nextSibling.value = l.value; }, i; }, ie = function (e, t) { if (!e)
        return V(t); if ("object" === ("undefined" == typeof e ? "undefined" : a(e))) {
        if (t.innerHTML = "", 0 in e)
            for (var n = 0; n in e; n++)
                t.appendChild(e[n].cloneNode(!0));
        else
            t.appendChild(e.cloneNode(!0));
    }
    else if (e)
        t.innerHTML = e;
    else
        ; T(t); }, ae = function () { if (te())
        return !1; var e = document.createElement("div"), t = { WebkitAnimation: "webkitAnimationEnd", OAnimation: "oAnimationEnd oanimationend", animation: "animationend" }; for (var n in t)
        if (t.hasOwnProperty(n) && "undefined" != typeof e.style[n])
            return t[n]; return !1; }(), re = function () { var e = "ontouchstart" in window || navigator.msMaxTouchPoints; if (e)
        return 0; var t = document.createElement("div"); t.style.width = "50px", t.style.height = "50px", t.style.overflow = "scroll", document.body.appendChild(t); var n = t.offsetWidth - t.clientWidth; return document.body.removeChild(t), n; }, se = function () { null !== A.previousBodyPadding || document.body.scrollHeight > window.innerHeight && (A.previousBodyPadding = document.body.style.paddingRight, document.body.style.paddingRight = re() + "px"); }, le = function () { null !== A.previousBodyPadding && (document.body.style.paddingRight = A.previousBodyPadding, A.previousBodyPadding = null); }, de = function () { var e = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; if (e && !E(document.body, k.iosfix)) {
        var t = document.body.scrollTop;
        document.body.style.top = -1 * t + "px", L(document.body, k.iosfix);
    } }, ue = function () { if (E(document.body, k.iosfix)) {
        var e = parseInt(document.body.style.top, 10);
        O(document.body, k.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * e;
    } }, ce = {}, pe = function (e, t) { var n = M(), o = N(); if (o) {
        null !== e && "function" == typeof e && e(o), O(o, k.show), L(o, k.hide), clearTimeout(o.timeout), ee() || (R(), window.onkeydown = ce.previousWindowKeyDown, ce.windowOnkeydownOverridden = !1);
        var i = function () { n.parentNode && n.parentNode.removeChild(n), O([document.documentElement, document.body], [k.shown, k["no-backdrop"], k["has-input"], k["toast-shown"]]), $() && (le(), ue()), null !== t && "function" == typeof t && setTimeout(function () { t(); }); };
        ae && !E(o, k.noanimation) ? o.addEventListener(ae, function e() { o.removeEventListener(ae, e), E(o, k.hide) && i(); }) : i();
    } }, me = { title: "", titleText: "", text: "", html: "", footer: "", type: null, toast: !1, customClass: "", target: "body", backdrop: !0, animation: !0, allowOutsideClick: !0, allowEscapeKey: !0, allowEnterKey: !0, showConfirmButton: !0, showCancelButton: !1, preConfirm: null, confirmButtonText: "OK", confirmButtonAriaLabel: "", confirmButtonColor: null, confirmButtonClass: null, cancelButtonText: "Cancel", cancelButtonAriaLabel: "", cancelButtonColor: null, cancelButtonClass: null, buttonsStyling: !0, reverseButtons: !1, focusConfirm: !0, focusCancel: !1, showCloseButton: !1, closeButtonAriaLabel: "Close this dialog", showLoaderOnConfirm: !1, imageUrl: null, imageWidth: null, imageHeight: null, imageAlt: "", imageClass: null, timer: null, width: null, padding: null, background: null, input: null, inputPlaceholder: "", inputValue: "", inputOptions: {}, inputAutoTrim: !0, inputClass: null, inputAttributes: {}, inputValidator: null, grow: !1, position: "center", progressSteps: [], currentProgressStep: null, progressStepsDistance: null, onBeforeOpen: null, onAfterClose: null, onOpen: null, onClose: null, useRejections: !1, expectRejections: !1 }, fe = ["useRejections", "expectRejections"], ge = function (e) { return me.hasOwnProperty(e) || "extraParams" === e; }, he = function (e) { return -1 !== fe.indexOf(e); }, be = function (e) { for (var t in e)
        ge(t) || g("Unknown parameter \"" + t + "\""), he(t) && y("The parameter \"" + t + "\" is deprecated and will be removed in the next major release."); }, ye = {}, ve = [], we = function (e, t) { return t && t < ve.length ? ve.splice(t, 0, e) : ve.push(e); }, Ce = function (e) { "undefined" != typeof ve[e] && ve.splice(e, 1); }, xe = function () { var e = N(); e || Oe(""), e = N(); var t = J(), n = Q(), o = Y(); T(t), T(n), L([e, t], k.loading), n.disabled = !0, o.disabled = !0, e.setAttribute("data-loading", !0), e.setAttribute("aria-busy", !0), e.focus(); }, ke = Object.freeze({ isValidParameter: ge, isDeprecatedParameter: he, argsToParams: function (e) { var t = {}; switch (a(e[0])) {
            case "string":
                ["title", "html", "type"].forEach(function (n, o) { void 0 !== e[o] && (t[n] = e[o]); });
                break;
            case "object":
                s(t, e[0]);
                break;
            default: return h("Unexpected type of argument! Expected \"string\" or \"object\", got " + a(e[0])), !1;
        } return t; }, adaptInputValidator: function (e) { return function (t, n) { return e.call(this, t, n).then(function () { }, function (e) { return e; }); }; }, close: pe, closePopup: pe, closeModal: pe, closeToast: pe, isVisible: function () { return !!N(); }, clickConfirm: function () { return Q().click(); }, clickCancel: function () { return Y().click(); }, getPopup: N, getTitle: W, getContent: U, getImage: K, getButtonsWrapper: function () { return y("swal.getButtonsWrapper() is deprecated and will be removed in the next major release, use swal.getActions() instead"), I(k.actions); }, getActions: J, getConfirmButton: Q, getCancelButton: Y, getFooter: X, isLoading: function () { return N().hasAttribute("data-loading"); }, mixin: function (t) { var n = this; return e(function (e) { function n() { return i(this, n), u(this, (n.__proto__ || Object.getPrototypeOf(n)).apply(this, arguments)); } return d(n, e), r(n, [{ key: "_main", value: function (e) { return l(n.prototype.__proto__ || Object.getPrototypeOf(n.prototype), "_main", this).call(this, s({}, t, e)); } }]), n; }(n)); }, queue: function (e) { var t = this; ve = e; var n = function () { ve = [], document.body.removeAttribute("data-swal2-queue-step"); }, o = []; return new Promise(function (e) { (function a(r, i) { r < ve.length ? (document.body.setAttribute("data-swal2-queue-step", r), t(ve[r]).then(function (t) { "undefined" == typeof t.value ? (n(), e({ dismiss: t.dismiss })) : (o.push(t.value), a(r + 1, i)); })) : (n(), e({ value: o })); })(0); }); }, getQueueStep: function () { return document.body.getAttribute("data-swal2-queue-step"); }, insertQueueStep: we, deleteQueueStep: Ce, showLoading: xe, enableLoading: xe, fire: function () { for (var e = this, t = arguments.length, n = Array(t), o = 0; o < t; o++)
            n[o] = arguments[o]; return new (Function.prototype.bind.apply(e, [null].concat(n))); } });
    if ("undefined" != typeof window && "function" != typeof window.WeakMap) {
        var Be = 0;
        window.Symbol = function (e) { return "__" + e + "_" + Math.floor(1e9 * Math.random()) + "_" + ++Be + "__"; }, Symbol.iterator = Symbol("Symbol.iterator"), window.WeakMap = function (e, t, n) { function o() { t(this, e, { value: Symbol("WeakMap") }); } return o.prototype = { delete: function (t) { delete t[this[e]]; }, get: function (t) { return t[this[e]]; }, has: function (t) { return n.call(t, this[e]); }, set: function (n, o) { t(n, this[e], { configurable: !0, value: o }); } }, o; }(Symbol("WeakMap"), Object.defineProperty, {}.hasOwnProperty);
    }
    var Ae = { promise: new WeakMap, innerParams: new WeakMap, domCache: new WeakMap }, Ee = { email: function (e) { return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e) ? Promise.resolve() : Promise.reject("Invalid email address"); }, url: function (e) { return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(e) ? Promise.resolve() : Promise.reject("Invalid URL"); } }, Se = function (e, t, n) { var o = M(), i = N(); null !== t && "function" == typeof t && t(i), e ? (L(i, k.show), L(o, k.fade), O(i, k.hide)) : O(i, k.fade), T(i), o.style.overflowY = "hidden", ae && !E(i, k.noanimation) ? i.addEventListener(ae, function e() { i.removeEventListener(ae, e), o.style.overflowY = "auto"; }) : o.style.overflowY = "auto", L([document.documentElement, document.body, o], k.shown), $() && (se(), de()), A.previousActiveElement = document.activeElement, null !== n && "function" == typeof n && setTimeout(function () { n(i); }); }, Pe = Object.freeze({ hideLoading: t, disableLoading: t, getInput: function (e) { var t = Ae.innerParams.get(this), n = Ae.domCache.get(this); return (e = e || t.input, !e) ? null : "select" === e || "textarea" === e || "file" === e ? _(n.content, k[e]) : "checkbox" === e ? n.popup.querySelector("." + k.checkbox + " input") : "radio" === e ? n.popup.querySelector("." + k.radio + " input:checked") || n.popup.querySelector("." + k.radio + " input:first-child") : "range" === e ? n.popup.querySelector("." + k.range + " input") : _(n.content, k.input); }, enableButtons: function () { var e = Ae.domCache.get(this); e.confirmButton.disabled = !1, e.cancelButton.disabled = !1; }, disableButtons: function () { var e = Ae.domCache.get(this); e.confirmButton.disabled = !0, e.cancelButton.disabled = !0; }, enableConfirmButton: function () { var e = Ae.domCache.get(this); e.confirmButton.disabled = !1; }, disableConfirmButton: function () { var e = Ae.domCache.get(this); e.confirmButton.disabled = !0; }, enableInput: function () { var e = this.getInput(); if (!e)
            return !1; if ("radio" === e.type)
            for (var t = e.parentNode.parentNode, n = t.querySelectorAll("input"), o = 0; o < n.length; o++)
                n[o].disabled = !1;
        else
            e.disabled = !1; }, disableInput: function () { var e = this.getInput(); if (!e)
            return !1; if (e && "radio" === e.type)
            for (var t = e.parentNode.parentNode, n = t.querySelectorAll("input"), o = 0; o < n.length; o++)
                n[o].disabled = !0;
        else
            e.disabled = !0; }, showValidationError: function (e) { var t = Ae.domCache.get(this); t.validationError.innerHTML = e; var n = window.getComputedStyle(t.popup); t.validationError.style.marginLeft = "-" + n.getPropertyValue("padding-left"), t.validationError.style.marginRight = "-" + n.getPropertyValue("padding-right"), T(t.validationError); var o = this.getInput(); o && (o.setAttribute("aria-invalid", !0), o.setAttribute("aria-describedBy", k.validationerror), S(o), L(o, k.inputerror)); }, resetValidationError: function () { var e = Ae.domCache.get(this); e.validationError && V(e.validationError); var t = this.getInput(); t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedBy"), O(t, k.inputerror)); }, _main: function (e) { var t = this; be(e); var o = s({}, me, e); n(o), Object.freeze(o), Ae.innerParams.set(this, o); var r = { popup: N(), container: M(), content: U(), actions: J(), confirmButton: Q(), cancelButton: Y(), closeButton: G(), validationError: F(), progressSteps: z() }; Ae.domCache.set(this, r); var l = this.constructor; return new Promise(function (e, n) { var s = function (t) { l.closePopup(o.onClose, o.onAfterClose), o.useRejections ? e(t) : e({ value: t }); }, d = function (t) { l.closePopup(o.onClose, o.onAfterClose), o.useRejections ? n(t) : e({ dismiss: t }); }, u = function (e) { l.closePopup(o.onClose, o.onAfterClose), n(e); }; o.timer && (r.popup.timeout = setTimeout(function () { return d("timer"); }, o.timer)); var p = function () { var e = t.getInput(); if (!e)
            return null; switch (o.input) {
            case "checkbox": return e.checked ? 1 : 0;
            case "radio": return e.checked ? e.value : null;
            case "file": return e.files.length ? e.files[0] : null;
            default: return o.inputAutoTrim ? e.value.trim() : e.value;
        } }; o.input && setTimeout(function () { var e = t.getInput(); e && S(e); }, 0); for (var m = function (e) { if (o.showLoaderOnConfirm && l.showLoading(), o.preConfirm) {
            t.resetValidationError();
            var n = Promise.resolve().then(function () { return o.preConfirm(e, o.extraParams); });
            o.expectRejections ? n.then(function (t) { return s(t || e); }, function (e) { t.hideLoading(), e && t.showValidationError(e); }) : n.then(function (n) { D(r.validationError) || !1 === n ? t.hideLoading() : s(n || e); }, function (e) { return u(e); });
        }
        else
            s(e); }, g = function (n) { var i = n || window.event, e = i.target || i.srcElement, a = r.confirmButton, s = r.cancelButton, c = a && (a === e || a.contains(e)), f = s && (s === e || s.contains(e)); switch (i.type) {
            case "click":
                if (!(c && l.isVisible()))
                    f && l.isVisible() && (t.disableButtons(), d(l.DismissReason.cancel));
                else if (t.disableButtons(), o.input) {
                    var g = p();
                    if (o.inputValidator) {
                        t.disableInput();
                        var h = Promise.resolve().then(function () { return o.inputValidator(g, o.extraParams); });
                        o.expectRejections ? h.then(function () { t.enableButtons(), t.enableInput(), m(g); }, function (e) { t.enableButtons(), t.enableInput(), e && t.showValidationError(e); }) : h.then(function (e) { t.enableButtons(), t.enableInput(), e ? t.showValidationError(e) : m(g); }, function (e) { return u(e); });
                    }
                    else
                        m(g);
                }
                else
                    m(!0);
                break;
            default:
        } }, b = r.popup.querySelectorAll("button"), y = 0; y < b.length; y++)
            b[y].onclick = g, b[y].onmouseover = g, b[y].onmouseout = g, b[y].onmousedown = g; if (r.closeButton.onclick = function () { d(l.DismissReason.close); }, o.toast)
            r.popup.onclick = function () { o.showConfirmButton || o.showCancelButton || o.showCloseButton || o.input || (l.closePopup(o.onClose, o.onAfterClose), d(l.DismissReason.close)); };
        else {
            var i = !1;
            r.popup.onmousedown = function () { r.container.onmouseup = function (t) { r.container.onmouseup = void 0, t.target === r.container && (i = !0); }; }, r.container.onmousedown = function () { r.popup.onmouseup = function (t) { r.popup.onmouseup = void 0, (t.target === r.popup || r.popup.contains(t.target)) && (i = !0); }; }, r.container.onclick = function (t) { return i ? void (i = !1) : void (t.target !== r.container || v(o.allowOutsideClick) && d(l.DismissReason.backdrop)); };
        } o.reverseButtons ? r.confirmButton.parentNode.insertBefore(r.cancelButton, r.confirmButton) : r.confirmButton.parentNode.insertBefore(r.confirmButton, r.cancelButton); var C = function (e, t) { for (var n = Z(o.focusCancel), i = 0; i < n.length; i++) {
            e += t, e === n.length ? e = 0 : -1 === e && (e = n.length - 1);
            var a = n[e];
            if (D(a))
                return a.focus();
        } }; o.toast && ce.windowOnkeydownOverridden && (window.onkeydown = ce.previousWindowKeyDown, ce.windowOnkeydownOverridden = !1), o.toast || ce.windowOnkeydownOverridden || (ce.previousWindowKeyDown = window.onkeydown, ce.windowOnkeydownOverridden = !0, window.onkeydown = function (n) { var i = n || window.event; if ("Enter" === i.key && !i.isComposing) {
            if (i.target === t.getInput()) {
                if (-1 !== ["textarea", "file"].indexOf(o.input))
                    return;
                l.clickConfirm(), i.preventDefault();
            }
        }
        else if ("Tab" === i.key) {
            for (var e = i.target || i.srcElement, a = Z(o.focusCancel), s = -1, u = 0; u < a.length; u++)
                if (e === a[u]) {
                    s = u;
                    break;
                }
            i.shiftKey ? C(s, -1) : C(s, 1), i.stopPropagation(), i.preventDefault();
        }
        else
            -1 === ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Left", "Right", "Up", "Down"].indexOf(i.key) ? ("Escape" === i.key || "Esc" === i.key) && !0 === v(o.allowEscapeKey) && d(l.DismissReason.esc) : document.activeElement === r.confirmButton && D(r.cancelButton) ? r.cancelButton.focus() : document.activeElement === r.cancelButton && D(r.confirmButton) && r.confirmButton.focus(); }), t.enableButtons(), t.hideLoading(), t.resetValidationError(), o.input && L(document.body, k["has-input"]); for (var x = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], B = void 0, A = 0; A < x.length; A++) {
            var E = k[x[A]], P = _(r.content, E);
            if (B = t.getInput(x[A]), B) {
                for (var O in B.attributes)
                    if (B.attributes.hasOwnProperty(O)) {
                        var q = B.attributes[O].name;
                        "type" !== q && "value" !== q && B.removeAttribute(q);
                    }
                for (var j in o.inputAttributes)
                    B.setAttribute(j, o.inputAttributes[j]);
            }
            P.className = E, o.inputClass && L(P, o.inputClass), V(P);
        } var R; switch (o.input) {
            case "text":
            case "email":
            case "password":
            case "number":
            case "tel":
            case "url":
                B = _(r.content, k.input), B.value = o.inputValue, B.placeholder = o.inputPlaceholder, B.type = o.input, T(B);
                break;
            case "file":
                B = _(r.content, k.file), B.placeholder = o.inputPlaceholder, B.type = o.input, T(B);
                break;
            case "range":
                var M = _(r.content, k.range), I = M.querySelector("input"), N = M.querySelector("output");
                I.value = o.inputValue, I.type = o.input, N.value = o.inputValue, T(M);
                break;
            case "select":
                var H = _(r.content, k.select);
                if (H.innerHTML = "", o.inputPlaceholder) {
                    var W = document.createElement("option");
                    W.innerHTML = o.inputPlaceholder, W.value = "", W.disabled = !0, W.selected = !0, H.appendChild(W);
                }
                R = function (e) { e.forEach(function (e) { var t = c(e, 2), n = t[0], i = t[1], a = document.createElement("option"); a.value = n, a.innerHTML = i, o.inputValue.toString() === n.toString() && (a.selected = !0), H.appendChild(a); }), T(H), H.focus(); };
                break;
            case "radio":
                var U = _(r.content, k.radio);
                U.innerHTML = "", R = function (e) { e.forEach(function (e) { var t = c(e, 2), n = t[0], i = t[1], a = document.createElement("input"), r = document.createElement("label"); a.type = "radio", a.name = k.radio, a.value = n, o.inputValue.toString() === n.toString() && (a.checked = !0), r.innerHTML = i, r.insertBefore(a, r.firstChild), U.appendChild(r); }), T(U); var t = U.querySelectorAll("input"); t.length && t[0].focus(); };
                break;
            case "checkbox":
                var K = _(r.content, k.checkbox), z = t.getInput("checkbox");
                z.type = "checkbox", z.value = 1, z.id = k.checkbox, z.checked = !!o.inputValue;
                var F = K.getElementsByTagName("span");
                F.length && K.removeChild(F[0]), F = document.createElement("span"), F.innerHTML = o.inputPlaceholder, K.appendChild(F), T(K);
                break;
            case "textarea":
                var Q = _(r.content, k.textarea);
                Q.value = o.inputValue, Q.placeholder = o.inputPlaceholder, T(Q);
                break;
            case null: break;
            default: h("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"" + o.input + "\"");
        } if ("select" === o.input || "radio" === o.input) {
            var Y = function (e) { return R(f(e)); };
            w(o.inputOptions) ? (l.showLoading(), o.inputOptions.then(function (e) { t.hideLoading(), Y(e); })) : "object" === a(o.inputOptions) ? Y(o.inputOptions) : h("Unexpected type of inputOptions! Expected object, Map or Promise, got " + a(o.inputOptions));
        }
        else
            -1 !== ["text", "email", "number", "tel", "textarea"].indexOf(o.input) && w(o.inputValue) && (l.showLoading(), V(B), o.inputValue.then(function (e) { B.value = "number" === o.input ? parseFloat(e) || 0 : e + "", T(B), t.hideLoading(); }).catch(function (e) { h("Error in inputValue promise: " + e), B.value = "", T(B), t.hideLoading(); })); Se(o.animation, o.onBeforeOpen, o.onOpen), o.toast || (v(o.allowEnterKey) ? o.focusCancel && D(r.cancelButton) ? r.cancelButton.focus() : o.focusConfirm && D(r.confirmButton) ? r.confirmButton.focus() : C(-1, 1) : document.activeElement && document.activeElement.blur()), r.container.scrollTop = 0; }); } }), Le = void 0;
    o.prototype.then = function (e, t) { var n = Ae.promise.get(this); return n.then(e, t); }, o.prototype.catch = function (e) { var t = Ae.promise.get(this); return t.catch(e); }, o.prototype.finally = function (e) { var t = Ae.promise.get(this); return t.finally(e); }, s(o.prototype, Pe), s(o, ke), Object.keys(Pe).forEach(function (e) { o[e] = function () { if (Le) {
        var t;
        return (t = Le)[e].apply(t, arguments);
    } }; }), o.DismissReason = C, o.noop = function () { }, o.version = "7.19.3";
    var Oe = e(function (e) { var t = function (t) { function n() { return i(this, n), u(this, (n.__proto__ || Object.getPrototypeOf(n)).apply(this, arguments)); } return d(n, t), r(n, [{ key: "_main", value: function (e) { return l(n.prototype.__proto__ || Object.getPrototypeOf(n.prototype), "_main", this).call(this, s({}, ye, e)); } }], [{ key: "setDefaults", value: function (t) { if (y("\"setDefaults\" & \"resetDefaults\" methods are deprecated in favor of \"mixin\" method and will be removed in the next major release. For new projects, use \"mixin\". For past projects already using \"setDefaults\", support will be provided through an additional package."), !t || "object" !== ("undefined" == typeof t ? "undefined" : a(t)))
                throw new TypeError("SweetAlert2: The argument for setDefaults() is required and has to be a object"); be(t), Object.keys(t).forEach(function (n) { e.isValidParameter(n) && (ye[n] = t[n]); }); } }, { key: "resetDefaults", value: function () { y("\"setDefaults\" & \"resetDefaults\" methods are deprecated in favor of \"mixin\" method and will be removed in the next major release. For new projects, use \"mixin\". For past projects already using \"setDefaults\", support will be provided through an additional package."), ye = {}; } }]), n; }(e); return "undefined" != typeof window && "object" === a(window._swalDefaults) && t.setDefaults(window._swalDefaults), t; }(o));
    return Oe.default = Oe, Oe;
}), "undefined" != typeof window && window.Sweetalert2 && (window.swal = window.sweetAlert = window.Swal = window.SweetAlert = window.Sweetalert2);
(function (y) {
    'use strict';
    function qe(a) { if (G(a))
        u(a.objectMaxDepth) && (Oc.objectMaxDepth = Wb(a.objectMaxDepth) ? a.objectMaxDepth : NaN);
    else
        return Oc; }
    function Wb(a) { return Y(a) && 0 < a; }
    function M(a, b) {
        b = b || Error;
        return function () {
            var d = arguments[0], c;
            c = "[" + (a ? a + ":" : "") + d + "] http://errors.angularjs.org/1.6.10/" + (a ? a + "/" : "") + d;
            for (d = 1; d < arguments.length; d++) {
                c = c + (1 == d ? "?" : "&") + "p" + (d - 1) + "=";
                var e = encodeURIComponent, f;
                f = arguments[d];
                f = "function" == typeof f ? f.toString().replace(/ \{[\s\S]*$/, "") : "undefined" ==
                    typeof f ? "undefined" : "string" != typeof f ? JSON.stringify(f) : f;
                c += e(f);
            }
            return new b(c);
        };
    }
    function ja(a) { if (null == a || Za(a))
        return !1; if (I(a) || F(a) || z && a instanceof z)
        return !0; var b = "length" in Object(a) && a.length; return Y(b) && (0 <= b && (b - 1 in a || a instanceof Array) || "function" === typeof a.item); }
    function q(a, b, d) {
        var c, e;
        if (a)
            if (C(a))
                for (c in a)
                    "prototype" !== c && "length" !== c && "name" !== c && a.hasOwnProperty(c) && b.call(d, a[c], c, a);
            else if (I(a) || ja(a)) {
                var f = "object" !== typeof a;
                c = 0;
                for (e = a.length; c < e; c++)
                    (f || c in
                        a) && b.call(d, a[c], c, a);
            }
            else if (a.forEach && a.forEach !== q)
                a.forEach(b, d, a);
            else if (Pc(a))
                for (c in a)
                    b.call(d, a[c], c, a);
            else if ("function" === typeof a.hasOwnProperty)
                for (c in a)
                    a.hasOwnProperty(c) && b.call(d, a[c], c, a);
            else
                for (c in a)
                    ra.call(a, c) && b.call(d, a[c], c, a);
        return a;
    }
    function Qc(a, b, d) { for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++)
        b.call(d, a[c[e]], c[e]); return c; }
    function Xb(a) { return function (b, d) { a(d, b); }; }
    function re() { return ++qb; }
    function Yb(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; e < f; ++e) {
            var g = b[e];
            if (G(g) || C(g))
                for (var k = Object.keys(g), h = 0, l = k.length; h < l; h++) {
                    var m = k[h], p = g[m];
                    d && G(p) ? da(p) ? a[m] = new Date(p.valueOf()) : $a(p) ? a[m] = new RegExp(p) : p.nodeName ? a[m] = p.cloneNode(!0) : Zb(p) ? a[m] = p.clone() : (G(a[m]) || (a[m] = I(p) ? [] : {}), Yb(a[m], [p], !0)) : a[m] = p;
                }
        }
        c ? a.$$hashKey = c : delete a.$$hashKey;
        return a;
    }
    function P(a) { return Yb(a, xa.call(arguments, 1), !1); }
    function se(a) { return Yb(a, xa.call(arguments, 1), !0); }
    function Z(a) { return parseInt(a, 10); }
    function $b(a, b) { return P(Object.create(a), b); }
    function D() { }
    function ab(a) { return a; }
    function ka(a) { return function () { return a; }; }
    function ac(a) { return C(a.toString) && a.toString !== ha; }
    function x(a) { return "undefined" === typeof a; }
    function u(a) { return "undefined" !== typeof a; }
    function G(a) { return null !== a && "object" === typeof a; }
    function Pc(a) { return null !== a && "object" === typeof a && !Rc(a); }
    function F(a) { return "string" === typeof a; }
    function Y(a) { return "number" === typeof a; }
    function da(a) { return "[object Date]" === ha.call(a); }
    function bc(a) {
        switch (ha.call(a)) {
            case "[object Error]": return !0;
            case "[object Exception]": return !0;
            case "[object DOMException]": return !0;
            default: return a instanceof Error;
        }
    }
    function C(a) { return "function" === typeof a; }
    function $a(a) { return "[object RegExp]" === ha.call(a); }
    function Za(a) { return a && a.window === a; }
    function bb(a) { return a && a.$evalAsync && a.$watch; }
    function La(a) { return "boolean" === typeof a; }
    function te(a) { return a && Y(a.length) && ue.test(ha.call(a)); }
    function Zb(a) { return !(!a || !(a.nodeName || a.prop && a.attr && a.find)); }
    function ve(a) {
        var b = {};
        a = a.split(",");
        var d;
        for (d =
            0; d < a.length; d++)
            b[a[d]] = !0;
        return b;
    }
    function ya(a) { return N(a.nodeName || a[0] && a[0].nodeName); }
    function cb(a, b) { var d = a.indexOf(b); 0 <= d && a.splice(d, 1); return d; }
    function na(a, b, d) {
        function c(a, b, c) {
            c--;
            if (0 > c)
                return "...";
            var d = b.$$hashKey, g;
            if (I(a)) {
                g = 0;
                for (var f = a.length; g < f; g++)
                    b.push(e(a[g], c));
            }
            else if (Pc(a))
                for (g in a)
                    b[g] = e(a[g], c);
            else if (a && "function" === typeof a.hasOwnProperty)
                for (g in a)
                    a.hasOwnProperty(g) && (b[g] = e(a[g], c));
            else
                for (g in a)
                    ra.call(a, g) && (b[g] = e(a[g], c));
            d ? b.$$hashKey = d : delete b.$$hashKey;
            return b;
        }
        function e(a, b) { if (!G(a))
            return a; var d = g.indexOf(a); if (-1 !== d)
            return k[d]; if (Za(a) || bb(a))
            throw oa("cpws"); var d = !1, e = f(a); void 0 === e && (e = I(a) ? [] : Object.create(Rc(a)), d = !0); g.push(a); k.push(e); return d ? c(a, e, b) : e; }
        function f(a) {
            switch (ha.call(a)) {
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object Float32Array]":
                case "[object Float64Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]": return new a.constructor(e(a.buffer), a.byteOffset, a.length);
                case "[object ArrayBuffer]":
                    if (!a.slice) {
                        var b = new ArrayBuffer(a.byteLength);
                        (new Uint8Array(b)).set(new Uint8Array(a));
                        return b;
                    }
                    return a.slice(0);
                case "[object Boolean]":
                case "[object Number]":
                case "[object String]":
                case "[object Date]": return new a.constructor(a.valueOf());
                case "[object RegExp]": return b = new RegExp(a.source, a.toString().match(/[^/]*$/)[0]), b.lastIndex = a.lastIndex, b;
                case "[object Blob]": return new a.constructor([a], { type: a.type });
            }
            if (C(a.cloneNode))
                return a.cloneNode(!0);
        }
        var g = [], k = [];
        d = Wb(d) ? d : NaN;
        if (b) {
            if (te(b) || "[object ArrayBuffer]" === ha.call(b))
                throw oa("cpta");
            if (a === b)
                throw oa("cpi");
            I(b) ? b.length = 0 : q(b, function (a, c) { "$$hashKey" !== c && delete b[c]; });
            g.push(a);
            k.push(b);
            return c(a, b, d);
        }
        return e(a, d);
    }
    function cc(a, b) { return a === b || a !== a && b !== b; }
    function sa(a, b) {
        if (a === b)
            return !0;
        if (null === a || null === b)
            return !1;
        if (a !== a && b !== b)
            return !0;
        var d = typeof a, c;
        if (d === typeof b && "object" === d)
            if (I(a)) {
                if (!I(b))
                    return !1;
                if ((d = a.length) === b.length) {
                    for (c = 0; c < d; c++)
                        if (!sa(a[c], b[c]))
                            return !1;
                    return !0;
                }
            }
            else {
                if (da(a))
                    return da(b) ? cc(a.getTime(), b.getTime()) : !1;
                if ($a(a))
                    return $a(b) ? a.toString() === b.toString() : !1;
                if (bb(a) || bb(b) || Za(a) || Za(b) || I(b) || da(b) || $a(b))
                    return !1;
                d = R();
                for (c in a)
                    if ("$" !== c.charAt(0) && !C(a[c])) {
                        if (!sa(a[c], b[c]))
                            return !1;
                        d[c] = !0;
                    }
                for (c in b)
                    if (!(c in d) && "$" !== c.charAt(0) && u(b[c]) && !C(b[c]))
                        return !1;
                return !0;
            }
        return !1;
    }
    function db(a, b, d) { return a.concat(xa.call(b, d)); }
    function Ta(a, b) {
        var d = 2 < arguments.length ? xa.call(arguments, 2) : [];
        return !C(b) || b instanceof
            RegExp ? b : d.length ? function () { return arguments.length ? b.apply(a, db(d, arguments, 0)) : b.apply(a, d); } : function () { return arguments.length ? b.apply(a, arguments) : b.call(a); };
    }
    function Sc(a, b) { var d = b; "string" === typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = void 0 : Za(b) ? d = "$WINDOW" : b && y.document === b ? d = "$DOCUMENT" : bb(b) && (d = "$SCOPE"); return d; }
    function eb(a, b) { if (!x(a))
        return Y(b) || (b = b ? 2 : null), JSON.stringify(a, Sc, b); }
    function Tc(a) { return F(a) ? JSON.parse(a) : a; }
    function dc(a, b) {
        a = a.replace(we, "");
        var d = Date.parse("Jan 01, 1970 00:00:00 " +
            a) / 6E4;
        return X(d) ? b : d;
    }
    function Uc(a, b) { a = new Date(a.getTime()); a.setMinutes(a.getMinutes() + b); return a; }
    function ec(a, b, d) { d = d ? -1 : 1; var c = a.getTimezoneOffset(); b = dc(b, c); return Uc(a, d * (b - c)); }
    function za(a) { a = z(a).clone().empty(); var b = z("<div></div>").append(a).html(); try {
        return a[0].nodeType === Ma ? N(b) : b.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (a, b) { return "<" + N(b); });
    }
    catch (d) {
        return N(b);
    } }
    function Vc(a) { try {
        return decodeURIComponent(a);
    }
    catch (b) { } }
    function fc(a) {
        var b = {};
        q((a || "").split("&"), function (a) { var c, e, f; a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), f = a.substring(c + 1)), e = Vc(e), u(e) && (f = u(f) ? Vc(f) : !0, ra.call(b, e) ? I(b[e]) ? b[e].push(f) : b[e] = [b[e], f] : b[e] = f)); });
        return b;
    }
    function gc(a) { var b = []; q(a, function (a, c) { I(a) ? q(a, function (a) { b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0))); }) : b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0))); }); return b.length ? b.join("&") : ""; }
    function fb(a) { return ia(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+"); }
    function ia(a, b) { return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+"); }
    function xe(a, b) { var d, c, e = Ga.length; for (c = 0; c < e; ++c)
        if (d = Ga[c] + b, F(d = a.getAttribute(d)))
            return d; return null; }
    function ye(a, b) {
        var d, c, e = {};
        q(Ga, function (b) { b += "app"; !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b)); });
        q(Ga, function (b) { b += "app"; var e; !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b)); });
        d && (ze ? (e.strictDi = null !== xe(d, "strict-di"), b(d, c ? [c] : [], e)) : y.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."));
    }
    function Wc(a, b, d) {
        G(d) || (d = {});
        d = P({ strictDi: !1 }, d);
        var c = function () {
            a = z(a);
            if (a.injector()) {
                var c = a[0] === y.document ? "document" : za(a);
                throw oa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            b = b || [];
            b.unshift(["$provide", function (b) { b.value("$rootElement", a); }]);
            d.debugInfoEnabled && b.push(["$compileProvider",
                function (a) { a.debugInfoEnabled(!0); }]);
            b.unshift("ng");
            c = gb(b, d.strictDi);
            c.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (a, b, c, d) { a.$apply(function () { b.data("$injector", d); c(b)(a); }); }]);
            return c;
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/;
        y && e.test(y.name) && (d.debugInfoEnabled = !0, y.name = y.name.replace(e, ""));
        if (y && !f.test(y.name))
            return c();
        y.name = y.name.replace(f, "");
        ea.resumeBootstrap = function (a) { q(a, function (a) { b.push(a); }); return c(); };
        C(ea.resumeDeferredBootstrap) &&
            ea.resumeDeferredBootstrap();
    }
    function Ae() { y.name = "NG_ENABLE_DEBUG_INFO!" + y.name; y.location.reload(); }
    function Be(a) { a = ea.element(a).injector(); if (!a)
        throw oa("test"); return a.get("$$testability"); }
    function Xc(a, b) { b = b || "_"; return a.replace(Ce, function (a, c) { return (c ? b : "") + a.toLowerCase(); }); }
    function De() {
        var a;
        if (!Yc) {
            var b = rb();
            (ta = x(b) ? y.jQuery : b ? y[b] : void 0) && ta.fn.on ? (z = ta, P(ta.fn, { scope: Ua.scope, isolateScope: Ua.isolateScope, controller: Ua.controller, injector: Ua.injector, inheritedData: Ua.inheritedData }),
                a = ta.cleanData, ta.cleanData = function (b) { for (var c, e = 0, f; null != (f = b[e]); e++)
                (c = ta._data(f, "events")) && c.$destroy && ta(f).triggerHandler("$destroy"); a(b); }) : z = S;
            ea.element = z;
            Yc = !0;
        }
    }
    function hb(a, b, d) { if (!a)
        throw oa("areq", b || "?", d || "required"); return a; }
    function sb(a, b, d) { d && I(a) && (a = a[a.length - 1]); hb(C(a), b, "not a function, got " + (a && "object" === typeof a ? a.constructor.name || "Object" : typeof a)); return a; }
    function Ha(a, b) { if ("hasOwnProperty" === a)
        throw oa("badname", b); }
    function Zc(a, b, d) {
        if (!b)
            return a;
        b =
            b.split(".");
        for (var c, e = a, f = b.length, g = 0; g < f; g++)
            c = b[g], a && (a = (e = a)[c]);
        return !d && C(a) ? Ta(e, a) : a;
    }
    function tb(a) { for (var b = a[0], d = a[a.length - 1], c, e = 1; b !== d && (b = b.nextSibling); e++)
        if (c || a[e] !== b)
            c || (c = z(xa.call(a, 0, e))), c.push(b); return c || a; }
    function R() { return Object.create(null); }
    function hc(a) { if (null == a)
        return ""; switch (typeof a) {
        case "string": break;
        case "number":
            a = "" + a;
            break;
        default: a = !ac(a) || I(a) || da(a) ? eb(a) : a.toString();
    } return a; }
    function Ee(a) {
        function b(a, b, c) { return a[b] || (a[b] = c()); }
        var d = M("$injector"), c = M("ng");
        a = b(a, "angular", Object);
        a.$$minErr = a.$$minErr || M;
        return b(a, "module", function () {
            var a = {};
            return function (f, g, k) {
                var h = {};
                if ("hasOwnProperty" === f)
                    throw c("badname", "module");
                g && a.hasOwnProperty(f) && (a[f] = null);
                return b(a, f, function () {
                    function a(b, c, d, g) { g || (g = e); return function () { g[d || "push"]([b, c, arguments]); return E; }; }
                    function b(a, c, d) { d || (d = e); return function (b, e) { e && C(e) && (e.$$moduleName = f); d.push([a, c, arguments]); return E; }; }
                    if (!g)
                        throw d("nomod", f);
                    var e = [], n = [], B = [], v = a("$injector", "invoke", "push", n), E = { _invokeQueue: e, _configBlocks: n, _runBlocks: B, info: function (a) { if (u(a)) {
                            if (!G(a))
                                throw c("aobj", "value");
                            h = a;
                            return this;
                        } return h; }, requires: g, name: f, provider: b("$provide", "provider"), factory: b("$provide", "factory"), service: b("$provide", "service"), value: a("$provide", "value"), constant: a("$provide", "constant", "unshift"), decorator: b("$provide", "decorator", n), animation: b("$animateProvider", "register"), filter: b("$filterProvider", "register"), controller: b("$controllerProvider", "register"), directive: b("$compileProvider", "directive"), component: b("$compileProvider", "component"), config: v, run: function (a) { B.push(a); return this; } };
                    k && v(k);
                    return E;
                });
            };
        });
    }
    function pa(a, b) { if (I(a)) {
        b = b || [];
        for (var d = 0, c = a.length; d < c; d++)
            b[d] = a[d];
    }
    else if (G(a))
        for (d in b = b || {}, a)
            if ("$" !== d.charAt(0) || "$" !== d.charAt(1))
                b[d] = a[d]; return b || a; }
    function Fe(a, b) { var d = []; Wb(b) && (a = ea.copy(a, null, b)); return JSON.stringify(a, function (a, b) { b = Sc(a, b); if (G(b)) {
        if (0 <= d.indexOf(b))
            return "...";
        d.push(b);
    } return b; }); }
    function Ge(a) {
        P(a, { errorHandlingConfig: qe, bootstrap: Wc, copy: na, extend: P, merge: se, equals: sa, element: z, forEach: q, injector: gb, noop: D, bind: Ta, toJson: eb, fromJson: Tc, identity: ab, isUndefined: x, isDefined: u, isString: F, isFunction: C, isObject: G, isNumber: Y, isElement: Zb, isArray: I, version: He, isDate: da, lowercase: N, uppercase: ub, callbacks: { $$counter: 0 }, getTestability: Be, reloadWithDebugInfo: Ae, $$minErr: M, $$csp: Ia, $$encodeUriSegment: fb, $$encodeUriQuery: ia, $$stringify: hc });
        jc = Ee(y);
        jc("ng", ["ngLocale"], ["$provide", function (a) {
                a.provider({ $$sanitizeUri: Ie });
                a.provider("$compile", $c).directive({ a: Je, input: ad, textarea: ad, form: Ke, script: Le, select: Me, option: Ne, ngBind: Oe, ngBindHtml: Pe, ngBindTemplate: Qe, ngClass: Re, ngClassEven: Se, ngClassOdd: Te, ngCloak: Ue, ngController: Ve, ngForm: We, ngHide: Xe, ngIf: Ye, ngInclude: Ze, ngInit: $e, ngNonBindable: af, ngPluralize: bf, ngRepeat: cf, ngShow: df, ngStyle: ef, ngSwitch: ff, ngSwitchWhen: gf, ngSwitchDefault: hf, ngOptions: jf, ngTransclude: kf, ngModel: lf, ngList: mf, ngChange: nf, pattern: bd, ngPattern: bd, required: cd, ngRequired: cd, minlength: dd, ngMinlength: dd,
                    maxlength: ed, ngMaxlength: ed, ngValue: of, ngModelOptions: pf }).directive({ ngInclude: qf }).directive(vb).directive(fd);
                a.provider({ $anchorScroll: rf, $animate: sf, $animateCss: tf, $$animateJs: uf, $$animateQueue: vf, $$AnimateRunner: wf, $$animateAsyncRun: xf, $browser: yf, $cacheFactory: zf, $controller: Af, $document: Bf, $$isDocumentHidden: Cf, $exceptionHandler: Df, $filter: gd, $$forceReflow: Ef, $interpolate: Ff, $interval: Gf, $http: Hf, $httpParamSerializer: If, $httpParamSerializerJQLike: Jf, $httpBackend: Kf, $xhrFactory: Lf, $jsonpCallbacks: Mf,
                    $location: Nf, $log: Of, $parse: Pf, $rootScope: Qf, $q: Rf, $$q: Sf, $sce: Tf, $sceDelegate: Uf, $sniffer: Vf, $templateCache: Wf, $templateRequest: Xf, $$testability: Yf, $timeout: Zf, $window: $f, $$rAF: ag, $$jqLite: bg, $$Map: cg, $$cookieReader: dg });
            }]).info({ angularVersion: "1.6.10" });
    }
    function wb(a, b) { return b.toUpperCase(); }
    function xb(a) { return a.replace(eg, wb); }
    function kc(a) { a = a.nodeType; return 1 === a || !a || 9 === a; }
    function hd(a, b) {
        var d, c, e = b.createDocumentFragment(), f = [];
        if (lc.test(a)) {
            d = e.appendChild(b.createElement("div"));
            c = (fg.exec(a) || ["", ""])[1].toLowerCase();
            c = $[c] || $._default;
            d.innerHTML = c[1] + a.replace(gg, "<$1></$2>") + c[2];
            for (c = c[0]; c--;)
                d = d.lastChild;
            f = db(f, d.childNodes);
            d = e.firstChild;
            d.textContent = "";
        }
        else
            f.push(b.createTextNode(a));
        e.textContent = "";
        e.innerHTML = "";
        q(f, function (a) { e.appendChild(a); });
        return e;
    }
    function S(a) {
        if (a instanceof S)
            return a;
        var b;
        F(a) && (a = Q(a), b = !0);
        if (!(this instanceof S)) {
            if (b && "<" !== a.charAt(0))
                throw mc("nosel");
            return new S(a);
        }
        if (b) {
            b = y.document;
            var d;
            a = (d = hg.exec(a)) ? [b.createElement(d[1])] :
                (d = hd(a, b)) ? d.childNodes : [];
            nc(this, a);
        }
        else
            C(a) ? id(a) : nc(this, a);
    }
    function oc(a) { return a.cloneNode(!0); }
    function yb(a, b) { !b && kc(a) && z.cleanData([a]); a.querySelectorAll && z.cleanData(a.querySelectorAll("*")); }
    function jd(a, b, d, c) {
        if (u(c))
            throw mc("offargs");
        var e = (c = zb(a)) && c.events, f = c && c.handle;
        if (f)
            if (b) {
                var g = function (b) { var c = e[b]; u(d) && cb(c || [], d); u(d) && c && 0 < c.length || (a.removeEventListener(b, f), delete e[b]); };
                q(b.split(" "), function (a) { g(a); Ab[a] && g(Ab[a]); });
            }
            else
                for (b in e)
                    "$destroy" !== b && a.removeEventListener(b, f), delete e[b];
    }
    function pc(a, b) { var d = a.ng339, c = d && ib[d]; c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), jd(a)), delete ib[d], a.ng339 = void 0)); }
    function zb(a, b) { var d = a.ng339, d = d && ib[d]; b && !d && (a.ng339 = d = ++ig, d = ib[d] = { events: {}, data: {}, handle: void 0 }); return d; }
    function qc(a, b, d) { if (kc(a)) {
        var c, e = u(d), f = !e && b && !G(b), g = !b;
        a = (a = zb(a, !f)) && a.data;
        if (e)
            a[xb(b)] = d;
        else {
            if (g)
                return a;
            if (f)
                return a && a[xb(b)];
            for (c in b)
                a[xb(c)] = b[c];
        }
    } }
    function Bb(a, b) {
        return a.getAttribute ? -1 <
            (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1;
    }
    function Cb(a, b) { if (b && a.setAttribute) {
        var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), c = d;
        q(b.split(" "), function (a) { a = Q(a); c = c.replace(" " + a + " ", " "); });
        c !== d && a.setAttribute("class", Q(c));
    } }
    function Db(a, b) {
        if (b && a.setAttribute) {
            var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), c = d;
            q(b.split(" "), function (a) { a = Q(a); -1 === c.indexOf(" " + a + " ") && (c += a + " "); });
            c !== d && a.setAttribute("class", Q(c));
        }
    }
    function nc(a, b) { if (b)
        if (b.nodeType)
            a[a.length++] = b;
        else {
            var d = b.length;
            if ("number" === typeof d && b.window !== b) {
                if (d)
                    for (var c = 0; c < d; c++)
                        a[a.length++] = b[c];
            }
            else
                a[a.length++] = b;
        } }
    function kd(a, b) { return Eb(a, "$" + (b || "ngController") + "Controller"); }
    function Eb(a, b, d) { 9 === a.nodeType && (a = a.documentElement); for (b = I(b) ? b : [b]; a;) {
        for (var c = 0, e = b.length; c < e; c++)
            if (u(d = z.data(a, b[c])))
                return d;
        a = a.parentNode || 11 === a.nodeType && a.host;
    } }
    function ld(a) { for (yb(a, !0); a.firstChild;)
        a.removeChild(a.firstChild); }
    function Fb(a, b) { b || yb(a); var d = a.parentNode; d && d.removeChild(a); }
    function jg(a, b) { b = b || y; if ("complete" === b.document.readyState)
        b.setTimeout(a);
    else
        z(b).on("load", a); }
    function id(a) { function b() { y.document.removeEventListener("DOMContentLoaded", b); y.removeEventListener("load", b); a(); } "complete" === y.document.readyState ? y.setTimeout(a) : (y.document.addEventListener("DOMContentLoaded", b), y.addEventListener("load", b)); }
    function md(a, b) { var d = Gb[b.toLowerCase()]; return d && nd[ya(a)] && d; }
    function kg(a, b) {
        var d = function (c, d) {
            c.isDefaultPrevented = function () { return c.defaultPrevented; };
            var f = b[d || c.type], g = f ? f.length : 0;
            if (g) {
                if (x(c.immediatePropagationStopped)) {
                    var k = c.stopImmediatePropagation;
                    c.stopImmediatePropagation = function () { c.immediatePropagationStopped = !0; c.stopPropagation && c.stopPropagation(); k && k.call(c); };
                }
                c.isImmediatePropagationStopped = function () { return !0 === c.immediatePropagationStopped; };
                var h = f.specialHandlerWrapper || lg;
                1 < g && (f = pa(f));
                for (var l = 0; l < g; l++)
                    c.isImmediatePropagationStopped() || h(a, c, f[l]);
            }
        };
        d.elem = a;
        return d;
    }
    function lg(a, b, d) { d.call(a, b); }
    function mg(a, b, d) { var c = b.relatedTarget; c && (c === a || ng.call(a, c)) || d.call(a, b); }
    function bg() { this.$get = function () { return P(S, { hasClass: function (a, b) { a.attr && (a = a[0]); return Bb(a, b); }, addClass: function (a, b) { a.attr && (a = a[0]); return Db(a, b); }, removeClass: function (a, b) { a.attr && (a = a[0]); return Cb(a, b); } }); }; }
    function Na(a, b) {
        var d = a && a.$$hashKey;
        if (d)
            return "function" === typeof d && (d = a.$$hashKey()), d;
        d = typeof a;
        return d = "function" === d || "object" === d && null !==
            a ? a.$$hashKey = d + ":" + (b || re)() : d + ":" + a;
    }
    function od() { this._keys = []; this._values = []; this._lastKey = NaN; this._lastIndex = -1; }
    function pd(a) { a = Function.prototype.toString.call(a).replace(og, ""); return a.match(pg) || a.match(qg); }
    function rg(a) { return (a = pd(a)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"; }
    function gb(a, b) {
        function d(a) { return function (b, c) { if (G(b))
            q(b, Xb(a));
        else
            return a(b, c); }; }
        function c(a, b) {
            Ha(a, "service");
            if (C(b) || I(b))
                b = n.instantiate(b);
            if (!b.$get)
                throw Aa("pget", a);
            return p[a +
                "Provider"] = b;
        }
        function e(a, b) { return function () { var c = E.invoke(b, this); if (x(c))
            throw Aa("undef", a); return c; }; }
        function f(a, b, d) { return c(a, { $get: !1 !== d ? e(a, b) : b }); }
        function g(a) {
            hb(x(a) || I(a), "modulesToLoad", "not an array");
            var b = [], c;
            q(a, function (a) {
                function d(a) { var b, c; b = 0; for (c = a.length; b < c; b++) {
                    var e = a[b], g = n.get(e[0]);
                    g[e[1]].apply(g, e[2]);
                } }
                if (!m.get(a)) {
                    m.set(a, !0);
                    try {
                        F(a) ? (c = jc(a), E.modules[a] = c, b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)) : C(a) ? b.push(n.invoke(a)) :
                            I(a) ? b.push(n.invoke(a)) : sb(a, "module");
                    }
                    catch (e) {
                        throw I(a) && (a = a[a.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), Aa("modulerr", a, e.stack || e.message || e);
                    }
                }
            });
            return b;
        }
        function k(a, c) {
            function d(b, e) { if (a.hasOwnProperty(b)) {
                if (a[b] === h)
                    throw Aa("cdep", b + " <- " + l.join(" <- "));
                return a[b];
            } try {
                return l.unshift(b), a[b] = h, a[b] = c(b, e), a[b];
            }
            catch (g) {
                throw a[b] === h && delete a[b], g;
            }
            finally {
                l.shift();
            } }
            function e(a, c, g) {
                var f = [];
                a = gb.$$annotate(a, b, g);
                for (var h = 0, k = a.length; h < k; h++) {
                    var l = a[h];
                    if ("string" !== typeof l)
                        throw Aa("itkn", l);
                    f.push(c && c.hasOwnProperty(l) ? c[l] : d(l, g));
                }
                return f;
            }
            return { invoke: function (a, b, c, d) { "string" === typeof c && (d = c, c = null); c = e(a, c, d); I(a) && (a = a[a.length - 1]); d = a; if (Ba || "function" !== typeof d)
                    d = !1;
                else {
                    var g = d.$$ngIsClass;
                    La(g) || (g = d.$$ngIsClass = /^(?:class\b|constructor\()/.test(Function.prototype.toString.call(d)));
                    d = g;
                } return d ? (c.unshift(null), new (Function.prototype.bind.apply(a, c))) : a.apply(b, c); }, instantiate: function (a, b, c) {
                    var d = I(a) ? a[a.length - 1] : a;
                    a = e(a, b, c);
                    a.unshift(null);
                    return new (Function.prototype.bind.apply(d, a));
                }, get: d, annotate: gb.$$annotate, has: function (b) { return p.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b); } };
        }
        b = !0 === b;
        var h = {}, l = [], m = new Hb, p = { $provide: { provider: d(c), factory: d(f), service: d(function (a, b) { return f(a, ["$injector", function (a) { return a.instantiate(b); }]); }), value: d(function (a, b) { return f(a, ka(b), !1); }), constant: d(function (a, b) { Ha(a, "constant"); p[a] = b; B[a] = b; }), decorator: function (a, b) {
                    var c = n.get(a +
                        "Provider"), d = c.$get;
                    c.$get = function () { var a = E.invoke(d, c); return E.invoke(b, null, { $delegate: a }); };
                } } }, n = p.$injector = k(p, function (a, b) { ea.isString(b) && l.push(b); throw Aa("unpr", l.join(" <- ")); }), B = {}, v = k(B, function (a, b) { var c = n.get(a + "Provider", b); return E.invoke(c.$get, c, void 0, a); }), E = v;
        p.$injectorProvider = { $get: ka(v) };
        E.modules = n.modules = R();
        var A = g(a), E = v.get("$injector");
        E.strictDi = b;
        q(A, function (a) { a && E.invoke(a); });
        E.loadNewModules = function (a) { q(g(a), function (a) { a && E.invoke(a); }); };
        return E;
    }
    function rf() {
        var a = !0;
        this.disableAutoScrolling = function () { a = !1; };
        this.$get = ["$window", "$location", "$rootScope", function (b, d, c) {
                function e(a) { var b = null; Array.prototype.some.call(a, function (a) { if ("a" === ya(a))
                    return b = a, !0; }); return b; }
                function f(a) { if (a) {
                    a.scrollIntoView();
                    var c;
                    c = g.yOffset;
                    C(c) ? c = c() : Zb(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Y(c) || (c = 0);
                    c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c));
                }
                else
                    b.scrollTo(0, 0); }
                function g(a) {
                    a = F(a) ? a : Y(a) ? a.toString() :
                        d.hash();
                    var b;
                    a ? (b = k.getElementById(a)) ? f(b) : (b = e(k.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null);
                }
                var k = b.document;
                a && c.$watch(function () { return d.hash(); }, function (a, b) { a === b && "" === a || jg(function () { c.$evalAsync(g); }); });
                return g;
            }];
    }
    function jb(a, b) { if (!a && !b)
        return ""; if (!a)
        return b; if (!b)
        return a; I(a) && (a = a.join(" ")); I(b) && (b = b.join(" ")); return a + " " + b; }
    function sg(a) { F(a) && (a = a.split(" ")); var b = R(); q(a, function (a) { a.length && (b[a] = !0); }); return b; }
    function Ja(a) { return G(a) ? a : {}; }
    function tg(a, b, d, c) {
        function e(a) { try {
            a.apply(null, xa.call(arguments, 1));
        }
        finally {
            if (v--, 0 === v)
                for (; E.length;)
                    try {
                        E.pop()();
                    }
                    catch (b) {
                        d.error(b);
                    }
        } }
        function f() { w = null; k(); }
        function g() { A = H(); A = x(A) ? null : A; sa(A, t) && (A = t); s = t = A; }
        function k() { var a = s; g(); if (J !== h.url() || a !== A)
            J = h.url(), s = A, q(K, function (a) { a(h.url(), A); }); }
        var h = this, l = a.location, m = a.history, p = a.setTimeout, n = a.clearTimeout, B = {};
        h.isMock = !1;
        var v = 0, E = [];
        h.$$completeOutstandingRequest = e;
        h.$$incOutstandingRequestCount = function () { v++; };
        h.notifyWhenNoOutstandingRequests =
            function (a) { 0 === v ? a() : E.push(a); };
        var A, s, J = l.href, ic = b.find("base"), w = null, H = c.history ? function () { try {
            return m.state;
        }
        catch (a) { } } : D;
        g();
        h.url = function (b, d, e) {
            x(e) && (e = null);
            l !== a.location && (l = a.location);
            m !== a.history && (m = a.history);
            if (b) {
                var f = s === e;
                if (J === b && (!c.history || f))
                    return h;
                var k = J && Ka(J) === Ka(b);
                J = b;
                s = e;
                !c.history || k && f ? (k || (w = b), d ? l.replace(b) : k ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), d.hash = e) : l.href = b, l.href !== b && (w = b)) : (m[d ? "replaceState" : "pushState"](e, "", b), g());
                w && (w = b);
                return h;
            }
            return w ||
                l.href.replace(/%27/g, "'");
        };
        h.state = function () { return A; };
        var K = [], T = !1, t = null;
        h.onUrlChange = function (b) { if (!T) {
            if (c.history)
                z(a).on("popstate", f);
            z(a).on("hashchange", f);
            T = !0;
        } K.push(b); return b; };
        h.$$applicationDestroyed = function () { z(a).off("hashchange popstate", f); };
        h.$$checkUrlChange = k;
        h.baseHref = function () { var a = ic.attr("href"); return a ? a.replace(/^(https?:)?\/\/[^/]*/, "") : ""; };
        h.defer = function (a, b) { var c; v++; c = p(function () { delete B[c]; e(a); }, b || 0); B[c] = !0; return c; };
        h.defer.cancel = function (a) {
            return B[a] ?
                (delete B[a], n(a), e(D), !0) : !1;
        };
    }
    function yf() { this.$get = ["$window", "$log", "$sniffer", "$document", function (a, b, d, c) { return new tg(a, c, b, d); }]; }
    function zf() {
        this.$get = function () {
            function a(a, c) {
                function e(a) { a !== p && (n ? n === a && (n = a.n) : n = a, f(a.n, a.p), f(a, p), p = a, p.n = null); }
                function f(a, b) { a !== b && (a && (a.p = b), b && (b.n = a)); }
                if (a in b)
                    throw M("$cacheFactory")("iid", a);
                var g = 0, k = P({}, c, { id: a }), h = R(), l = c && c.capacity || Number.MAX_VALUE, m = R(), p = null, n = null;
                return b[a] = { put: function (a, b) {
                        if (!x(b)) {
                            if (l < Number.MAX_VALUE) {
                                var c = m[a] || (m[a] = { key: a });
                                e(c);
                            }
                            a in h || g++;
                            h[a] = b;
                            g > l && this.remove(n.key);
                            return b;
                        }
                    }, get: function (a) { if (l < Number.MAX_VALUE) {
                        var b = m[a];
                        if (!b)
                            return;
                        e(b);
                    } return h[a]; }, remove: function (a) { if (l < Number.MAX_VALUE) {
                        var b = m[a];
                        if (!b)
                            return;
                        b === p && (p = b.p);
                        b === n && (n = b.n);
                        f(b.n, b.p);
                        delete m[a];
                    } a in h && (delete h[a], g--); }, removeAll: function () { h = R(); g = 0; m = R(); p = n = null; }, destroy: function () { m = k = h = null; delete b[a]; }, info: function () { return P({}, k, { size: g }); } };
            }
            var b = {};
            a.info = function () {
                var a = {};
                q(b, function (b, e) { a[e] = b.info(); });
                return a;
            };
            a.get = function (a) { return b[a]; };
            return a;
        };
    }
    function Wf() { this.$get = ["$cacheFactory", function (a) { return a("templates"); }]; }
    function $c(a, b) {
        function d(a, b, c) { var d = /^([@&<]|=(\*?))(\??)\s*([\w$]*)$/, e = R(); q(a, function (a, g) { a = a.trim(); if (a in p)
            e[g] = p[a];
        else {
            var f = a.match(d);
            if (!f)
                throw aa("iscp", b, g, a, c ? "controller bindings definition" : "isolate scope definition");
            e[g] = { mode: f[1][0], collection: "*" === f[2], optional: "?" === f[3], attrName: f[4] || g };
            f[4] && (p[a] = e[g]);
        } }); return e; }
        function c(a) {
            var b = a.charAt(0);
            if (!b || b !== N(b))
                throw aa("baddir", a);
            if (a !== a.trim())
                throw aa("baddir", a);
        }
        function e(a) { var b = a.require || a.controller && a.name; !I(b) && G(b) && q(b, function (a, c) { var d = a.match(l); a.substring(d[0].length) || (b[c] = d[0] + c); }); return b; }
        var f = {}, g = /^\s*directive:\s*([\w-]+)\s+(.*)$/, k = /(([\w-]+)(?::([^;]+))?;?)/, h = ve("ngSrc,ngSrcset,src,srcset"), l = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, m = /^(on[a-z]+|formaction)$/, p = R();
        this.directive = function ic(b, d) {
            hb(b, "name");
            Ha(b, "directive");
            F(b) ? (c(b), hb(d, "directiveFactory"),
                f.hasOwnProperty(b) || (f[b] = [], a.factory(b + "Directive", ["$injector", "$exceptionHandler", function (a, c) { var d = []; q(f[b], function (g, f) { try {
                        var h = a.invoke(g);
                        C(h) ? h = { compile: ka(h) } : !h.compile && h.link && (h.compile = ka(h.link));
                        h.priority = h.priority || 0;
                        h.index = f;
                        h.name = h.name || b;
                        h.require = e(h);
                        var k = h, l = h.restrict;
                        if (l && (!F(l) || !/[EACM]/.test(l)))
                            throw aa("badrestrict", l, b);
                        k.restrict = l || "EA";
                        h.$$moduleName = g.$$moduleName;
                        d.push(h);
                    }
                    catch (m) {
                        c(m);
                    } }); return d; }])), f[b].push(d)) : q(b, Xb(ic));
            return this;
        };
        this.component =
            function w(a, b) {
                function c(a) { function e(b) { return C(b) || I(b) ? function (c, d) { return a.invoke(b, this, { $element: c, $attrs: d }); } : b; } var g = b.template || b.templateUrl ? b.template : "", f = { controller: d, controllerAs: ug(b.controller) || b.controllerAs || "$ctrl", template: e(g), templateUrl: e(b.templateUrl), transclude: b.transclude, scope: {}, bindToController: b.bindings || {}, restrict: "E", require: b.require }; q(b, function (a, b) { "$" === b.charAt(0) && (f[b] = a); }); return f; }
                if (!F(a))
                    return q(a, Xb(Ta(this, w))), this;
                var d = b.controller || function () { };
                q(b, function (a, b) { "$" === b.charAt(0) && (c[b] = a, C(d) && (d[b] = a)); });
                c.$inject = ["$injector"];
                return this.directive(a, c);
            };
        this.aHrefSanitizationWhitelist = function (a) { return u(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist(); };
        this.imgSrcSanitizationWhitelist = function (a) { return u(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist(); };
        var n = !0;
        this.debugInfoEnabled = function (a) { return u(a) ? (n = a, this) : n; };
        var B = !1;
        this.preAssignBindingsEnabled = function (a) {
            return u(a) ?
                (B = a, this) : B;
        };
        var v = !1;
        this.strictComponentBindingsEnabled = function (a) { return u(a) ? (v = a, this) : v; };
        var E = 10;
        this.onChangesTtl = function (a) { return arguments.length ? (E = a, this) : E; };
        var A = !0;
        this.commentDirectivesEnabled = function (a) { return arguments.length ? (A = a, this) : A; };
        var s = !0;
        this.cssClassDirectivesEnabled = function (a) { return arguments.length ? (s = a, this) : s; };
        this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function (a, b, c, e, p, V, O, qa, L, r) {
                function la() { try {
                    if (!--Ea)
                        throw ga = void 0, aa("infchng", E);
                    O.$apply(function () { for (var a = 0, b = ga.length; a < b; ++a)
                        try {
                            ga[a]();
                        }
                        catch (d) {
                            c(d);
                        } ga = void 0; });
                }
                finally {
                    Ea++;
                } }
                function rc(a, b) { if (b) {
                    var c = Object.keys(b), d, e, g;
                    d = 0;
                    for (e = c.length; d < e; d++)
                        g = c[d], this[g] = b[g];
                }
                else
                    this.$attr = {}; this.$$element = a; }
                function Oa(a, b, c) { Aa.innerHTML = "<span " + b + ">"; b = Aa.firstChild.attributes; var d = b[0]; b.removeNamedItem(d.name); d.value = c; a.attributes.setNamedItem(d); }
                function Pa(a, b) { try {
                    a.addClass(b);
                }
                catch (c) { } }
                function ba(a, b, c, d, e) {
                    a instanceof z || (a = z(a));
                    var g = Sa(a, b, a, c, d, e);
                    ba.$$addScopeClass(a);
                    var f = null;
                    return function (b, c, d) {
                        if (!a)
                            throw aa("multilink");
                        hb(b, "scope");
                        e && e.needsNewScope && (b = b.$parent.$new());
                        d = d || {};
                        var h = d.parentBoundTranscludeFn, k = d.transcludeControllers;
                        d = d.futureParentElement;
                        h && h.$$boundTransclude && (h = h.$$boundTransclude);
                        f || (f = (d = d && d[0]) ? "foreignobject" !== ya(d) && ha.call(d).match(/SVG/) ? "svg" : "html" : "html");
                        d = "html" !== f ? z(fa(f, z("<div></div>").append(a).html())) : c ? Ua.clone.call(a) :
                            a;
                        if (k)
                            for (var l in k)
                                d.data("$" + l + "Controller", k[l].instance);
                        ba.$$addScopeInfo(d, b);
                        c && c(d, b);
                        g && g(b, d, d, h);
                        c || (a = g = null);
                        return d;
                    };
                }
                function Sa(a, b, c, d, e, g) {
                    function f(a, c, d, e) {
                        var g, k, l, m, p, n, H;
                        if (K)
                            for (H = Array(c.length), m = 0; m < h.length; m += 3)
                                g = h[m], H[g] = c[g];
                        else
                            H = c;
                        m = 0;
                        for (p = h.length; m < p;)
                            k = H[h[m++]], c = h[m++], g = h[m++], c ? (c.scope ? (l = a.$new(), ba.$$addScopeInfo(z(k), l)) : l = a, n = c.transcludeOnThisElement ? Qa(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? Qa(a, b) : null, c(g, l, k, d, n)) : g && g(a, k.childNodes, void 0, e);
                    }
                    for (var h = [], k = I(a) || a instanceof z, l, m, p, n, K, H = 0; H < a.length; H++) {
                        l = new rc;
                        11 === Ba && Ca(a, H, k);
                        m = sc(a[H], [], l, 0 === H ? d : void 0, e);
                        (g = m.length ? Y(m, a[H], l, b, c, null, [], [], g) : null) && g.scope && ba.$$addScopeClass(l.$$element);
                        l = g && g.terminal || !(p = a[H].childNodes) || !p.length ? null : Sa(p, g ? (g.transcludeOnThisElement || !g.templateOnThisElement) && g.transclude : b);
                        if (g || l)
                            h.push(H, g, l), n = !0, K = K || g;
                        g = null;
                    }
                    return n ? f : null;
                }
                function Ca(a, b, c) {
                    var d = a[b], e = d.parentNode, g;
                    if (d.nodeType === Ma)
                        for (;;) {
                            g = e ? d.nextSibling :
                                a[b + 1];
                            if (!g || g.nodeType !== Ma)
                                break;
                            d.nodeValue += g.nodeValue;
                            g.parentNode && g.parentNode.removeChild(g);
                            c && g === a[b + 1] && a.splice(b + 1, 1);
                        }
                }
                function Qa(a, b, c) { function d(e, g, f, h, k) { e || (e = a.$new(!1, k), e.$$transcluded = !0); return b(e, g, { parentBoundTranscludeFn: c, transcludeControllers: f, futureParentElement: h }); } var e = d.$$slots = R(), g; for (g in b.$$slots)
                    e[g] = b.$$slots[g] ? Qa(a, b.$$slots[g], c) : null; return d; }
                function sc(a, b, c, d, e) {
                    var g = c.$attr, f;
                    switch (a.nodeType) {
                        case 1:
                            f = ya(a);
                            X(b, Da(f), "E", d, e);
                            for (var h, l, m, p, n = a.attributes, K = 0, H = n && n.length; K < H; K++) {
                                var B = !1, w = !1;
                                h = n[K];
                                l = h.name;
                                m = h.value;
                                h = Da(l);
                                (p = Na.test(h)) && (l = l.replace(qd, "").substr(8).replace(/_(.)/g, function (a, b) { return b.toUpperCase(); }));
                                (h = h.match(Ra)) && ea(h[1]) && (B = l, w = l.substr(0, l.length - 5) + "end", l = l.substr(0, l.length - 6));
                                h = Da(l.toLowerCase());
                                g[h] = l;
                                if (p || !c.hasOwnProperty(h))
                                    c[h] = m, md(a, h) && (c[h] = !0);
                                va(a, b, m, h, p);
                                X(b, h, "A", d, e, B, w);
                            }
                            "input" === f && "hidden" === a.getAttribute("type") && a.setAttribute("autocomplete", "off");
                            if (!Ka)
                                break;
                            g = a.className;
                            G(g) && (g = g.animVal);
                            if (F(g) && "" !== g)
                                for (; a = k.exec(g);)
                                    h = Da(a[2]), X(b, h, "C", d, e) && (c[h] = Q(a[3])), g = g.substr(a.index + a[0].length);
                            break;
                        case Ma:
                            ma(b, a.nodeValue);
                            break;
                        case 8:
                            if (!Ja)
                                break;
                            M(a, b, c, d, e);
                    }
                    b.sort(ka);
                    return b;
                }
                function M(a, b, c, d, e) { try {
                    var f = g.exec(a.nodeValue);
                    if (f) {
                        var h = Da(f[1]);
                        X(b, h, "M", d, e) && (c[h] = Q(f[2]));
                    }
                }
                catch (k) { } }
                function rd(a, b, c) {
                    var d = [], e = 0;
                    if (b && a.hasAttribute && a.hasAttribute(b)) {
                        do {
                            if (!a)
                                throw aa("uterdir", b, c);
                            1 === a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--);
                            d.push(a);
                            a = a.nextSibling;
                        } while (0 < e);
                    }
                    else
                        d.push(a);
                    return z(d);
                }
                function S(a, b, c) { return function (d, e, g, f, h) { e = rd(e[0], b, c); return a(d, e, g, f, h); }; }
                function U(a, b, c, d, e, g) { var f; return a ? ba(b, c, d, e, g) : function () { f || (f = ba(b, c, d, e, g), b = c = g = null); return f.apply(this, arguments); }; }
                function Y(a, b, d, e, g, f, h, k, l) {
                    function m(a, b, c, d) {
                        if (a) {
                            c && (a = S(a, c, d));
                            a.require = t.require;
                            a.directiveName = L;
                            if (O === t || t.$$isolateScope)
                                a = ta(a, { isolateScope: !0 });
                            h.push(a);
                        }
                        if (b) {
                            c && (b = S(b, c, d));
                            b.require = t.require;
                            b.directiveName =
                                L;
                            if (O === t || t.$$isolateScope)
                                b = ta(b, { isolateScope: !0 });
                            k.push(b);
                        }
                    }
                    function p(a, e, g, f, l) {
                        function m(a, b, c, d) { var e; bb(a) || (d = c, c = b, b = a, a = void 0); qa && (e = E); c || (c = qa ? L.parent() : L); if (d) {
                            var g = l.$$slots[d];
                            if (g)
                                return g(a, b, e, c, ua);
                            if (x(g))
                                throw aa("noslot", d, za(L));
                        }
                        else
                            return l(a, b, e, c, ua); }
                        var n, t, v, s, T, E, V, L;
                        b === g ? (f = d, L = d.$$element) : (L = z(g), f = new rc(L, d));
                        T = e;
                        O ? s = e.$new(!0) : H && (T = e.$parent);
                        l && (V = m, V.$$boundTransclude = l, V.isSlotFilled = function (a) { return !!l.$$slots[a]; });
                        w && (E = ca(L, f, V, w, s, e, O));
                        O &&
                            (ba.$$addScopeInfo(L, s, !0, !(A && (A === O || A === O.$$originalDirective))), ba.$$addScopeClass(L, !0), s.$$isolateBindings = O.$$isolateBindings, t = oa(e, f, s, s.$$isolateBindings, O), t.removeWatches && s.$on("$destroy", t.removeWatches));
                        for (n in E) {
                            t = w[n];
                            v = E[n];
                            var Ib = t.$$bindings.bindToController;
                            if (B) {
                                v.bindingInfo = Ib ? oa(T, f, v.instance, Ib, t) : {};
                                var r = v();
                                r !== v.instance && (v.instance = r, L.data("$" + t.name + "Controller", r), v.bindingInfo.removeWatches && v.bindingInfo.removeWatches(), v.bindingInfo = oa(T, f, v.instance, Ib, t));
                            }
                            else
                                v.instance =
                                    v(), L.data("$" + t.name + "Controller", v.instance), v.bindingInfo = oa(T, f, v.instance, Ib, t);
                        }
                        q(w, function (a, b) { var c = a.require; a.bindToController && !I(c) && G(c) && P(E[b].instance, W(b, c, L, E)); });
                        q(E, function (a) { var b = a.instance; if (C(b.$onChanges))
                            try {
                                b.$onChanges(a.bindingInfo.initialChanges);
                            }
                            catch (d) {
                                c(d);
                            } if (C(b.$onInit))
                            try {
                                b.$onInit();
                            }
                            catch (e) {
                                c(e);
                            } C(b.$doCheck) && (T.$watch(function () { b.$doCheck(); }), b.$doCheck()); C(b.$onDestroy) && T.$on("$destroy", function () { b.$onDestroy(); }); });
                        n = 0;
                        for (t = h.length; n < t; n++)
                            v = h[n],
                                wa(v, v.isolateScope ? s : e, L, f, v.require && W(v.directiveName, v.require, L, E), V);
                        var ua = e;
                        O && (O.template || null === O.templateUrl) && (ua = s);
                        a && a(ua, g.childNodes, void 0, l);
                        for (n = k.length - 1; 0 <= n; n--)
                            v = k[n], wa(v, v.isolateScope ? s : e, L, f, v.require && W(v.directiveName, v.require, L, E), V);
                        q(E, function (a) { a = a.instance; C(a.$postLink) && a.$postLink(); });
                    }
                    l = l || {};
                    for (var n = -Number.MAX_VALUE, H = l.newScopeDirective, w = l.controllerDirectives, O = l.newIsolateScopeDirective, A = l.templateDirective, s = l.nonTlbTranscludeDirective, T = !1, E = !1, qa = l.hasElementTranscludeDirective, v = d.$$element = z(b), t, L, V, r = e, ua, la = !1, u = !1, y, Ca = 0, Oa = a.length; Ca < Oa; Ca++) {
                        t = a[Ca];
                        var Pa = t.$$start, D = t.$$end;
                        Pa && (v = rd(b, Pa, D));
                        V = void 0;
                        if (n > t.priority)
                            break;
                        if (y = t.scope)
                            t.templateUrl || (G(y) ? ($("new/isolated scope", O || H, t, v), O = t) : $("new/isolated scope", O, t, v)), H = H || t;
                        L = t.name;
                        if (!la && (t.replace && (t.templateUrl || t.template) || t.transclude && !t.$$tlb)) {
                            for (y = Ca + 1; la = a[y++];)
                                if (la.transclude && !la.$$tlb || la.replace && (la.templateUrl || la.template)) {
                                    u = !0;
                                    break;
                                }
                            la = !0;
                        }
                        !t.templateUrl &&
                            t.controller && (w = w || R(), $("'" + L + "' controller", w[L], t, v), w[L] = t);
                        if (y = t.transclude)
                            if (T = !0, t.$$tlb || ($("transclusion", s, t, v), s = t), "element" === y)
                                qa = !0, n = t.priority, V = v, v = d.$$element = z(ba.$$createComment(L, d[L])), b = v[0], ja(g, xa.call(V, 0), b), V[0].$$parentNode = V[0].parentNode, r = U(u, V, e, n, f && f.name, { nonTlbTranscludeDirective: s });
                            else {
                                var F = R();
                                if (G(y)) {
                                    V = [];
                                    var Qa = R(), M = R();
                                    q(y, function (a, b) { var c = "?" === a.charAt(0); a = c ? a.substring(1) : a; Qa[a] = b; F[b] = null; M[b] = c; });
                                    q(v.contents(), function (a) {
                                        var b = Qa[Da(ya(a))];
                                        b ? (M[b] = !0, F[b] = F[b] || [], F[b].push(a)) : V.push(a);
                                    });
                                    q(M, function (a, b) { if (!a)
                                        throw aa("reqslot", b); });
                                    for (var Sa in F)
                                        F[Sa] && (F[Sa] = U(u, F[Sa], e));
                                }
                                else
                                    V = z(oc(b)).contents();
                                v.empty();
                                r = U(u, V, e, void 0, void 0, { needsNewScope: t.$$isolateScope || t.$$newScope });
                                r.$$slots = F;
                            }
                        if (t.template)
                            if (E = !0, $("template", A, t, v), A = t, y = C(t.template) ? t.template(v, d) : t.template, y = Ha(y), t.replace) {
                                f = t;
                                V = lc.test(y) ? sd(fa(t.templateNamespace, Q(y))) : [];
                                b = V[0];
                                if (1 !== V.length || 1 !== b.nodeType)
                                    throw aa("tplrt", L, "");
                                ja(g, v, b);
                                Oa =
                                    { $attr: {} };
                                y = sc(b, [], Oa);
                                var N = a.splice(Ca + 1, a.length - (Ca + 1));
                                (O || H) && Z(y, O, H);
                                a = a.concat(y).concat(N);
                                da(d, Oa);
                                Oa = a.length;
                            }
                            else
                                v.html(y);
                        if (t.templateUrl)
                            E = !0, $("template", A, t, v), A = t, t.replace && (f = t), p = ia(a.splice(Ca, a.length - Ca), v, d, g, T && r, h, k, { controllerDirectives: w, newScopeDirective: H !== t && H, newIsolateScopeDirective: O, templateDirective: A, nonTlbTranscludeDirective: s }), Oa = a.length;
                        else if (t.compile)
                            try {
                                ua = t.compile(v, d, r);
                                var tc = t.$$originalDirective || t;
                                C(ua) ? m(null, Ta(tc, ua), Pa, D) : ua && m(Ta(tc, ua.pre), Ta(tc, ua.post), Pa, D);
                            }
                            catch (X) {
                                c(X, za(v));
                            }
                        t.terminal && (p.terminal = !0, n = Math.max(n, t.priority));
                    }
                    p.scope = H && !0 === H.scope;
                    p.transcludeOnThisElement = T;
                    p.templateOnThisElement = E;
                    p.transclude = r;
                    l.hasElementTranscludeDirective = qa;
                    return p;
                }
                function W(a, b, c, d) {
                    var e;
                    if (F(b)) {
                        var g = b.match(l);
                        b = b.substring(g[0].length);
                        var f = g[1] || g[3], g = "?" === g[2];
                        "^^" === f ? c = c.parent() : e = (e = d && d[b]) && e.instance;
                        if (!e) {
                            var h = "$" + b + "Controller";
                            e = f ? c.inheritedData(h) : c.data(h);
                        }
                        if (!e && !g)
                            throw aa("ctreq", b, a);
                    }
                    else if (I(b))
                        for (e =
                            [], f = 0, g = b.length; f < g; f++)
                            e[f] = W(a, b[f], c, d);
                    else
                        G(b) && (e = {}, q(b, function (b, g) { e[g] = W(a, b, c, d); }));
                    return e || null;
                }
                function ca(a, b, c, d, e, g, f) { var h = R(), k; for (k in d) {
                    var l = d[k], m = { $scope: l === f || l.$$isolateScope ? e : g, $element: a, $attrs: b, $transclude: c }, p = l.controller;
                    "@" === p && (p = b[l.name]);
                    m = V(p, m, !0, l.controllerAs);
                    h[l.name] = m;
                    a.data("$" + l.name + "Controller", m.instance);
                } return h; }
                function Z(a, b, c) { for (var d = 0, e = a.length; d < e; d++)
                    a[d] = $b(a[d], { $$isolateScope: b, $$newScope: c }); }
                function X(b, c, e, g, h, k, l) {
                    if (c ===
                        h)
                        return null;
                    var m = null;
                    if (f.hasOwnProperty(c)) {
                        h = a.get(c + "Directive");
                        for (var p = 0, n = h.length; p < n; p++)
                            if (c = h[p], (x(g) || g > c.priority) && -1 !== c.restrict.indexOf(e)) {
                                k && (c = $b(c, { $$start: k, $$end: l }));
                                if (!c.$$bindings) {
                                    var H = m = c, K = c.name, t = { isolateScope: null, bindToController: null };
                                    G(H.scope) && (!0 === H.bindToController ? (t.bindToController = d(H.scope, K, !0), t.isolateScope = {}) : t.isolateScope = d(H.scope, K, !1));
                                    G(H.bindToController) && (t.bindToController = d(H.bindToController, K, !0));
                                    if (t.bindToController && !H.controller)
                                        throw aa("noctrl", K);
                                    m = m.$$bindings = t;
                                    G(m.isolateScope) && (c.$$isolateBindings = m.isolateScope);
                                }
                                b.push(c);
                                m = c;
                            }
                    }
                    return m;
                }
                function ea(b) { if (f.hasOwnProperty(b))
                    for (var c = a.get(b + "Directive"), d = 0, e = c.length; d < e; d++)
                        if (b = c[d], b.multiElement)
                            return !0; return !1; }
                function da(a, b) { var c = b.$attr, d = a.$attr; q(a, function (d, e) { "$" !== e.charAt(0) && (b[e] && b[e] !== d && (d = d.length ? d + (("style" === e ? ";" : " ") + b[e]) : b[e]), a.$set(e, d, !0, c[e])); }); q(b, function (b, e) { a.hasOwnProperty(e) || "$" === e.charAt(0) || (a[e] = b, "class" !== e && "style" !== e && (d[e] = c[e])); }); }
                function ia(a, b, d, g, f, h, k, l) {
                    var m = [], p, n, H = b[0], t = a.shift(), B = $b(t, { templateUrl: null, transclude: null, replace: null, $$originalDirective: t }), v = C(t.templateUrl) ? t.templateUrl(b, d) : t.templateUrl, O = t.templateNamespace;
                    b.empty();
                    e(v).then(function (c) {
                        var e, K;
                        c = Ha(c);
                        if (t.replace) {
                            c = lc.test(c) ? sd(fa(O, Q(c))) : [];
                            e = c[0];
                            if (1 !== c.length || 1 !== e.nodeType)
                                throw aa("tplrt", t.name, v);
                            c = { $attr: {} };
                            ja(g, b, e);
                            var w = sc(e, [], c);
                            G(t.scope) && Z(w, !0);
                            a = w.concat(a);
                            da(d, c);
                        }
                        else
                            e = H, b.html(c);
                        a.unshift(B);
                        p = Y(a, e, d, f, b, t, h, k, l);
                        q(g, function (a, c) { a === e && (g[c] = b[0]); });
                        for (n = Sa(b[0].childNodes, f); m.length;) {
                            c = m.shift();
                            K = m.shift();
                            var s = m.shift(), A = m.shift(), w = b[0];
                            if (!c.$$destroyed) {
                                if (K !== H) {
                                    var T = K.className;
                                    l.hasElementTranscludeDirective && t.replace || (w = oc(e));
                                    ja(s, z(K), w);
                                    Pa(z(w), T);
                                }
                                K = p.transcludeOnThisElement ? Qa(c, p.transclude, A) : A;
                                p(n, c, w, g, K);
                            }
                        }
                        m = null;
                    }).catch(function (a) { bc(a) && c(a); });
                    return function (a, b, c, d, e) {
                        a = e;
                        b.$$destroyed || (m ? m.push(b, c, d, a) : (p.transcludeOnThisElement && (a = Qa(b, p.transclude, e)), p(n, b, c, d, a)));
                    };
                }
                function ka(a, b) { var c = b.priority - a.priority; return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index; }
                function $(a, b, c, d) { function e(a) { return a ? " (module: " + a + ")" : ""; } if (b)
                    throw aa("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, za(d)); }
                function ma(a, c) {
                    var d = b(c, !0);
                    d && a.push({ priority: 0, compile: function (a) {
                            a = a.parent();
                            var b = !!a.length;
                            b && ba.$$addBindingClass(a);
                            return function (a, c) {
                                var e = c.parent();
                                b || ba.$$addBindingClass(e);
                                ba.$$addBindingInfo(e, d.expressions);
                                a.$watch(d, function (a) { c[0].nodeValue = a; });
                            };
                        } });
                }
                function fa(a, b) { a = N(a || "html"); switch (a) {
                    case "svg":
                    case "math":
                        var c = y.document.createElement("div");
                        c.innerHTML = "<" + a + ">" + b + "</" + a + ">";
                        return c.childNodes[0].childNodes;
                    default: return b;
                } }
                function pa(a, b) { if ("srcdoc" === b)
                    return qa.HTML; var c = ya(a); if ("src" === b || "ngSrc" === b) {
                    if (-1 === ["img", "video", "audio", "source", "track"].indexOf(c))
                        return qa.RESOURCE_URL;
                }
                else if ("xlinkHref" === b || "form" === c && "action" === b || "link" === c && "href" === b)
                    return qa.RESOURCE_URL; }
                function va(a, c, d, e, g) { var f = pa(a, e), k = h[e] || g, l = b(d, !g, f, k); if (l) {
                    if ("multiple" === e && "select" === ya(a))
                        throw aa("selmulti", za(a));
                    if (m.test(e))
                        throw aa("nodomevents");
                    c.push({ priority: 100, compile: function () { return { pre: function (a, c, g) { c = g.$$observers || (g.$$observers = R()); var h = g[e]; h !== d && (l = h && b(h, !0, f, k), d = h); l && (g[e] = l(a), (c[e] || (c[e] = [])).$$inter = !0, (g.$$observers && g.$$observers[e].$$scope || a).$watch(l, function (a, b) { "class" === e && a !== b ? g.$updateClass(a, b) : g.$set(e, a); })); } }; } });
                } }
                function ja(a, b, c) {
                    var d = b[0], e = b.length, g = d.parentNode, f, h;
                    if (a)
                        for (f = 0, h = a.length; f < h; f++)
                            if (a[f] === d) {
                                a[f++] = c;
                                h = f + e - 1;
                                for (var k = a.length; f < k; f++, h++)
                                    h < k ? a[f] = a[h] : delete a[f];
                                a.length -= e - 1;
                                a.context === d && (a.context = c);
                                break;
                            }
                    g && g.replaceChild(c, d);
                    a = y.document.createDocumentFragment();
                    for (f = 0; f < e; f++)
                        a.appendChild(b[f]);
                    z.hasData(d) && (z.data(c, z.data(d)), z(d).off("$destroy"));
                    z.cleanData(a.querySelectorAll("*"));
                    for (f = 1; f < e; f++)
                        delete b[f];
                    b[0] = c;
                    b.length = 1;
                }
                function ta(a, b) {
                    return P(function () { return a.apply(null, arguments); }, a, b);
                }
                function wa(a, b, d, e, g, f) { try {
                    a(b, d, e, g, f);
                }
                catch (h) {
                    c(h, za(d));
                } }
                function na(a, b) { if (v)
                    throw aa("missingattr", a, b); }
                function oa(a, c, d, e, g) {
                    function f(b, c, e) { C(d.$onChanges) && !cc(c, e) && (ga || (a.$$postDigest(la), ga = []), m || (m = {}, ga.push(h)), m[b] && (e = m[b].previousValue), m[b] = new Jb(e, c)); }
                    function h() { d.$onChanges(m); m = void 0; }
                    var k = [], l = {}, m;
                    q(e, function (e, h) {
                        var m = e.attrName, n = e.optional, K, B, w, v;
                        switch (e.mode) {
                            case "@":
                                n || ra.call(c, m) || (na(m, g.name), d[h] = c[m] = void 0);
                                n = c.$observe(m, function (a) {
                                    if (F(a) ||
                                        La(a))
                                        f(h, a, d[h]), d[h] = a;
                                });
                                c.$$observers[m].$$scope = a;
                                K = c[m];
                                F(K) ? d[h] = b(K)(a) : La(K) && (d[h] = K);
                                l[h] = new Jb(uc, d[h]);
                                k.push(n);
                                break;
                            case "=":
                                if (!ra.call(c, m)) {
                                    if (n)
                                        break;
                                    na(m, g.name);
                                    c[m] = void 0;
                                }
                                if (n && !c[m])
                                    break;
                                B = p(c[m]);
                                v = B.literal ? sa : cc;
                                w = B.assign || function () { K = d[h] = B(a); throw aa("nonassign", c[m], m, g.name); };
                                K = d[h] = B(a);
                                n = function (b) { v(b, d[h]) || (v(b, K) ? w(a, b = d[h]) : d[h] = b); return K = b; };
                                n.$stateful = !0;
                                n = e.collection ? a.$watchCollection(c[m], n) : a.$watch(p(c[m], n), null, B.literal);
                                k.push(n);
                                break;
                            case "<":
                                if (!ra.call(c, m)) {
                                    if (n)
                                        break;
                                    na(m, g.name);
                                    c[m] = void 0;
                                }
                                if (n && !c[m])
                                    break;
                                B = p(c[m]);
                                var O = B.literal, s = d[h] = B(a);
                                l[h] = new Jb(uc, d[h]);
                                n = a.$watch(B, function (a, b) { if (b === a) {
                                    if (b === s || O && sa(b, s))
                                        return;
                                    b = s;
                                } f(h, a, b); d[h] = a; }, O);
                                k.push(n);
                                break;
                            case "&":
                                n || ra.call(c, m) || na(m, g.name);
                                B = c.hasOwnProperty(m) ? p(c[m]) : D;
                                if (B === D && n)
                                    break;
                                d[h] = function (b) { return B(a, b); };
                        }
                    });
                    return { initialChanges: l, removeWatches: k.length && function () { for (var a = 0, b = k.length; a < b; ++a)
                            k[a](); } };
                }
                var Ia = /^\w/, Aa = y.document.createElement("div"), Ja = A, Ka = s, Ea = E, ga;
                rc.prototype = { $normalize: Da, $addClass: function (a) { a && 0 < a.length && L.addClass(this.$$element, a); }, $removeClass: function (a) { a && 0 < a.length && L.removeClass(this.$$element, a); }, $updateClass: function (a, b) { var c = td(a, b); c && c.length && L.addClass(this.$$element, c); (c = td(b, a)) && c.length && L.removeClass(this.$$element, c); }, $set: function (a, b, d, e) {
                        var g = md(this.$$element[0], a), f = ud[a], h = a;
                        g ? (this.$$element.prop(a, b), e = g) : f && (this[f] = b, h = f);
                        this[a] = b;
                        e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = Xc(a, "-"));
                        g = ya(this.$$element);
                        if ("a" === g && ("href" === a || "xlinkHref" === a) || "img" === g && "src" === a)
                            this[a] = b = null == b ? b : r(b, "src" === a);
                        else if ("img" === g && "srcset" === a && u(b)) {
                            for (var g = "", f = Q(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(f) ? k : /(,)/, f = f.split(k), k = Math.floor(f.length / 2), l = 0; l < k; l++)
                                var m = 2 * l, g = g + r(Q(f[m]), !0), g = g + (" " + Q(f[m + 1]));
                            f = Q(f[2 * l]).split(/\s/);
                            g += r(Q(f[0]), !0);
                            2 === f.length && (g += " " + Q(f[1]));
                            this[a] = b = g;
                        }
                        !1 !== d && (null == b ? this.$$element.removeAttr(e) : Ia.test(e) ? this.$$element.attr(e, b) : Oa(this.$$element[0], e, b));
                        (a = this.$$observers) && q(a[h], function (a) { try {
                            a(b);
                        }
                        catch (d) {
                            c(d);
                        } });
                    }, $observe: function (a, b) { var c = this, d = c.$$observers || (c.$$observers = R()), e = d[a] || (d[a] = []); e.push(b); O.$evalAsync(function () { e.$$inter || !c.hasOwnProperty(a) || x(c[a]) || b(c[a]); }); return function () { cb(e, b); }; } };
                var Fa = b.startSymbol(), Ga = b.endSymbol(), Ha = "{{" === Fa && "}}" === Ga ? ab : function (a) { return a.replace(/\{\{/g, Fa).replace(/}}/g, Ga); }, Na = /^ngAttr[A-Z]/, Ra = /^(.+)Start$/;
                ba.$$addBindingInfo = n ? function (a, b) {
                    var c = a.data("$binding") || [];
                    I(b) ? c = c.concat(b) : c.push(b);
                    a.data("$binding", c);
                } : D;
                ba.$$addBindingClass = n ? function (a) { Pa(a, "ng-binding"); } : D;
                ba.$$addScopeInfo = n ? function (a, b, c, d) { a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b); } : D;
                ba.$$addScopeClass = n ? function (a, b) { Pa(a, b ? "ng-isolate-scope" : "ng-scope"); } : D;
                ba.$$createComment = function (a, b) { var c = ""; n && (c = " " + (a || "") + ": ", b && (c += b + " ")); return y.document.createComment(c); };
                return ba;
            }];
    }
    function Jb(a, b) { this.previousValue = a; this.currentValue = b; }
    function Da(a) { return a.replace(qd, "").replace(vg, function (a, d, c) { return c ? d.toUpperCase() : d; }); }
    function td(a, b) { var d = "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0; a: for (; f < c.length; f++) {
        for (var g = c[f], k = 0; k < e.length; k++)
            if (g === e[k])
                continue a;
        d += (0 < d.length ? " " : "") + g;
    } return d; }
    function sd(a) { a = z(a); var b = a.length; if (1 >= b)
        return a; for (; b--;) {
        var d = a[b];
        (8 === d.nodeType || d.nodeType === Ma && "" === d.nodeValue.trim()) && wg.call(a, b, 1);
    } return a; }
    function ug(a, b) { if (b && F(b))
        return b; if (F(a)) {
        var d = vd.exec(a);
        if (d)
            return d[3];
    } }
    function Af() {
        var a = {}, b = !1;
        this.has = function (b) { return a.hasOwnProperty(b); };
        this.register = function (b, c) { Ha(b, "controller"); G(b) ? P(a, b) : a[b] = c; };
        this.allowGlobals = function () { b = !0; };
        this.$get = ["$injector", "$window", function (d, c) {
                function e(a, b, c, d) { if (!a || !G(a.$scope))
                    throw M("$controller")("noscp", d, b); a.$scope[b] = c; }
                return function (f, g, k, h) {
                    var l, m, p;
                    k = !0 === k;
                    h && F(h) && (p = h);
                    if (F(f)) {
                        h = f.match(vd);
                        if (!h)
                            throw wd("ctrlfmt", f);
                        m = h[1];
                        p = p || h[3];
                        f = a.hasOwnProperty(m) ? a[m] : Zc(g.$scope, m, !0) || (b ? Zc(c, m, !0) :
                            void 0);
                        if (!f)
                            throw wd("ctrlreg", m);
                        sb(f, m, !0);
                    }
                    if (k)
                        return k = (I(f) ? f[f.length - 1] : f).prototype, l = Object.create(k || null), p && e(g, p, l, m || f.name), P(function () { var a = d.invoke(f, l, g, m); a !== l && (G(a) || C(a)) && (l = a, p && e(g, p, l, m || f.name)); return l; }, { instance: l, identifier: p });
                    l = d.instantiate(f, g, m);
                    p && e(g, p, l, m || f.name);
                    return l;
                };
            }];
    }
    function Bf() { this.$get = ["$window", function (a) { return z(a.document); }]; }
    function Cf() {
        this.$get = ["$document", "$rootScope", function (a, b) {
                function d() { e = c.hidden; }
                var c = a[0], e = c && c.hidden;
                a.on("visibilitychange", d);
                b.$on("$destroy", function () { a.off("visibilitychange", d); });
                return function () { return e; };
            }];
    }
    function Df() { this.$get = ["$log", function (a) { return function (b, d) { a.error.apply(a, arguments); }; }]; }
    function vc(a) { return G(a) ? da(a) ? a.toISOString() : eb(a) : a; }
    function If() { this.$get = function () { return function (a) { if (!a)
        return ""; var b = []; Qc(a, function (a, c) { null === a || x(a) || C(a) || (I(a) ? q(a, function (a) { b.push(ia(c) + "=" + ia(vc(a))); }) : b.push(ia(c) + "=" + ia(vc(a)))); }); return b.join("&"); }; }; }
    function Jf() {
        this.$get =
            function () { return function (a) { function b(a, e, f) { null === a || x(a) || (I(a) ? q(a, function (a, c) { b(a, e + "[" + (G(a) ? c : "") + "]"); }) : G(a) && !da(a) ? Qc(a, function (a, c) { b(a, e + (f ? "" : "[") + c + (f ? "" : "]")); }) : d.push(ia(e) + "=" + ia(vc(a)))); } if (!a)
                return ""; var d = []; b(a, "", !0); return d.join("&"); }; };
    }
    function wc(a, b) { if (F(a)) {
        var d = a.replace(xg, "").trim();
        if (d) {
            var c = b("Content-Type"), c = c && 0 === c.indexOf(xd), e;
            (e = c) || (e = (e = d.match(yg)) && zg[e[0]].test(d));
            if (e)
                try {
                    a = Tc(d);
                }
                catch (f) {
                    if (!c)
                        return a;
                    throw Kb("baddata", a, f);
                }
        }
    } return a; }
    function yd(a) {
        var b = R(), d;
        F(a) ? q(a.split("\n"), function (a) { d = a.indexOf(":"); var e = N(Q(a.substr(0, d))); a = Q(a.substr(d + 1)); e && (b[e] = b[e] ? b[e] + ", " + a : a); }) : G(a) && q(a, function (a, d) { var f = N(d), g = Q(a); f && (b[f] = b[f] ? b[f] + ", " + g : g); });
        return b;
    }
    function zd(a) { var b; return function (d) { b || (b = yd(a)); return d ? (d = b[N(d)], void 0 === d && (d = null), d) : b; }; }
    function Ad(a, b, d, c) { if (C(c))
        return c(a, b, d); q(c, function (c) { a = c(a, b, d); }); return a; }
    function Hf() {
        var a = this.defaults = { transformResponse: [wc], transformRequest: [function (a) {
                    return G(a) && "[object File]" !==
                        ha.call(a) && "[object Blob]" !== ha.call(a) && "[object FormData]" !== ha.call(a) ? eb(a) : a;
                }], headers: { common: { Accept: "application/json, text/plain, */*" }, post: pa(xc), put: pa(xc), patch: pa(xc) }, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", paramSerializer: "$httpParamSerializer", jsonpCallbackParam: "callback" }, b = !1;
        this.useApplyAsync = function (a) { return u(a) ? (b = !!a, this) : b; };
        var d = this.interceptors = [], c = this.xsrfWhitelistedOrigins = [];
        this.$get = ["$browser", "$httpBackend", "$$cookieReader", "$cacheFactory",
            "$rootScope", "$q", "$injector", "$sce", function (e, f, g, k, h, l, m, p) {
                function n(b) {
                    function c(a, b) { for (var d = 0, e = b.length; d < e;) {
                        var g = b[d++], f = b[d++];
                        a = a.then(g, f);
                    } b.length = 0; return a; }
                    function d(a, b) { var c, e = {}; q(a, function (a, d) { C(a) ? (c = a(b), null != c && (e[d] = c)) : e[d] = a; }); return e; }
                    function g(a) { var b = P({}, a); b.data = Ad(a.data, a.headers, a.status, f.transformResponse); a = a.status; return 200 <= a && 300 > a ? b : l.reject(b); }
                    if (!G(b))
                        throw M("$http")("badreq", b);
                    if (!F(p.valueOf(b.url)))
                        throw M("$http")("badreq", b.url);
                    var f = P({ method: "get", transformRequest: a.transformRequest, transformResponse: a.transformResponse, paramSerializer: a.paramSerializer, jsonpCallbackParam: a.jsonpCallbackParam }, b);
                    f.headers = function (b) { var c = a.headers, e = P({}, b.headers), g, f, h, c = P({}, c.common, c[N(b.method)]); a: for (g in c) {
                        f = N(g);
                        for (h in e)
                            if (N(h) === f)
                                continue a;
                        e[g] = c[g];
                    } return d(e, pa(b)); }(b);
                    f.method = ub(f.method);
                    f.paramSerializer = F(f.paramSerializer) ? m.get(f.paramSerializer) : f.paramSerializer;
                    e.$$incOutstandingRequestCount();
                    var h = [], k = [];
                    b =
                        l.resolve(f);
                    q(s, function (a) { (a.request || a.requestError) && h.unshift(a.request, a.requestError); (a.response || a.responseError) && k.push(a.response, a.responseError); });
                    b = c(b, h);
                    b = b.then(function (b) { var c = b.headers, d = Ad(b.data, zd(c), void 0, b.transformRequest); x(d) && q(c, function (a, b) { "content-type" === N(b) && delete c[b]; }); x(b.withCredentials) && !x(a.withCredentials) && (b.withCredentials = a.withCredentials); return B(b, d).then(g, g); });
                    b = c(b, k);
                    return b = b.finally(function () { e.$$completeOutstandingRequest(D); });
                }
                function B(c, d) {
                    function e(a) { if (a) {
                        var c = {};
                        q(a, function (a, d) { c[d] = function (c) { function d() { a(c); } b ? h.$applyAsync(d) : h.$$phase ? d() : h.$apply(d); }; });
                        return c;
                    } }
                    function k(a, c, d, e, g) { function f() { m(c, a, d, e, g); } L && (200 <= a && 300 > a ? L.put(z, [a, c, yd(d), e, g]) : L.remove(z)); b ? h.$applyAsync(f) : (f(), h.$$phase || h.$apply()); }
                    function m(a, b, d, e, g) { b = -1 <= b ? b : 0; (200 <= b && 300 > b ? s.resolve : s.reject)({ data: a, status: b, headers: zd(d), config: c, statusText: e, xhrStatus: g }); }
                    function t(a) { m(a.data, a.status, pa(a.headers()), a.statusText, a.xhrStatus); }
                    function B() { var a = n.pendingRequests.indexOf(c); -1 !== a && n.pendingRequests.splice(a, 1); }
                    var s = l.defer(), qa = s.promise, L, r, la = c.headers, y = "jsonp" === N(c.method), z = c.url;
                    y ? z = p.getTrustedResourceUrl(z) : F(z) || (z = p.valueOf(z));
                    z = v(z, c.paramSerializer(c.params));
                    y && (z = E(z, c.jsonpCallbackParam));
                    n.pendingRequests.push(c);
                    qa.then(B, B);
                    !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (L = G(c.cache) ? c.cache : G(a.cache) ? a.cache : A);
                    L && (r = L.get(z), u(r) ? r && C(r.then) ? r.then(t, t) : I(r) ? m(r[1], r[0], pa(r[2]), r[3], r[4]) : m(r, 200, {}, "OK", "complete") : L.put(z, qa));
                    x(r) && ((r = J(c.url) ? g()[c.xsrfCookieName || a.xsrfCookieName] : void 0) && (la[c.xsrfHeaderName || a.xsrfHeaderName] = r), f(c.method, z, d, k, la, c.timeout, c.withCredentials, c.responseType, e(c.eventHandlers), e(c.uploadEventHandlers)));
                    return qa;
                }
                function v(a, b) { 0 < b.length && (a += (-1 === a.indexOf("?") ? "?" : "&") + b); return a; }
                function E(a, b) {
                    var c = a.split("?");
                    if (2 < c.length)
                        throw Kb("badjsonp", a);
                    c = fc(c[1]);
                    q(c, function (c, d) {
                        if ("JSON_CALLBACK" === c)
                            throw Kb("badjsonp", a);
                        if (d === b)
                            throw Kb("badjsonp", b, a);
                    });
                    return a += (-1 === a.indexOf("?") ? "?" : "&") + b + "=JSON_CALLBACK";
                }
                var A = k("$http");
                a.paramSerializer = F(a.paramSerializer) ? m.get(a.paramSerializer) : a.paramSerializer;
                var s = [];
                q(d, function (a) { s.unshift(F(a) ? m.get(a) : m.invoke(a)); });
                var J = Ag(c);
                n.pendingRequests = [];
                (function (a) { q(arguments, function (a) { n[a] = function (b, c) { return n(P({}, c || {}, { method: a, url: b })); }; }); })("get", "delete", "head", "jsonp");
                (function (a) {
                    q(arguments, function (a) {
                        n[a] = function (b, c, d) {
                            return n(P({}, d ||
                                {}, { method: a, url: b, data: c }));
                        };
                    });
                })("post", "put", "patch");
                n.defaults = a;
                return n;
            }];
    }
    function Lf() { this.$get = function () { return function () { return new y.XMLHttpRequest; }; }; }
    function Kf() { this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function (a, b, d, c) { return Bg(a, c, a.defer, b, d[0]); }]; }
    function Bg(a, b, d, c, e) {
        function f(a, b, d) {
            a = a.replace("JSON_CALLBACK", b);
            var f = e.createElement("script"), m = null;
            f.type = "text/javascript";
            f.src = a;
            f.async = !0;
            m = function (a) {
                f.removeEventListener("load", m);
                f.removeEventListener("error", m);
                e.body.removeChild(f);
                f = null;
                var g = -1, B = "unknown";
                a && ("load" !== a.type || c.wasCalled(b) || (a = { type: "error" }), B = a.type, g = "error" === a.type ? 404 : 200);
                d && d(g, B);
            };
            f.addEventListener("load", m);
            f.addEventListener("error", m);
            e.body.appendChild(f);
            return m;
        }
        return function (e, k, h, l, m, p, n, B, v, E) {
            function A(a) { H = "timeout" === a; r && r(); w && w.abort(); }
            function s(a, b, c, e, g, f) { u(T) && d.cancel(T); r = w = null; a(b, c, e, g, f); }
            k = k || a.url();
            if ("jsonp" === N(e))
                var J = c.createCallback(k), r = f(k, J, function (a, b) {
                    var d = 200 === a && c.getResponse(J);
                    s(l, a, d, "", b, "complete");
                    c.removeCallback(J);
                });
            else {
                var w = b(e, k), H = !1;
                w.open(e, k, !0);
                q(m, function (a, b) { u(a) && w.setRequestHeader(b, a); });
                w.onload = function () { var a = w.statusText || "", b = "response" in w ? w.response : w.responseText, c = 1223 === w.status ? 204 : w.status; 0 === c && (c = b ? 200 : "file" === ma(k).protocol ? 404 : 0); s(l, c, b, w.getAllResponseHeaders(), a, "complete"); };
                w.onerror = function () { s(l, -1, null, null, "", "error"); };
                w.ontimeout = function () { s(l, -1, null, null, "", "timeout"); };
                w.onabort = function () {
                    s(l, -1, null, null, "", H ? "timeout" :
                        "abort");
                };
                q(v, function (a, b) { w.addEventListener(b, a); });
                q(E, function (a, b) { w.upload.addEventListener(b, a); });
                n && (w.withCredentials = !0);
                if (B)
                    try {
                        w.responseType = B;
                    }
                    catch (K) {
                        if ("json" !== B)
                            throw K;
                    }
                w.send(x(h) ? null : h);
            }
            if (0 < p)
                var T = d(function () { A("timeout"); }, p);
            else
                p && C(p.then) && p.then(function () { A(u(p.$$timeoutId) ? "timeout" : "abort"); });
        };
    }
    function Ff() {
        var a = "{{", b = "}}";
        this.startSymbol = function (b) { return b ? (a = b, this) : a; };
        this.endSymbol = function (a) { return a ? (b = a, this) : b; };
        this.$get = ["$parse", "$exceptionHandler",
            "$sce", function (d, c, e) {
                function f(a) { return "\\\\\\" + a; }
                function g(c) { return c.replace(p, a).replace(n, b); }
                function k(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a); }, b, c); return e; }
                function h(f, h, p, n) {
                    function s(a) { try {
                        var b = a;
                        a = p ? e.getTrusted(p, b) : e.valueOf(b);
                        return n && !u(a) ? a : hc(a);
                    }
                    catch (d) {
                        c(Ea.interr(f, d));
                    } }
                    if (!f.length || -1 === f.indexOf(a)) {
                        var J;
                        h || (h = g(f), J = ka(h), J.exp = f, J.expressions = [], J.$$watchDelegate = k);
                        return J;
                    }
                    n = !!n;
                    var q, w, H = 0, K = [], T = [];
                    J = f.length;
                    for (var t = [], r = []; H < J;)
                        if (-1 !== (q = f.indexOf(a, H)) && -1 !== (w = f.indexOf(b, q + l)))
                            H !== q && t.push(g(f.substring(H, q))), H = f.substring(q + l, w), K.push(H), T.push(d(H, s)), H = w + m, r.push(t.length), t.push("");
                        else {
                            H !== J && t.push(g(f.substring(H)));
                            break;
                        }
                    p && 1 < t.length && Ea.throwNoconcat(f);
                    if (!h || K.length) {
                        var O = function (a) { for (var b = 0, c = K.length; b < c; b++) {
                            if (n && x(a[b]))
                                return;
                            t[r[b]] = a[b];
                        } return t.join(""); };
                        return P(function (a) { var b = 0, d = K.length, e = Array(d); try {
                            for (; b < d; b++)
                                e[b] = T[b](a);
                            return O(e);
                        }
                        catch (g) {
                            c(Ea.interr(f, g));
                        } }, { exp: f, expressions: K, $$watchDelegate: function (a, b) { var c; return a.$watchGroup(T, function (d, e) { var g = O(d); b.call(this, g, d !== e ? c : g, a); c = g; }); } });
                    }
                }
                var l = a.length, m = b.length, p = new RegExp(a.replace(/./g, f), "g"), n = new RegExp(b.replace(/./g, f), "g");
                h.startSymbol = function () { return a; };
                h.endSymbol = function () { return b; };
                return h;
            }];
    }
    function Gf() {
        this.$get = ["$rootScope", "$window", "$q", "$$q", "$browser", function (a, b, d, c, e) {
                function f(f, h, l, m) {
                    function p() { n ? f.apply(null, B) : f(A); }
                    var n = 4 < arguments.length, B = n ? xa.call(arguments, 4) : [], v = b.setInterval, E = b.clearInterval, A = 0, s = u(m) && !m, J = (s ? c : d).defer(), q = J.promise;
                    l = u(l) ? l : 0;
                    q.$$intervalId = v(function () { s ? e.defer(p) : a.$evalAsync(p); J.notify(A++); 0 < l && A >= l && (J.resolve(A), E(q.$$intervalId), delete g[q.$$intervalId]); s || a.$apply(); }, h);
                    g[q.$$intervalId] = J;
                    return q;
                }
                var g = {};
                f.cancel = function (a) { return a && a.$$intervalId in g ? (g[a.$$intervalId].promise.$$state.pur = !0, g[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), delete g[a.$$intervalId], !0) : !1; };
                return f;
            }];
    }
    function yc(a) {
        a = a.split("/");
        for (var b = a.length; b--;)
            a[b] =
                fb(a[b].replace(/%2F/g, "/"));
        return a.join("/");
    }
    function Bd(a, b) { var d = ma(a); b.$$protocol = d.protocol; b.$$host = d.hostname; b.$$port = Z(d.port) || Cg[d.protocol] || null; }
    function Cd(a, b, d) {
        if (Dg.test(a))
            throw kb("badpath", a);
        var c = "/" !== a.charAt(0);
        c && (a = "/" + a);
        a = ma(a);
        for (var c = (c && "/" === a.pathname.charAt(0) ? a.pathname.substring(1) : a.pathname).split("/"), e = c.length; e--;)
            c[e] = decodeURIComponent(c[e]), d && (c[e] = c[e].replace(/\//g, "%2F"));
        d = c.join("/");
        b.$$path = d;
        b.$$search = fc(a.search);
        b.$$hash = decodeURIComponent(a.hash);
        b.$$path && "/" !== b.$$path.charAt(0) && (b.$$path = "/" + b.$$path);
    }
    function zc(a, b) { return a.slice(0, b.length) === b; }
    function va(a, b) { if (zc(b, a))
        return b.substr(a.length); }
    function Ka(a) { var b = a.indexOf("#"); return -1 === b ? a : a.substr(0, b); }
    function lb(a) { return a.replace(/(#.+)|#$/, "$1"); }
    function Ac(a, b, d) {
        this.$$html5 = !0;
        d = d || "";
        Bd(a, this);
        this.$$parse = function (a) { var d = va(b, a); if (!F(d))
            throw kb("ipthprfx", a, b); Cd(d, this, !0); this.$$path || (this.$$path = "/"); this.$$compose(); };
        this.$$compose = function () {
            var a = gc(this.$$search), d = this.$$hash ? "#" + fb(this.$$hash) : "";
            this.$$url = yc(this.$$path) + (a ? "?" + a : "") + d;
            this.$$absUrl = b + this.$$url.substr(1);
            this.$$urlUpdatedByLocation = !0;
        };
        this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0])
            return this.hash(e.slice(1)), !0; var f, g; u(f = va(a, c)) ? (g = f, g = d && u(f = va(d, f)) ? b + (va("/", f) || f) : a + g) : u(f = va(b, c)) ? g = b + f : b === c + "/" && (g = b); g && this.$$parse(g); return !!g; };
    }
    function Bc(a, b, d) {
        Bd(a, this);
        this.$$parse = function (c) {
            var e = va(a, c) || va(b, c), f;
            x(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", x(e) && (a = c,
                this.replace())) : (f = va(d, e), x(f) && (f = e));
            Cd(f, this, !1);
            c = this.$$path;
            var e = a, g = /^\/[A-Z]:(\/.*)/;
            zc(f, e) && (f = f.replace(e, ""));
            g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c);
            this.$$path = c;
            this.$$compose();
        };
        this.$$compose = function () { var b = gc(this.$$search), e = this.$$hash ? "#" + fb(this.$$hash) : ""; this.$$url = yc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + (this.$$url ? d + this.$$url : ""); this.$$urlUpdatedByLocation = !0; };
        this.$$parseLinkUrl = function (b, d) { return Ka(a) === Ka(b) ? (this.$$parse(b), !0) : !1; };
    }
    function Dd(a, b, d) {
        this.$$html5 =
            !0;
        Bc.apply(this, arguments);
        this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0])
            return this.hash(e.slice(1)), !0; var f, g; a === Ka(c) ? f = c : (g = va(b, c)) ? f = a + d + g : b === c + "/" && (f = b); f && this.$$parse(f); return !!f; };
        this.$$compose = function () { var b = gc(this.$$search), e = this.$$hash ? "#" + fb(this.$$hash) : ""; this.$$url = yc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + d + this.$$url; this.$$urlUpdatedByLocation = !0; };
    }
    function Lb(a) { return function () { return this[a]; }; }
    function Ed(a, b) {
        return function (d) {
            if (x(d))
                return this[a];
            this[a] =
                b(d);
            this.$$compose();
            return this;
        };
    }
    function Nf() {
        var a = "!", b = { enabled: !1, requireBase: !0, rewriteLinks: !0 };
        this.hashPrefix = function (b) { return u(b) ? (a = b, this) : a; };
        this.html5Mode = function (a) { if (La(a))
            return b.enabled = a, this; if (G(a)) {
            La(a.enabled) && (b.enabled = a.enabled);
            La(a.requireBase) && (b.requireBase = a.requireBase);
            if (La(a.rewriteLinks) || F(a.rewriteLinks))
                b.rewriteLinks = a.rewriteLinks;
            return this;
        } return b; };
        this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function (d, c, e, f, g) {
                function k(a, b, d) { var e = l.url(), g = l.$$state; try {
                    c.url(a, b, d), l.$$state = c.state();
                }
                catch (f) {
                    throw l.url(e), l.$$state = g, f;
                } }
                function h(a, b) { d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b); }
                var l, m;
                m = c.baseHref();
                var p = c.url(), n;
                if (b.enabled) {
                    if (!m && b.requireBase)
                        throw kb("nobase");
                    n = p.substring(0, p.indexOf("/", p.indexOf("//") + 2)) + (m || "/");
                    m = e.history ? Ac : Dd;
                }
                else
                    n = Ka(p), m = Bc;
                var B = n.substr(0, Ka(n).lastIndexOf("/") + 1);
                l = new m(n, B, "#" + a);
                l.$$parseLinkUrl(p, p);
                l.$$state = c.state();
                var v = /^\s*(javascript|mailto):/i;
                f.on("click", function (a) {
                    var e = b.rewriteLinks;
                    if (e && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 !== a.which && 2 !== a.button) {
                        for (var h = z(a.target); "a" !== ya(h[0]);)
                            if (h[0] === f[0] || !(h = h.parent())[0])
                                return;
                        if (!F(e) || !x(h.attr(e))) {
                            var e = h.prop("href"), k = h.attr("href") || h.attr("xlink:href");
                            G(e) && "[object SVGAnimatedString]" === e.toString() && (e = ma(e.animVal).href);
                            v.test(e) || !e || h.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(e, k) || (a.preventDefault(), l.absUrl() !== c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] =
                                !0));
                        }
                    }
                });
                lb(l.absUrl()) !== lb(p) && c.url(l.absUrl(), !0);
                var q = !0;
                c.onUrlChange(function (a, b) { zc(a, B) ? (d.$evalAsync(function () { var c = l.absUrl(), e = l.$$state, g; a = lb(a); l.$$parse(a); l.$$state = b; g = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented; l.absUrl() === a && (g ? (l.$$parse(c), l.$$state = e, k(c, !1, e)) : (q = !1, h(c, e))); }), d.$$phase || d.$digest()) : g.location.href = a; });
                d.$watch(function () {
                    if (q || l.$$urlUpdatedByLocation) {
                        l.$$urlUpdatedByLocation = !1;
                        var a = lb(c.url()), b = lb(l.absUrl()), g = c.state(), f = l.$$replace, m = a !== b || l.$$html5 && e.history && g !== l.$$state;
                        if (q || m)
                            q = !1, d.$evalAsync(function () { var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, g).defaultPrevented; l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = g) : (m && k(b, f, g === l.$$state ? null : l.$$state), h(a, g))); });
                    }
                    l.$$replace = !1;
                });
                return l;
            }];
    }
    function Of() {
        var a = !0, b = this;
        this.debugEnabled = function (b) { return u(b) ? (a = b, this) : a; };
        this.$get = ["$window", function (d) {
                function c(a) {
                    bc(a) && (a.stack && f ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " +
                        a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line));
                    return a;
                }
                function e(a) { var b = d.console || {}, e = b[a] || b.log || D; return function () { var a = []; q(arguments, function (b) { a.push(c(b)); }); return Function.prototype.apply.call(e, b, a); }; }
                var f = Ba || /\bEdge\//.test(d.navigator && d.navigator.userAgent);
                return { log: e("log"), info: e("info"), warn: e("warn"), error: e("error"), debug: function () { var c = e("debug"); return function () { a && c.apply(b, arguments); }; }() };
            }];
    }
    function Eg(a) { return a + ""; }
    function Fg(a, b) { return "undefined" !== typeof a ? a : b; }
    function Fd(a, b) { return "undefined" === typeof a ? b : "undefined" === typeof b ? a : a + b; }
    function Gg(a, b) { switch (a.type) {
        case r.MemberExpression:
            if (a.computed)
                return !1;
            break;
        case r.UnaryExpression: return 1;
        case r.BinaryExpression: return "+" !== a.operator ? 1 : !1;
        case r.CallExpression: return !1;
    } return void 0 === b ? Gd : b; }
    function U(a, b, d) {
        var c, e, f = a.isPure = Gg(a, d);
        switch (a.type) {
            case r.Program:
                c = !0;
                q(a.body, function (a) { U(a.expression, b, f); c = c && a.expression.constant; });
                a.constant = c;
                break;
            case r.Literal:
                a.constant = !0;
                a.toWatch = [];
                break;
            case r.UnaryExpression:
                U(a.argument, b, f);
                a.constant = a.argument.constant;
                a.toWatch = a.argument.toWatch;
                break;
            case r.BinaryExpression:
                U(a.left, b, f);
                U(a.right, b, f);
                a.constant = a.left.constant && a.right.constant;
                a.toWatch = a.left.toWatch.concat(a.right.toWatch);
                break;
            case r.LogicalExpression:
                U(a.left, b, f);
                U(a.right, b, f);
                a.constant = a.left.constant && a.right.constant;
                a.toWatch = a.constant ? [] : [a];
                break;
            case r.ConditionalExpression:
                U(a.test, b, f);
                U(a.alternate, b, f);
                U(a.consequent, b, f);
                a.constant = a.test.constant && a.alternate.constant && a.consequent.constant;
                a.toWatch = a.constant ? [] : [a];
                break;
            case r.Identifier:
                a.constant = !1;
                a.toWatch = [a];
                break;
            case r.MemberExpression:
                U(a.object, b, f);
                a.computed && U(a.property, b, f);
                a.constant = a.object.constant && (!a.computed || a.property.constant);
                a.toWatch = a.constant ? [] : [a];
                break;
            case r.CallExpression:
                c = d = a.filter ? !b(a.callee.name).$stateful : !1;
                e = [];
                q(a.arguments, function (a) { U(a, b, f); c = c && a.constant; e.push.apply(e, a.toWatch); });
                a.constant =
                    c;
                a.toWatch = d ? e : [a];
                break;
            case r.AssignmentExpression:
                U(a.left, b, f);
                U(a.right, b, f);
                a.constant = a.left.constant && a.right.constant;
                a.toWatch = [a];
                break;
            case r.ArrayExpression:
                c = !0;
                e = [];
                q(a.elements, function (a) { U(a, b, f); c = c && a.constant; e.push.apply(e, a.toWatch); });
                a.constant = c;
                a.toWatch = e;
                break;
            case r.ObjectExpression:
                c = !0;
                e = [];
                q(a.properties, function (a) { U(a.value, b, f); c = c && a.value.constant; e.push.apply(e, a.value.toWatch); a.computed && (U(a.key, b, !1), c = c && a.key.constant, e.push.apply(e, a.key.toWatch)); });
                a.constant =
                    c;
                a.toWatch = e;
                break;
            case r.ThisExpression:
                a.constant = !1;
                a.toWatch = [];
                break;
            case r.LocalsExpression: a.constant = !1, a.toWatch = [];
        }
    }
    function Hd(a) { if (1 === a.length) {
        a = a[0].expression;
        var b = a.toWatch;
        return 1 !== b.length ? b : b[0] !== a ? b : void 0;
    } }
    function Id(a) { return a.type === r.Identifier || a.type === r.MemberExpression; }
    function Jd(a) { if (1 === a.body.length && Id(a.body[0].expression))
        return { type: r.AssignmentExpression, left: a.body[0].expression, right: { type: r.NGValueParameter }, operator: "=" }; }
    function Kd(a) {
        this.$filter =
            a;
    }
    function Ld(a) { this.$filter = a; }
    function Mb(a, b, d) { this.ast = new r(a, d); this.astCompiler = d.csp ? new Ld(b) : new Kd(b); }
    function Cc(a) { return C(a.valueOf) ? a.valueOf() : Hg.call(a); }
    function Pf() {
        var a = R(), b = { "true": !0, "false": !1, "null": null, undefined: void 0 }, d, c;
        this.addLiteral = function (a, c) { b[a] = c; };
        this.setIdentifierFns = function (a, b) { d = a; c = b; return this; };
        this.$get = ["$filter", function (e) {
                function f(b, c) {
                    var d, g;
                    switch (typeof b) {
                        case "string": return g = b = b.trim(), d = a[g], d || (d = new Nb(n), d = (new Mb(d, e, n)).parse(b),
                            d.constant ? d.$$watchDelegate = m : d.oneTime ? d.$$watchDelegate = d.literal ? l : h : d.inputs && (d.$$watchDelegate = k), a[g] = d), p(d, c);
                        case "function": return p(b, c);
                        default: return p(D, c);
                    }
                }
                function g(a, b, c) { return null == a || null == b ? a === b : "object" !== typeof a || (a = Cc(a), "object" !== typeof a || c) ? a === b || a !== a && b !== b : !1; }
                function k(a, b, c, d, e) {
                    var f = d.inputs, h;
                    if (1 === f.length) {
                        var k = g, f = f[0];
                        return a.$watch(function (a) { var b = f(a); g(b, k, f.isPure) || (h = d(a, void 0, void 0, [b]), k = b && Cc(b)); return h; }, b, c, e);
                    }
                    for (var l = [], m = [], p = 0, n = f.length; p < n; p++)
                        l[p] = g, m[p] = null;
                    return a.$watch(function (a) { for (var b = !1, c = 0, e = f.length; c < e; c++) {
                        var k = f[c](a);
                        if (b || (b = !g(k, l[c], f[c].isPure)))
                            m[c] = k, l[c] = k && Cc(k);
                    } b && (h = d(a, void 0, void 0, m)); return h; }, b, c, e);
                }
                function h(a, b, c, d, e) { function g(a) { return d(a); } function f(a, c, d) { l = a; C(b) && b(a, c, d); u(a) && d.$$postDigest(function () { u(l) && h(); }); } var h, l; return h = d.inputs ? k(a, f, c, d, e) : a.$watch(g, f, c); }
                function l(a, b, c, d) {
                    function e(a) { var b = !0; q(a, function (a) { u(a) || (b = !1); }); return b; }
                    var g, f;
                    return g = a.$watch(function (a) { return d(a); }, function (a, c, d) { f = a; C(b) && b(a, c, d); e(a) && d.$$postDigest(function () { e(f) && g(); }); }, c);
                }
                function m(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a); }, b, c); return e; }
                function p(a, b) {
                    if (!b)
                        return a;
                    var c = a.$$watchDelegate, d = !1, e = c !== l && c !== h ? function (c, e, g, f) { g = d && f ? f[0] : a(c, e, g, f); return b(g, c, e); } : function (c, d, e, g) { e = a(c, d, e, g); c = b(e, c, d); return u(e) ? c : e; }, d = !a.inputs;
                    c && c !== k ? (e.$$watchDelegate = c, e.inputs = a.inputs) : b.$stateful || (e.$$watchDelegate = k, e.inputs = a.inputs ? a.inputs : [a]);
                    e.inputs && (e.inputs = e.inputs.map(function (a) {
                        return a.isPure ===
                            Gd ? function (b) { return a(b); } : a;
                    }));
                    return e;
                }
                var n = { csp: Ia().noUnsafeEval, literals: na(b), isIdentifierStart: C(d) && d, isIdentifierContinue: C(c) && c };
                f.$$getAst = function (a) { var b = new Nb(n); return (new Mb(b, e, n)).getAst(a).ast; };
                return f;
            }];
    }
    function Rf() { var a = !0; this.$get = ["$rootScope", "$exceptionHandler", function (b, d) { return Md(function (a) { b.$evalAsync(a); }, d, a); }]; this.errorOnUnhandledRejections = function (b) { return u(b) ? (a = b, this) : a; }; }
    function Sf() {
        var a = !0;
        this.$get = ["$browser", "$exceptionHandler", function (b, d) { return Md(function (a) { b.defer(a); }, d, a); }];
        this.errorOnUnhandledRejections = function (b) { return u(b) ? (a = b, this) : a; };
    }
    function Md(a, b, d) {
        function c() { return new e; }
        function e() { var a = this.promise = new f; this.resolve = function (b) { h(a, b); }; this.reject = function (b) { m(a, b); }; this.notify = function (b) { n(a, b); }; }
        function f() { this.$$state = { status: 0 }; }
        function g() {
            for (; !J && u.length;) {
                var a = u.shift();
                if (!a.pur) {
                    a.pur = !0;
                    var c = a.value, c = "Possibly unhandled rejection: " + ("function" === typeof c ? c.toString().replace(/ \{[\s\S]*$/, "") : x(c) ? "undefined" : "string" !== typeof c ? Fe(c, void 0) : c);
                    bc(a.value) ? b(a.value, c) : b(c);
                }
            }
        }
        function k(c) {
            !d || c.pending || 2 !== c.status || c.pur || (0 === J && 0 === u.length && a(g), u.push(c));
            !c.processScheduled && c.pending && (c.processScheduled = !0, ++J, a(function () {
                var e, f, k;
                k = c.pending;
                c.processScheduled = !1;
                c.pending = void 0;
                try {
                    for (var l = 0, p = k.length; l < p; ++l) {
                        c.pur = !0;
                        f = k[l][0];
                        e = k[l][c.status];
                        try {
                            C(e) ? h(f, e(c.value)) : 1 === c.status ? h(f, c.value) : m(f, c.value);
                        }
                        catch (n) {
                            m(f, n), n && !0 === n.$$passToExceptionHandler && b(n);
                        }
                    }
                }
                finally {
                    --J,
                        d && 0 === J && a(g);
                }
            }));
        }
        function h(a, b) { a.$$state.status || (b === a ? p(a, s("qcycle", b)) : l(a, b)); }
        function l(a, b) { function c(b) { g || (g = !0, l(a, b)); } function d(b) { g || (g = !0, p(a, b)); } function e(b) { n(a, b); } var f, g = !1; try {
            if (G(b) || C(b))
                f = b.then;
            C(f) ? (a.$$state.status = -1, f.call(b, c, d, e)) : (a.$$state.value = b, a.$$state.status = 1, k(a.$$state));
        }
        catch (h) {
            d(h);
        } }
        function m(a, b) { a.$$state.status || p(a, b); }
        function p(a, b) { a.$$state.value = b; a.$$state.status = 2; k(a.$$state); }
        function n(c, d) {
            var e = c.$$state.pending;
            0 >= c.$$state.status &&
                e && e.length && a(function () { for (var a, c, f = 0, g = e.length; f < g; f++) {
                c = e[f][0];
                a = e[f][3];
                try {
                    n(c, C(a) ? a(d) : d);
                }
                catch (h) {
                    b(h);
                }
            } });
        }
        function B(a) { var b = new f; m(b, a); return b; }
        function v(a, b, c) { var d = null; try {
            C(c) && (d = c());
        }
        catch (e) {
            return B(e);
        } return d && C(d.then) ? d.then(function () { return b(a); }, B) : b(a); }
        function r(a, b, c, d) { var e = new f; h(e, a); return e.then(b, c, d); }
        function A(a) { if (!C(a))
            throw s("norslvr", a); var b = new f; a(function (a) { h(b, a); }, function (a) { m(b, a); }); return b; }
        var s = M("$q", TypeError), J = 0, u = [];
        P(f.prototype, { then: function (a, b, c) { if (x(a) && x(b) && x(c))
                return this; var d = new f; this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([d, a, b, c]); 0 < this.$$state.status && k(this.$$state); return d; }, "catch": function (a) { return this.then(null, a); }, "finally": function (a, b) { return this.then(function (b) { return v(b, w, a); }, function (b) { return v(b, B, a); }, b); } });
        var w = r;
        A.prototype = f.prototype;
        A.defer = c;
        A.reject = B;
        A.when = r;
        A.resolve = w;
        A.all = function (a) {
            var b = new f, c = 0, d = I(a) ? [] : {};
            q(a, function (a, e) {
                c++;
                r(a).then(function (a) {
                    d[e] =
                        a;
                    --c || h(b, d);
                }, function (a) { m(b, a); });
            });
            0 === c && h(b, d);
            return b;
        };
        A.race = function (a) { var b = c(); q(a, function (a) { r(a).then(b.resolve, b.reject); }); return b.promise; };
        return A;
    }
    function ag() {
        this.$get = ["$window", "$timeout", function (a, b) {
                var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function (a) { var b = d(a); return function () { c(b); }; } : function (a) { var c = b(a, 16.66, !1); return function () { b.cancel(c); }; };
                f.supported = e;
                return f;
            }];
    }
    function Qf() {
        function a(a) { function b() { this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = ++qb; this.$$ChildScope = null; this.$$suspended = !1; } b.prototype = a; return b; }
        var b = 10, d = M("$rootScope"), c = null, e = null;
        this.digestTtl = function (a) { arguments.length && (b = a); return b; };
        this.$get = ["$exceptionHandler", "$parse", "$browser", function (f, g, k) {
                function h(a) { a.currentScope.$$destroyed = !0; }
                function l(a) {
                    9 ===
                        Ba && (a.$$childHead && l(a.$$childHead), a.$$nextSibling && l(a.$$nextSibling));
                    a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null;
                }
                function m() { this.$id = ++qb; this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$suspended = this.$$destroyed = !1; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null; }
                function p(a) {
                    if (s.$$phase)
                        throw d("inprog", s.$$phase);
                    s.$$phase = a;
                }
                function n(a, b) { do
                    a.$$watchersCount += b;
                while (a = a.$parent); }
                function B(a, b, c) { do
                    a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c];
                while (a = a.$parent); }
                function v() { }
                function r() { for (; w.length;)
                    try {
                        w.shift()();
                    }
                    catch (a) {
                        f(a);
                    } e = null; }
                function A() { null === e && (e = k.defer(function () { s.$apply(r); })); }
                m.prototype = { constructor: m, $new: function (b, c) {
                        var d;
                        c = c || this;
                        b ? (d = new m, d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), d = new this.$$ChildScope);
                        d.$parent = c;
                        d.$$prevSibling = c.$$childTail;
                        c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d;
                        (b || c !== this) && d.$on("$destroy", h);
                        return d;
                    }, $watch: function (a, b, d, e) {
                        var f = g(a);
                        b = C(b) ? b : D;
                        if (f.$$watchDelegate)
                            return f.$$watchDelegate(this, b, d, f, a);
                        var h = this, k = h.$$watchers, l = { fn: b, last: v, get: f, exp: e || a, eq: !!d };
                        c = null;
                        k || (k = h.$$watchers = [], k.$$digestWatchIndex = -1);
                        k.unshift(l);
                        k.$$digestWatchIndex++;
                        n(this, 1);
                        return function () {
                            var a = cb(k, l);
                            0 <= a && (n(h, -1), a < k.$$digestWatchIndex &&
                                k.$$digestWatchIndex--);
                            c = null;
                        };
                    }, $watchGroup: function (a, b) { function c() { h = !1; k ? (k = !1, b(e, e, g)) : b(e, d, g); } var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0; if (!a.length) {
                        var l = !0;
                        g.$evalAsync(function () { l && b(e, e, g); });
                        return function () { l = !1; };
                    } if (1 === a.length)
                        return this.$watch(a[0], function (a, c, f) { e[0] = a; d[0] = c; b(e, a === c ? e : d, f); }); q(a, function (a, b) { var k = g.$watch(a, function (a, f) { e[b] = a; d[b] = f; h || (h = !0, g.$evalAsync(c)); }); f.push(k); }); return function () { for (; f.length;)
                        f.shift()(); }; }, $watchCollection: function (a, b) {
                        function c(a) { e = a; var b, d, g, h; if (!x(e)) {
                            if (G(e))
                                if (ja(e))
                                    for (f !== p && (f = p, q = f.length = 0, l++), a = e.length, q !== a && (l++, f.length = q = a), b = 0; b < a; b++)
                                        h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (l++, f[b] = g);
                                else {
                                    f !== n && (f = n = {}, q = 0, l++);
                                    a = 0;
                                    for (b in e)
                                        ra.call(e, b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, d || h === g || (l++, f[b] = g)) : (q++, f[b] = g, l++));
                                    if (q > a)
                                        for (b in l++, f)
                                            ra.call(e, b) || (q--, delete f[b]);
                                }
                            else
                                f !== e && (f = e, l++);
                            return l;
                        } }
                        c.$stateful = !0;
                        var d = this, e, f, h, k = 1 < b.length, l = 0, m = g(a, c), p = [], n = {}, B = !0, q = 0;
                        return this.$watch(m, function () { B ? (B = !1, b(e, e, d)) : b(e, h, d); if (k)
                            if (G(e))
                                if (ja(e)) {
                                    h = Array(e.length);
                                    for (var a = 0; a < e.length; a++)
                                        h[a] = e[a];
                                }
                                else
                                    for (a in h = {}, e)
                                        ra.call(e, a) && (h[a] = e[a]);
                            else
                                h = e; });
                    }, $digest: function () {
                        var a, g, h, l, m, n, q, B = b, w, A = [], z, y;
                        p("$digest");
                        k.$$checkUrlChange();
                        this === s && null !== e && (k.defer.cancel(e), r());
                        c = null;
                        do {
                            q = !1;
                            w = this;
                            for (n = 0; n < J.length; n++) {
                                try {
                                    y = J[n], l = y.fn, l(y.scope, y.locals);
                                }
                                catch (x) {
                                    f(x);
                                }
                                c = null;
                            }
                            J.length = 0;
                            a: do {
                                if (n = !w.$$suspended && w.$$watchers)
                                    for (n.$$digestWatchIndex = n.length; n.$$digestWatchIndex--;)
                                        try {
                                            if (a =
                                                n[n.$$digestWatchIndex])
                                                if (m = a.get, (g = m(w)) !== (h = a.last) && !(a.eq ? sa(g, h) : X(g) && X(h)))
                                                    q = !0, c = a, a.last = a.eq ? na(g, null) : g, l = a.fn, l(g, h === v ? g : h, w), 5 > B && (z = 4 - B, A[z] || (A[z] = []), A[z].push({ msg: C(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp, newVal: g, oldVal: h }));
                                                else if (a === c) {
                                                    q = !1;
                                                    break a;
                                                }
                                        }
                                        catch (F) {
                                            f(F);
                                        }
                                if (!(n = !w.$$suspended && w.$$watchersCount && w.$$childHead || w !== this && w.$$nextSibling))
                                    for (; w !== this && !(n = w.$$nextSibling);)
                                        w = w.$parent;
                            } while (w = n);
                            if ((q || J.length) && !B--)
                                throw s.$$phase = null, d("infdig", b, A);
                        } while (q || J.length);
                        for (s.$$phase = null; H < u.length;)
                            try {
                                u[H++]();
                            }
                            catch (D) {
                                f(D);
                            }
                        u.length = H = 0;
                        k.$$checkUrlChange();
                    }, $suspend: function () { this.$$suspended = !0; }, $isSuspended: function () { return this.$$suspended; }, $resume: function () { this.$$suspended = !1; }, $destroy: function () {
                        if (!this.$$destroyed) {
                            var a = this.$parent;
                            this.$broadcast("$destroy");
                            this.$$destroyed = !0;
                            this === s && k.$$applicationDestroyed();
                            n(this, -this.$$watchersCount);
                            for (var b in this.$$listenerCount)
                                B(this, this.$$listenerCount[b], b);
                            a && a.$$childHead ===
                                this && (a.$$childHead = this.$$nextSibling);
                            a && a.$$childTail === this && (a.$$childTail = this.$$prevSibling);
                            this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling);
                            this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling);
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = D;
                            this.$on = this.$watch = this.$watchGroup = function () { return D; };
                            this.$$listeners = {};
                            this.$$nextSibling = null;
                            l(this);
                        }
                    }, $eval: function (a, b) { return g(a)(this, b); }, $evalAsync: function (a, b) {
                        s.$$phase ||
                            J.length || k.defer(function () { J.length && s.$digest(); });
                        J.push({ scope: this, fn: g(a), locals: b });
                    }, $$postDigest: function (a) { u.push(a); }, $apply: function (a) { try {
                        p("$apply");
                        try {
                            return this.$eval(a);
                        }
                        finally {
                            s.$$phase = null;
                        }
                    }
                    catch (b) {
                        f(b);
                    }
                    finally {
                        try {
                            s.$digest();
                        }
                        catch (c) {
                            throw f(c), c;
                        }
                    } }, $applyAsync: function (a) { function b() { c.$eval(a); } var c = this; a && w.push(b); a = g(a); A(); }, $on: function (a, b) {
                        var c = this.$$listeners[a];
                        c || (this.$$listeners[a] = c = []);
                        c.push(b);
                        var d = this;
                        do
                            d.$$listenerCount[a] || (d.$$listenerCount[a] =
                                0), d.$$listenerCount[a]++;
                        while (d = d.$parent);
                        var e = this;
                        return function () { var d = c.indexOf(b); -1 !== d && (delete c[d], B(e, 1, a)); };
                    }, $emit: function (a, b) {
                        var c = [], d, e = this, g = !1, h = { name: a, targetScope: e, stopPropagation: function () { g = !0; }, preventDefault: function () { h.defaultPrevented = !0; }, defaultPrevented: !1 }, k = db([h], arguments, 1), l, m;
                        do {
                            d = e.$$listeners[a] || c;
                            h.currentScope = e;
                            l = 0;
                            for (m = d.length; l < m; l++)
                                if (d[l])
                                    try {
                                        d[l].apply(null, k);
                                    }
                                    catch (n) {
                                        f(n);
                                    }
                                else
                                    d.splice(l, 1), l--, m--;
                            if (g)
                                break;
                            e = e.$parent;
                        } while (e);
                        h.currentScope =
                            null;
                        return h;
                    }, $broadcast: function (a, b) {
                        var c = this, d = this, e = { name: a, targetScope: this, preventDefault: function () { e.defaultPrevented = !0; }, defaultPrevented: !1 };
                        if (!this.$$listenerCount[a])
                            return e;
                        for (var g = db([e], arguments, 1), h, k; c = d;) {
                            e.currentScope = c;
                            d = c.$$listeners[a] || [];
                            h = 0;
                            for (k = d.length; h < k; h++)
                                if (d[h])
                                    try {
                                        d[h].apply(null, g);
                                    }
                                    catch (l) {
                                        f(l);
                                    }
                                else
                                    d.splice(h, 1), h--, k--;
                            if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling))
                                for (; c !== this && !(d = c.$$nextSibling);)
                                    c = c.$parent;
                        }
                        e.currentScope =
                            null;
                        return e;
                    } };
                var s = new m, J = s.$$asyncQueue = [], u = s.$$postDigestQueue = [], w = s.$$applyAsyncQueue = [], H = 0;
                return s;
            }];
    }
    function Ie() { var a = /^\s*(https?|s?ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function (b) { return u(b) ? (a = b, this) : a; }; this.imgSrcSanitizationWhitelist = function (a) { return u(a) ? (b = a, this) : b; }; this.$get = function () { return function (d, c) { var e = c ? b : a, f; f = ma(d && d.trim()).href; return "" === f || f.match(e) ? d : "unsafe:" + f; }; }; }
    function Ig(a) {
        if ("self" ===
            a)
            return a;
        if (F(a)) {
            if (-1 < a.indexOf("***"))
                throw wa("iwcard", a);
            a = Nd(a).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
            return new RegExp("^" + a + "$");
        }
        if ($a(a))
            return new RegExp("^" + a.source + "$");
        throw wa("imatcher");
    }
    function Od(a) { var b = []; u(a) && q(a, function (a) { b.push(Ig(a)); }); return b; }
    function Uf() {
        this.SCE_CONTEXTS = fa;
        var a = ["self"], b = [];
        this.resourceUrlWhitelist = function (b) { arguments.length && (a = Od(b)); return a; };
        this.resourceUrlBlacklist = function (a) { arguments.length && (b = Od(a)); return b; };
        this.$get = ["$injector", function (d) {
                function c(a, b) { return "self" === a ? Pd(b, Qd) : !!a.exec(b.href); }
                function e(a) { var b = function (a) { this.$$unwrapTrustedValue = function () { return a; }; }; a && (b.prototype = new a); b.prototype.valueOf = function () { return this.$$unwrapTrustedValue(); }; b.prototype.toString = function () { return this.$$unwrapTrustedValue().toString(); }; return b; }
                var f = function (a) { throw wa("unsafe"); };
                d.has("$sanitize") && (f = d.get("$sanitize"));
                var g = e(), k = {};
                k[fa.HTML] = e(g);
                k[fa.CSS] = e(g);
                k[fa.URL] = e(g);
                k[fa.JS] =
                    e(g);
                k[fa.RESOURCE_URL] = e(k[fa.URL]);
                return { trustAs: function (a, b) { var c = k.hasOwnProperty(a) ? k[a] : null; if (!c)
                        throw wa("icontext", a, b); if (null === b || x(b) || "" === b)
                        return b; if ("string" !== typeof b)
                        throw wa("itype", a); return new c(b); }, getTrusted: function (d, e) {
                        if (null === e || x(e) || "" === e)
                            return e;
                        var g = k.hasOwnProperty(d) ? k[d] : null;
                        if (g && e instanceof g)
                            return e.$$unwrapTrustedValue();
                        if (d === fa.RESOURCE_URL) {
                            var g = ma(e.toString()), p, n, q = !1;
                            p = 0;
                            for (n = a.length; p < n; p++)
                                if (c(a[p], g)) {
                                    q = !0;
                                    break;
                                }
                            if (q)
                                for (p = 0, n = b.length; p <
                                    n; p++)
                                    if (c(b[p], g)) {
                                        q = !1;
                                        break;
                                    }
                            if (q)
                                return e;
                            throw wa("insecurl", e.toString());
                        }
                        if (d === fa.HTML)
                            return f(e);
                        throw wa("unsafe");
                    }, valueOf: function (a) { return a instanceof g ? a.$$unwrapTrustedValue() : a; } };
            }];
    }
    function Tf() {
        var a = !0;
        this.enabled = function (b) { arguments.length && (a = !!b); return a; };
        this.$get = ["$parse", "$sceDelegate", function (b, d) {
                if (a && 8 > Ba)
                    throw wa("iequirks");
                var c = pa(fa);
                c.isEnabled = function () { return a; };
                c.trustAs = d.trustAs;
                c.getTrusted = d.getTrusted;
                c.valueOf = d.valueOf;
                a || (c.trustAs = c.getTrusted =
                    function (a, b) { return b; }, c.valueOf = ab);
                c.parseAs = function (a, d) { var e = b(d); return e.literal && e.constant ? e : b(d, function (b) { return c.getTrusted(a, b); }); };
                var e = c.parseAs, f = c.getTrusted, g = c.trustAs;
                q(fa, function (a, b) { var d = N(b); c[("parse_as_" + d).replace(Dc, wb)] = function (b) { return e(a, b); }; c[("get_trusted_" + d).replace(Dc, wb)] = function (b) { return f(a, b); }; c[("trust_as_" + d).replace(Dc, wb)] = function (b) { return g(a, b); }; });
                return c;
            }];
    }
    function Vf() {
        this.$get = ["$window", "$document", function (a, b) {
                var d = {}, c = !((!a.nw ||
                    !a.nw.process) && a.chrome && (a.chrome.app && a.chrome.app.runtime || !a.chrome.app && a.chrome.runtime && a.chrome.runtime.id)) && a.history && a.history.pushState, e = Z((/android (\d+)/.exec(N((a.navigator || {}).userAgent)) || [])[1]), f = /Boxee/i.test((a.navigator || {}).userAgent), g = b[0] || {}, k = g.body && g.body.style, h = !1, l = !1;
                k && (h = !!("transition" in k || "webkitTransition" in k), l = !!("animation" in k || "webkitAnimation" in k));
                return { history: !(!c || 4 > e || f), hasEvent: function (a) {
                        if ("input" === a && Ba)
                            return !1;
                        if (x(d[a])) {
                            var b = g.createElement("div");
                            d[a] = "on" + a in b;
                        }
                        return d[a];
                    }, csp: Ia(), transitions: h, animations: l, android: e };
            }];
    }
    function Xf() {
        var a;
        this.httpOptions = function (b) { return b ? (a = b, this) : a; };
        this.$get = ["$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function (b, d, c, e, f) {
                function g(k, h) {
                    g.totalPendingRequests++;
                    if (!F(k) || x(d.get(k)))
                        k = f.getTrustedResourceUrl(k);
                    var l = c.defaults && c.defaults.transformResponse;
                    I(l) ? l = l.filter(function (a) { return a !== wc; }) : l === wc && (l = null);
                    return c.get(k, P({ cache: d, transformResponse: l }, a)).finally(function () { g.totalPendingRequests--; }).then(function (a) {
                        d.put(k, a.data);
                        return a.data;
                    }, function (a) { h || (a = Jg("tpload", k, a.status, a.statusText), b(a)); return e.reject(a); });
                }
                g.totalPendingRequests = 0;
                return g;
            }];
    }
    function Yf() {
        this.$get = ["$rootScope", "$browser", "$location", function (a, b, d) {
                return { findBindings: function (a, b, d) { a = a.getElementsByClassName("ng-binding"); var g = []; q(a, function (a) { var c = ea.element(a).data("$binding"); c && q(c, function (c) { d ? (new RegExp("(^|\\s)" + Nd(b) + "(\\s|\\||$)")).test(c) && g.push(a) : -1 !== c.indexOf(b) && g.push(a); }); }); return g; }, findModels: function (a, b, d) { for (var g = ["ng-", "data-ng-", "ng\\:"], k = 0; k < g.length; ++k) {
                        var h = a.querySelectorAll("[" + g[k] + "model" + (d ? "=" : "*=") + '"' + b + '"]');
                        if (h.length)
                            return h;
                    } }, getLocation: function () { return d.url(); }, setLocation: function (b) { b !== d.url() && (d.url(b), a.$digest()); }, whenStable: function (a) { b.notifyWhenNoOutstandingRequests(a); } };
            }];
    }
    function Zf() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function (a, b, d, c, e) {
                function f(f, h, l) {
                    C(f) || (l = h, h = f, f = D);
                    var m = xa.call(arguments, 3), p = u(l) && !l, n = (p ? c : d).defer(), q = n.promise, v;
                    v = b.defer(function () { try {
                        n.resolve(f.apply(null, m));
                    }
                    catch (b) {
                        n.reject(b), e(b);
                    }
                    finally {
                        delete g[q.$$timeoutId];
                    } p || a.$apply(); }, h);
                    q.$$timeoutId = v;
                    g[v] = n;
                    return q;
                }
                var g = {};
                f.cancel = function (a) { return a && a.$$timeoutId in g ? (g[a.$$timeoutId].promise.$$state.pur = !0, g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], b.defer.cancel(a.$$timeoutId)) : !1; };
                return f;
            }];
    }
    function ma(a) {
        if (!F(a))
            return a;
        Ba && (W.setAttribute("href", a), a = W.href);
        W.setAttribute("href", a);
        return { href: W.href, protocol: W.protocol ?
                W.protocol.replace(/:$/, "") : "", host: W.host, search: W.search ? W.search.replace(/^\?/, "") : "", hash: W.hash ? W.hash.replace(/^#/, "") : "", hostname: W.hostname, port: W.port, pathname: "/" === W.pathname.charAt(0) ? W.pathname : "/" + W.pathname };
    }
    function Ag(a) { var b = [Qd].concat(a.map(ma)); return function (a) { a = ma(a); return b.some(Pd.bind(null, a)); }; }
    function Pd(a, b) { a = ma(a); b = ma(b); return a.protocol === b.protocol && a.host === b.host; }
    function $f() { this.$get = ka(y); }
    function Rd(a) {
        function b(a) { try {
            return decodeURIComponent(a);
        }
        catch (b) {
            return a;
        } }
        var d = a[0] || {}, c = {}, e = "";
        return function () { var a, g, k, h, l; try {
            a = d.cookie || "";
        }
        catch (m) {
            a = "";
        } if (a !== e)
            for (e = a, a = e.split("; "), c = {}, k = 0; k < a.length; k++)
                g = a[k], h = g.indexOf("="), 0 < h && (l = b(g.substring(0, h)), x(c[l]) && (c[l] = b(g.substring(h + 1)))); return c; };
    }
    function dg() { this.$get = Rd; }
    function gd(a) {
        function b(d, c) { if (G(d)) {
            var e = {};
            q(d, function (a, c) { e[c] = b(c, a); });
            return e;
        } return a.factory(d + "Filter", c); }
        this.register = b;
        this.$get = ["$injector", function (a) { return function (b) { return a.get(b + "Filter"); }; }];
        b("currency", Sd);
        b("date", Td);
        b("filter", Kg);
        b("json", Lg);
        b("limitTo", Mg);
        b("lowercase", Ng);
        b("number", Ud);
        b("orderBy", Vd);
        b("uppercase", Og);
    }
    function Kg() { return function (a, b, d, c) { if (!ja(a)) {
        if (null == a)
            return a;
        throw M("filter")("notarray", a);
    } c = c || "$"; var e; switch (Ec(b)) {
        case "function": break;
        case "boolean":
        case "null":
        case "number":
        case "string": e = !0;
        case "object":
            b = Pg(b, d, c, e);
            break;
        default: return a;
    } return Array.prototype.filter.call(a, b); }; }
    function Pg(a, b, d, c) {
        var e = G(a) && d in a;
        !0 === b ? b = sa : C(b) || (b = function (a, b) { if (x(a))
            return !1; if (null === a || null === b)
            return a === b; if (G(b) || G(a) && !ac(a))
            return !1; a = N("" + a); b = N("" + b); return -1 !== a.indexOf(b); });
        return function (f) { return e && !G(f) ? ga(f, a[d], b, d, !1) : ga(f, a, b, d, c); };
    }
    function ga(a, b, d, c, e, f) {
        var g = Ec(a), k = Ec(b);
        if ("string" === k && "!" === b.charAt(0))
            return !ga(a, b.substring(1), d, c, e);
        if (I(a))
            return a.some(function (a) { return ga(a, b, d, c, e); });
        switch (g) {
            case "object":
                var h;
                if (e) {
                    for (h in a)
                        if (h.charAt && "$" !== h.charAt(0) && ga(a[h], b, d, c, !0))
                            return !0;
                    return f ? !1 : ga(a, b, d, c, !1);
                }
                if ("object" ===
                    k) {
                    for (h in b)
                        if (f = b[h], !C(f) && !x(f) && (g = h === c, !ga(g ? a : a[h], f, d, c, g, g)))
                            return !1;
                    return !0;
                }
                return d(a, b);
            case "function": return !1;
            default: return d(a, b);
        }
    }
    function Ec(a) { return null === a ? "null" : typeof a; }
    function Sd(a) { var b = a.NUMBER_FORMATS; return function (a, c, e) { x(c) && (c = b.CURRENCY_SYM); x(e) && (e = b.PATTERNS[1].maxFrac); var f = c ? /\u00A4/g : /\s*\u00A4\s*/g; return null == a ? a : Wd(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(f, c); }; }
    function Ud(a) {
        var b = a.NUMBER_FORMATS;
        return function (a, c) {
            return null ==
                a ? a : Wd(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c);
        };
    }
    function Qg(a) { var b = 0, d, c, e, f, g; -1 < (c = a.indexOf(Xd)) && (a = a.replace(Xd, "")); 0 < (e = a.search(/e/i)) ? (0 > c && (c = e), c += +a.slice(e + 1), a = a.substring(0, e)) : 0 > c && (c = a.length); for (e = 0; a.charAt(e) === Fc; e++)
        ; if (e === (g = a.length))
        d = [0], c = 1;
    else {
        for (g--; a.charAt(g) === Fc;)
            g--;
        c -= e;
        d = [];
        for (f = 0; e <= g; e++, f++)
            d[f] = +a.charAt(e);
    } c > Yd && (d = d.splice(0, Yd - 1), b = c - 1, c = 1); return { d: d, e: b, i: c }; }
    function Rg(a, b, d, c) {
        var e = a.d, f = e.length - a.i;
        b = x(b) ? Math.min(Math.max(d, f), c) : +b;
        d =
            b + a.i;
        c = e[d];
        if (0 < d) {
            e.splice(Math.max(a.i, d));
            for (var g = d; g < e.length; g++)
                e[g] = 0;
        }
        else
            for (f = Math.max(0, f), a.i = 1, e.length = Math.max(1, d = b + 1), e[0] = 0, g = 1; g < d; g++)
                e[g] = 0;
        if (5 <= c)
            if (0 > d - 1) {
                for (c = 0; c > d; c--)
                    e.unshift(0), a.i++;
                e.unshift(1);
                a.i++;
            }
            else
                e[d - 1]++;
        for (; f < Math.max(0, b); f++)
            e.push(0);
        if (b = e.reduceRight(function (a, b, c, d) { b += a; d[c] = b % 10; return Math.floor(b / 10); }, 0))
            e.unshift(b), a.i++;
    }
    function Wd(a, b, d, c, e) {
        if (!F(a) && !Y(a) || isNaN(a))
            return "";
        var f = !isFinite(a), g = !1, k = Math.abs(a) + "", h = "";
        if (f)
            h = "\u221e";
        else {
            g = Qg(k);
            Rg(g, e, b.minFrac, b.maxFrac);
            h = g.d;
            k = g.i;
            e = g.e;
            f = [];
            for (g = h.reduce(function (a, b) { return a && !b; }, !0); 0 > k;)
                h.unshift(0), k++;
            0 < k ? f = h.splice(k, h.length) : (f = h, h = [0]);
            k = [];
            for (h.length >= b.lgSize && k.unshift(h.splice(-b.lgSize, h.length).join("")); h.length > b.gSize;)
                k.unshift(h.splice(-b.gSize, h.length).join(""));
            h.length && k.unshift(h.join(""));
            h = k.join(d);
            f.length && (h += c + f.join(""));
            e && (h += "e+" + e);
        }
        return 0 > a && !g ? b.negPre + h + b.negSuf : b.posPre + h + b.posSuf;
    }
    function Ob(a, b, d, c) {
        var e = "";
        if (0 > a || c && 0 >=
            a)
            c ? a = -a + 1 : (a = -a, e = "-");
        for (a = "" + a; a.length < b;)
            a = Fc + a;
        d && (a = a.substr(a.length - b));
        return e + a;
    }
    function ca(a, b, d, c, e) { d = d || 0; return function (f) { f = f["get" + a](); if (0 < d || f > -d)
        f += d; 0 === f && -12 === d && (f = 12); return Ob(f, b, c, e); }; }
    function mb(a, b, d) { return function (c, e) { var f = c["get" + a](), g = ub((d ? "STANDALONE" : "") + (b ? "SHORT" : "") + a); return e[g][f]; }; }
    function Zd(a) { var b = (new Date(a, 0, 1)).getDay(); return new Date(a, 0, (4 >= b ? 5 : 12) - b); }
    function $d(a) {
        return function (b) {
            var d = Zd(b.getFullYear());
            b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d;
            b = 1 + Math.round(b / 6048E5);
            return Ob(b, a);
        };
    }
    function Gc(a, b) { return 0 >= a.getFullYear() ? b.ERAS[0] : b.ERAS[1]; }
    function Td(a) {
        function b(a) { var b; if (b = a.match(d)) {
            a = new Date(0);
            var f = 0, g = 0, k = b[8] ? a.setUTCFullYear : a.setFullYear, h = b[8] ? a.setUTCHours : a.setHours;
            b[9] && (f = Z(b[9] + b[10]), g = Z(b[9] + b[11]));
            k.call(a, Z(b[1]), Z(b[2]) - 1, Z(b[3]));
            f = Z(b[4] || 0) - f;
            g = Z(b[5] || 0) - g;
            k = Z(b[6] || 0);
            b = Math.round(1E3 * parseFloat("0." + (b[7] || 0)));
            h.call(a, f, g, k, b);
        } return a; }
        var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function (c, d, f) { var g = "", k = [], h, l; d = d || "mediumDate"; d = a.DATETIME_FORMATS[d] || d; F(c) && (c = Sg.test(c) ? Z(c) : b(c)); Y(c) && (c = new Date(c)); if (!da(c) || !isFinite(c.getTime()))
            return c; for (; d;)
            (l = Tg.exec(d)) ? (k = db(k, l, 1), d = k.pop()) : (k.push(d), d = null); var m = c.getTimezoneOffset(); f && (m = dc(f, m), c = ec(c, f, !0)); q(k, function (b) { h = Ug[b]; g += h ? h(c, a.DATETIME_FORMATS, m) : "''" === b ? "'" : b.replace(/(^'|'$)/g, "").replace(/''/g, "'"); }); return g; };
    }
    function Lg() { return function (a, b) { x(b) && (b = 2); return eb(a, b); }; }
    function Mg() {
        return function (a, b, d) { b = Infinity === Math.abs(Number(b)) ? Number(b) : Z(b); if (X(b))
            return a; Y(a) && (a = a.toString()); if (!ja(a))
            return a; d = !d || isNaN(d) ? 0 : Z(d); d = 0 > d ? Math.max(0, a.length + d) : d; return 0 <= b ? Hc(a, d, d + b) : 0 === d ? Hc(a, b, a.length) : Hc(a, Math.max(0, d + b), d); };
    }
    function Hc(a, b, d) { return F(a) ? a.slice(b, d) : xa.call(a, b, d); }
    function Vd(a) {
        function b(b) {
            return b.map(function (b) {
                var c = 1, d = ab;
                if (C(b))
                    d = b;
                else if (F(b)) {
                    if ("+" === b.charAt(0) || "-" === b.charAt(0))
                        c = "-" === b.charAt(0) ? -1 : 1, b = b.substring(1);
                    if ("" !== b && (d = a(b), d.constant))
                        var e = d(), d = function (a) { return a[e]; };
                }
                return { get: d, descending: c };
            });
        }
        function d(a) { switch (typeof a) {
            case "number":
            case "boolean":
            case "string": return !0;
            default: return !1;
        } }
        function c(a, b) { var c = 0, d = a.type, h = b.type; if (d === h) {
            var h = a.value, l = b.value;
            "string" === d ? (h = h.toLowerCase(), l = l.toLowerCase()) : "object" === d && (G(h) && (h = a.index), G(l) && (l = b.index));
            h !== l && (c = h < l ? -1 : 1);
        }
        else
            c = d < h ? -1 : 1; return c; }
        return function (a, f, g, k) {
            if (null == a)
                return a;
            if (!ja(a))
                throw M("orderBy")("notarray", a);
            I(f) || (f = [f]);
            0 === f.length &&
                (f = ["+"]);
            var h = b(f), l = g ? -1 : 1, m = C(k) ? k : c;
            a = Array.prototype.map.call(a, function (a, b) { return { value: a, tieBreaker: { value: b, type: "number", index: b }, predicateValues: h.map(function (c) { var e = c.get(a); c = typeof e; if (null === e)
                    c = "string", e = "null";
                else if ("object" === c)
                    a: {
                        if (C(e.valueOf) && (e = e.valueOf(), d(e)))
                            break a;
                        ac(e) && (e = e.toString(), d(e));
                    } return { value: e, type: c, index: b }; }) }; });
            a.sort(function (a, b) {
                for (var d = 0, e = h.length; d < e; d++) {
                    var g = m(a.predicateValues[d], b.predicateValues[d]);
                    if (g)
                        return g * h[d].descending *
                            l;
                }
                return (m(a.tieBreaker, b.tieBreaker) || c(a.tieBreaker, b.tieBreaker)) * l;
            });
            return a = a.map(function (a) { return a.value; });
        };
    }
    function Ra(a) { C(a) && (a = { link: a }); a.restrict = a.restrict || "AC"; return ka(a); }
    function Pb(a, b, d, c, e) { this.$$controls = []; this.$error = {}; this.$$success = {}; this.$pending = void 0; this.$name = e(b.name || b.ngForm || "")(d); this.$dirty = !1; this.$valid = this.$pristine = !0; this.$submitted = this.$invalid = !1; this.$$parentForm = Qb; this.$$element = a; this.$$animate = c; ae(this); }
    function ae(a) {
        a.$$classCache = {};
        a.$$classCache[be] = !(a.$$classCache[nb] = a.$$element.hasClass(nb));
    }
    function ce(a) {
        function b(a, b, c) { c && !a.$$classCache[b] ? (a.$$animate.addClass(a.$$element, b), a.$$classCache[b] = !0) : !c && a.$$classCache[b] && (a.$$animate.removeClass(a.$$element, b), a.$$classCache[b] = !1); }
        function d(a, c, d) { c = c ? "-" + Xc(c, "-") : ""; b(a, nb + c, !0 === d); b(a, be + c, !1 === d); }
        var c = a.set, e = a.unset;
        a.clazz.prototype.$setValidity = function (a, g, k) {
            x(g) ? (this.$pending || (this.$pending = {}), c(this.$pending, a, k)) : (this.$pending && e(this.$pending, a, k), de(this.$pending) && (this.$pending = void 0));
            La(g) ? g ? (e(this.$error, a, k), c(this.$$success, a, k)) : (c(this.$error, a, k), e(this.$$success, a, k)) : (e(this.$error, a, k), e(this.$$success, a, k));
            this.$pending ? (b(this, "ng-pending", !0), this.$valid = this.$invalid = void 0, d(this, "", null)) : (b(this, "ng-pending", !1), this.$valid = de(this.$error), this.$invalid = !this.$valid, d(this, "", this.$valid));
            g = this.$pending && this.$pending[a] ? void 0 : this.$error[a] ? !1 : this.$$success[a] ? !0 : null;
            d(this, a, g);
            this.$$parentForm.$setValidity(a, g, this);
        };
    }
    function de(a) { if (a)
        for (var b in a)
            if (a.hasOwnProperty(b))
                return !1; return !0; }
    function Ic(a) { a.$formatters.push(function (b) { return a.$isEmpty(b) ? b : b.toString(); }); }
    function Va(a, b, d, c, e, f) {
        var g = N(b[0].type);
        if (!e.android) {
            var k = !1;
            b.on("compositionstart", function () { k = !0; });
            b.on("compositionupdate", function (a) { if (x(a.data) || "" === a.data)
                k = !1; });
            b.on("compositionend", function () { k = !1; l(); });
        }
        var h, l = function (a) {
            h && (f.defer.cancel(h), h = null);
            if (!k) {
                var e = b.val();
                a = a && a.type;
                "password" === g || d.ngTrim &&
                    "false" === d.ngTrim || (e = Q(e));
                (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a);
            }
        };
        if (e.hasEvent("input"))
            b.on("input", l);
        else {
            var m = function (a, b, c) { h || (h = f.defer(function () { h = null; b && b.value === c || l(a); })); };
            b.on("keydown", function (a) { var b = a.keyCode; 91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || m(a, this, this.value); });
            if (e.hasEvent("paste"))
                b.on("paste cut drop", m);
        }
        b.on("change", l);
        if (ee[g] && c.$$hasNativeValidators && g === d.type)
            b.on("keydown wheel mousedown", function (a) {
                if (!h) {
                    var b = this.validity, c = b.badInput, d = b.typeMismatch;
                    h = f.defer(function () { h = null; b.badInput === c && b.typeMismatch === d || l(a); });
                }
            });
        c.$render = function () { var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue; b.val() !== a && b.val(a); };
    }
    function Rb(a, b) {
        return function (d, c) {
            var e, f;
            if (da(d))
                return d;
            if (F(d)) {
                '"' === d.charAt(0) && '"' === d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1));
                if (Vg.test(d))
                    return new Date(d);
                a.lastIndex = 0;
                if (e = a.exec(d))
                    return e.shift(), f = c ? { yyyy: c.getFullYear(), MM: c.getMonth() + 1, dd: c.getDate(), HH: c.getHours(), mm: c.getMinutes(),
                        ss: c.getSeconds(), sss: c.getMilliseconds() / 1E3 } : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }, q(e, function (a, c) { c < b.length && (f[b[c]] = +a); }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0);
            }
            return NaN;
        };
    }
    function ob(a, b, d, c) {
        return function (e, f, g, k, h, l, m) {
            function p(a) { return a && !(a.getTime && a.getTime() !== a.getTime()); }
            function n(a) { return u(a) && !da(a) ? q(a) || void 0 : a; }
            function q(a, b) { var c = k.$options.getOption("timezone"); E && E !== c && (b = Uc(b, dc(E))); var e = d(a, b); !isNaN(e) && c && (e = ec(e, c)); return e; }
            Jc(e, f, g, k);
            Va(e, f, g, k, h, l);
            var r, E;
            k.$$parserName = a;
            k.$parsers.push(function (a) { if (k.$isEmpty(a))
                return null; if (b.test(a))
                return q(a, r); });
            k.$formatters.push(function (a) { if (a && !da(a))
                throw pb("datefmt", a); if (p(a)) {
                r = a;
                var b = k.$options.getOption("timezone");
                b && (E = b, r = ec(r, b, !0));
                return m("date")(a, c, b);
            } E = r = null; return ""; });
            if (u(g.min) || g.ngMin) {
                var A;
                k.$validators.min = function (a) { return !p(a) || x(A) || d(a) >= A; };
                g.$observe("min", function (a) { A = n(a); k.$validate(); });
            }
            if (u(g.max) || g.ngMax) {
                var s;
                k.$validators.max =
                    function (a) { return !p(a) || x(s) || d(a) <= s; };
                g.$observe("max", function (a) { s = n(a); k.$validate(); });
            }
        };
    }
    function Jc(a, b, d, c) { (c.$$hasNativeValidators = G(b[0].validity)) && c.$parsers.push(function (a) { var c = b.prop("validity") || {}; return c.badInput || c.typeMismatch ? void 0 : a; }); }
    function fe(a) { a.$$parserName = "number"; a.$parsers.push(function (b) { if (a.$isEmpty(b))
        return null; if (Wg.test(b))
        return parseFloat(b); }); a.$formatters.push(function (b) { if (!a.$isEmpty(b)) {
        if (!Y(b))
            throw pb("numfmt", b);
        b = b.toString();
    } return b; }); }
    function Wa(a) {
        u(a) &&
            !Y(a) && (a = parseFloat(a));
        return X(a) ? void 0 : a;
    }
    function Kc(a) { var b = a.toString(), d = b.indexOf("."); return -1 === d ? -1 < a && 1 > a && (a = /e-(\d+)$/.exec(b)) ? Number(a[1]) : 0 : b.length - d - 1; }
    function ge(a, b, d) { a = Number(a); var c = (a | 0) !== a, e = (b | 0) !== b, f = (d | 0) !== d; if (c || e || f) {
        var g = c ? Kc(a) : 0, k = e ? Kc(b) : 0, h = f ? Kc(d) : 0, g = Math.max(g, k, h), g = Math.pow(10, g);
        a *= g;
        b *= g;
        d *= g;
        c && (a = Math.round(a));
        e && (b = Math.round(b));
        f && (d = Math.round(d));
    } return 0 === (a - b) % d; }
    function he(a, b, d, c, e) {
        if (u(c)) {
            a = a(c);
            if (!a.constant)
                throw pb("constexpr", d, c);
            return a(b);
        }
        return e;
    }
    function Lc(a, b) {
        function d(a, b) { if (!a || !a.length)
            return []; if (!b || !b.length)
            return a; var c = [], d = 0; a: for (; d < a.length; d++) {
            for (var e = a[d], f = 0; f < b.length; f++)
                if (e === b[f])
                    continue a;
            c.push(e);
        } return c; }
        function c(a) { var b = a; I(a) ? b = a.map(c).join(" ") : G(a) && (b = Object.keys(a).filter(function (b) { return a[b]; }).join(" ")); return b; }
        function e(a) { var b = a; if (I(a))
            b = a.map(e);
        else if (G(a)) {
            var c = !1, b = Object.keys(a).filter(function (b) { b = a[b]; !c && x(b) && (c = !0); return b; });
            c && b.push(void 0);
        } return b; }
        a = "ngClass" + a;
        var f;
        return ["$parse", function (g) {
                return { restrict: "AC", link: function (k, h, l) {
                        function m(a, b) { var c = []; q(a, function (a) { if (0 < b || s[a])
                            s[a] = (s[a] || 0) + b, s[a] === +(0 < b) && c.push(a); }); return c.join(" "); }
                        function p(a) { if (a === b) {
                            var c = z, c = m(c && c.split(" "), 1);
                            l.$addClass(c);
                        }
                        else
                            c = z, c = m(c && c.split(" "), -1), l.$removeClass(c); u = a; }
                        function n(a) { a = c(a); a !== z && r(a); }
                        function r(a) {
                            if (u === b) {
                                var c = z && z.split(" "), e = a && a.split(" "), g = d(c, e), c = d(e, c), g = m(g, -1), c = m(c, 1);
                                l.$addClass(c);
                                l.$removeClass(g);
                            }
                            z =
                                a;
                        }
                        var v = l[a].trim(), E = ":" === v.charAt(0) && ":" === v.charAt(1), v = g(v, E ? e : c), A = E ? n : r, s = h.data("$classCounts"), u = !0, z;
                        s || (s = R(), h.data("$classCounts", s));
                        "ngClass" !== a && (f || (f = g("$index", function (a) { return a & 1; })), k.$watch(f, p));
                        k.$watch(v, A, E);
                    } };
            }];
    }
    function Sb(a, b, d, c, e, f, g, k, h) {
        this.$modelValue = this.$viewValue = Number.NaN;
        this.$$rawModelValue = void 0;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = !0;
        this.$touched = !1;
        this.$pristine =
            !0;
        this.$dirty = !1;
        this.$valid = !0;
        this.$invalid = !1;
        this.$error = {};
        this.$$success = {};
        this.$pending = void 0;
        this.$name = h(d.name || "", !1)(a);
        this.$$parentForm = Qb;
        this.$options = Tb;
        this.$$updateEvents = "";
        this.$$updateEventHandler = this.$$updateEventHandler.bind(this);
        this.$$parsedNgModel = e(d.ngModel);
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
        this.$$ngModelGet = this.$$parsedNgModel;
        this.$$ngModelSet = this.$$parsedNgModelAssign;
        this.$$pendingDebounce = null;
        this.$$parserValid = void 0;
        this.$$currentValidationRunId =
            0;
        Object.defineProperty(this, "$$scope", { value: a });
        this.$$attr = d;
        this.$$element = c;
        this.$$animate = f;
        this.$$timeout = g;
        this.$$parse = e;
        this.$$q = k;
        this.$$exceptionHandler = b;
        ae(this);
        Xg(this);
    }
    function Xg(a) { a.$$scope.$watch(function (b) { b = a.$$ngModelGet(b); b === a.$modelValue || a.$modelValue !== a.$modelValue && b !== b || a.$$setModelValue(b); return b; }); }
    function Mc(a) { this.$$options = a; }
    function ie(a, b) { q(b, function (b, c) { u(a[c]) || (a[c] = b); }); }
    function Fa(a, b) { a.prop("selected", b); a.attr("selected", b); }
    var Oc = { objectMaxDepth: 5 }, Yg = /^\/(.+)\/([a-z]*)$/, ra = Object.prototype.hasOwnProperty, N = function (a) { return F(a) ? a.toLowerCase() : a; }, ub = function (a) { return F(a) ? a.toUpperCase() : a; }, Ba, z, ta, xa = [].slice, wg = [].splice, Zg = [].push, ha = Object.prototype.toString, Rc = Object.getPrototypeOf, oa = M("ng"), ea = y.angular || (y.angular = {}), jc, qb = 0;
    Ba = y.document.documentMode;
    var X = Number.isNaN || function (a) { return a !== a; };
    D.$inject = [];
    ab.$inject = [];
    var I = Array.isArray, ue = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, Q = function (a) { return F(a) ? a.trim() : a; }, Nd = function (a) { return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08"); }, Ia = function () {
        if (!u(Ia.rules)) {
            var a = y.document.querySelector("[ng-csp]") || y.document.querySelector("[data-ng-csp]");
            if (a) {
                var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp");
                Ia.rules = { noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"), noInlineStyle: !b || -1 !== b.indexOf("no-inline-style") };
            }
            else {
                a = Ia;
                try {
                    new Function(""), b = !1;
                }
                catch (d) {
                    b = !0;
                }
                a.rules = { noUnsafeEval: b,
                    noInlineStyle: !1 };
            }
        }
        return Ia.rules;
    }, rb = function () { if (u(rb.name_))
        return rb.name_; var a, b, d = Ga.length, c, e; for (b = 0; b < d; ++b)
        if (c = Ga[b], a = y.document.querySelector("[" + c.replace(":", "\\:") + "jq]")) {
            e = a.getAttribute(c + "jq");
            break;
        } return rb.name_ = e; }, we = /:/g, Ga = ["ng-", "data-ng-", "ng:", "x-ng-"], ze = function (a) {
        var b = a.currentScript;
        if (!b)
            return !0;
        if (!(b instanceof y.HTMLScriptElement || b instanceof y.SVGScriptElement))
            return !1;
        b = b.attributes;
        return [b.getNamedItem("src"), b.getNamedItem("href"), b.getNamedItem("xlink:href")].every(function (b) {
            if (!b)
                return !0;
            if (!b.value)
                return !1;
            var c = a.createElement("a");
            c.href = b.value;
            if (a.location.origin === c.origin)
                return !0;
            switch (c.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "blob:":
                case "file:":
                case "data:": return !0;
                default: return !1;
            }
        });
    }(y.document), Ce = /[A-Z]/g, Yc = !1, Ma = 3, He = { full: "1.6.10", major: 1, minor: 6, dot: 10, codeName: "crystalline-persuasion" };
    S.expando = "ng339";
    var ib = S.cache = {}, ig = 1;
    S._data = function (a) { return this.cache[a[this.expando]] || {}; };
    var eg = /-([a-z])/g, $g = /^-ms-/, Ab = { mouseleave: "mouseout", mouseenter: "mouseover" }, mc = M("jqLite"), hg = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, lc = /<|&#?\w+;/, fg = /<([\w:-]+)/, gg = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, $ = { option: [1, '<select multiple="multiple">', "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
    $.optgroup = $.option;
    $.tbody = $.tfoot = $.colgroup = $.caption = $.thead;
    $.th = $.td;
    var ng = y.Node.prototype.contains ||
        function (a) { return !!(this.compareDocumentPosition(a) & 16); }, Ua = S.prototype = { ready: id, toString: function () { var a = []; q(this, function (b) { a.push("" + b); }); return "[" + a.join(", ") + "]"; }, eq: function (a) { return 0 <= a ? z(this[a]) : z(this[this.length + a]); }, length: 0, push: Zg, sort: [].sort, splice: [].splice }, Gb = {};
    q("multiple selected checked disabled readOnly required open".split(" "), function (a) { Gb[N(a)] = a; });
    var nd = {};
    q("input select option textarea button form details".split(" "), function (a) { nd[a] = !0; });
    var ud = { ngMinlength: "minlength",
        ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern", ngStep: "step" };
    q({ data: qc, removeData: pc, hasData: function (a) { for (var b in ib[a.ng339])
            return !0; return !1; }, cleanData: function (a) { for (var b = 0, d = a.length; b < d; b++)
            pc(a[b]); } }, function (a, b) { S[b] = a; });
    q({ data: qc, inheritedData: Eb, scope: function (a) { return z.data(a, "$scope") || Eb(a.parentNode || a, ["$isolateScope", "$scope"]); }, isolateScope: function (a) { return z.data(a, "$isolateScope") || z.data(a, "$isolateScopeNoTemplate"); }, controller: kd, injector: function (a) {
            return Eb(a, "$injector");
        }, removeAttr: function (a, b) { a.removeAttribute(b); }, hasClass: Bb, css: function (a, b, d) { b = xb(b.replace($g, "ms-")); if (u(d))
            a.style[b] = d;
        else
            return a.style[b]; }, attr: function (a, b, d) { var c = a.nodeType; if (c !== Ma && 2 !== c && 8 !== c && a.getAttribute) {
            var c = N(b), e = Gb[c];
            if (u(d))
                null === d || !1 === d && e ? a.removeAttribute(b) : a.setAttribute(b, e ? c : d);
            else
                return a = a.getAttribute(b), e && null !== a && (a = c), null === a ? void 0 : a;
        } }, prop: function (a, b, d) { if (u(d))
            a[b] = d;
        else
            return a[b]; }, text: function () {
            function a(a, d) {
                if (x(d)) {
                    var c = a.nodeType;
                    return 1 === c || c === Ma ? a.textContent : "";
                }
                a.textContent = d;
            }
            a.$dv = "";
            return a;
        }(), val: function (a, b) { if (x(b)) {
            if (a.multiple && "select" === ya(a)) {
                var d = [];
                q(a.options, function (a) { a.selected && d.push(a.value || a.text); });
                return d;
            }
            return a.value;
        } a.value = b; }, html: function (a, b) { if (x(b))
            return a.innerHTML; yb(a, !0); a.innerHTML = b; }, empty: ld }, function (a, b) {
        S.prototype[b] = function (b, c) {
            var e, f, g = this.length;
            if (a !== ld && x(2 === a.length && a !== Bb && a !== kd ? b : c)) {
                if (G(b)) {
                    for (e = 0; e < g; e++)
                        if (a === qc)
                            a(this[e], b);
                        else
                            for (f in b)
                                a(this[e], f, b[f]);
                    return this;
                }
                e = a.$dv;
                g = x(e) ? Math.min(g, 1) : g;
                for (f = 0; f < g; f++) {
                    var k = a(this[f], b, c);
                    e = e ? e + k : k;
                }
                return e;
            }
            for (e = 0; e < g; e++)
                a(this[e], b, c);
            return this;
        };
    });
    q({ removeData: pc, on: function (a, b, d, c) {
            if (u(c))
                throw mc("onargs");
            if (kc(a)) {
                c = zb(a, !0);
                var e = c.events, f = c.handle;
                f || (f = c.handle = kg(a, e));
                c = 0 <= b.indexOf(" ") ? b.split(" ") : [b];
                for (var g = c.length, k = function (b, c, g) { var k = e[b]; k || (k = e[b] = [], k.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f)); k.push(d); }; g--;)
                    b = c[g], Ab[b] ? (k(Ab[b], mg),
                        k(b, void 0, !0)) : k(b);
            }
        }, off: jd, one: function (a, b, d) { a = z(a); a.on(b, function e() { a.off(b, d); a.off(b, e); }); a.on(b, d); }, replaceWith: function (a, b) { var d, c = a.parentNode; yb(a); q(new S(b), function (b) { d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a); d = b; }); }, children: function (a) { var b = []; q(a.childNodes, function (a) { 1 === a.nodeType && b.push(a); }); return b; }, contents: function (a) { return a.contentDocument || a.childNodes || []; }, append: function (a, b) {
            var d = a.nodeType;
            if (1 === d || 11 === d) {
                b = new S(b);
                for (var d = 0, c = b.length; d <
                    c; d++)
                    a.appendChild(b[d]);
            }
        }, prepend: function (a, b) { if (1 === a.nodeType) {
            var d = a.firstChild;
            q(new S(b), function (b) { a.insertBefore(b, d); });
        } }, wrap: function (a, b) { var d = z(b).eq(0).clone()[0], c = a.parentNode; c && c.replaceChild(d, a); d.appendChild(a); }, remove: Fb, detach: function (a) { Fb(a, !0); }, after: function (a, b) { var d = a, c = a.parentNode; if (c) {
            b = new S(b);
            for (var e = 0, f = b.length; e < f; e++) {
                var g = b[e];
                c.insertBefore(g, d.nextSibling);
                d = g;
            }
        } }, addClass: Db, removeClass: Cb, toggleClass: function (a, b, d) {
            b && q(b.split(" "), function (b) {
                var e = d;
                x(e) && (e = !Bb(a, b));
                (e ? Db : Cb)(a, b);
            });
        }, parent: function (a) { return (a = a.parentNode) && 11 !== a.nodeType ? a : null; }, next: function (a) { return a.nextElementSibling; }, find: function (a, b) { return a.getElementsByTagName ? a.getElementsByTagName(b) : []; }, clone: oc, triggerHandler: function (a, b, d) {
            var c, e, f = b.type || b, g = zb(a);
            if (g = (g = g && g.events) && g[f])
                c = { preventDefault: function () { this.defaultPrevented = !0; }, isDefaultPrevented: function () { return !0 === this.defaultPrevented; }, stopImmediatePropagation: function () {
                        this.immediatePropagationStopped =
                            !0;
                    }, isImmediatePropagationStopped: function () { return !0 === this.immediatePropagationStopped; }, stopPropagation: D, type: f, target: a }, b.type && (c = P(c, b)), b = pa(g), e = d ? [c].concat(d) : [c], q(b, function (b) { c.isImmediatePropagationStopped() || b.apply(a, e); });
        } }, function (a, b) { S.prototype[b] = function (b, c, e) { for (var f, g = 0, k = this.length; g < k; g++)
        x(f) ? (f = a(this[g], b, c, e), u(f) && (f = z(f))) : nc(f, a(this[g], b, c, e)); return u(f) ? f : this; }; });
    S.prototype.bind = S.prototype.on;
    S.prototype.unbind = S.prototype.off;
    var ah = Object.create(null);
    od.prototype = { _idx: function (a) { if (a === this._lastKey)
            return this._lastIndex; this._lastKey = a; return this._lastIndex = this._keys.indexOf(a); }, _transformKey: function (a) { return X(a) ? ah : a; }, get: function (a) { a = this._transformKey(a); a = this._idx(a); if (-1 !== a)
            return this._values[a]; }, set: function (a, b) { a = this._transformKey(a); var d = this._idx(a); -1 === d && (d = this._lastIndex = this._keys.length); this._keys[d] = a; this._values[d] = b; }, delete: function (a) {
            a = this._transformKey(a);
            a = this._idx(a);
            if (-1 === a)
                return !1;
            this._keys.splice(a, 1);
            this._values.splice(a, 1);
            this._lastKey = NaN;
            this._lastIndex = -1;
            return !0;
        } };
    var Hb = od, cg = [function () { this.$get = [function () { return Hb; }]; }], pg = /^([^(]+?)=>/, qg = /^[^(]*\(\s*([^)]*)\)/m, bh = /,/, ch = /^\s*(_?)(\S+?)\1\s*$/, og = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Aa = M("$injector");
    gb.$$annotate = function (a, b, d) {
        var c;
        if ("function" === typeof a) {
            if (!(c = a.$inject)) {
                c = [];
                if (a.length) {
                    if (b)
                        throw F(d) && d || (d = a.name || rg(a)), Aa("strictdi", d);
                    b = pd(a);
                    q(b[1].split(bh), function (a) { a.replace(ch, function (a, b, d) { c.push(d); }); });
                }
                a.$inject =
                    c;
            }
        }
        else
            I(a) ? (b = a.length - 1, sb(a[b], "fn"), c = a.slice(0, b)) : sb(a, "fn", !0);
        return c;
    };
    var je = M("$animate"), uf = function () { this.$get = D; }, vf = function () {
        var a = new Hb, b = [];
        this.$get = ["$$AnimateRunner", "$rootScope", function (d, c) {
                function e(a, b, c) { var d = !1; b && (b = F(b) ? b.split(" ") : I(b) ? b : [], q(b, function (b) { b && (d = !0, a[b] = c); })); return d; }
                function f() {
                    q(b, function (b) {
                        var c = a.get(b);
                        if (c) {
                            var d = sg(b.attr("class")), e = "", f = "";
                            q(c, function (a, b) { a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b); });
                            q(b, function (a) {
                                e &&
                                    Db(a, e);
                                f && Cb(a, f);
                            });
                            a.delete(b);
                        }
                    });
                    b.length = 0;
                }
                return { enabled: D, on: D, off: D, pin: D, push: function (g, k, h, l) { l && l(); h = h || {}; h.from && g.css(h.from); h.to && g.css(h.to); if (h.addClass || h.removeClass)
                        if (k = h.addClass, l = h.removeClass, h = a.get(g) || {}, k = e(h, k, !0), l = e(h, l, !1), k || l)
                            a.set(g, h), b.push(g), 1 === b.length && c.$$postDigest(f); g = new d; g.complete(); return g; } };
            }];
    }, sf = ["$provide", function (a) {
            var b = this, d = null, c = null;
            this.$$registeredAnimations = Object.create(null);
            this.register = function (c, d) {
                if (c && "." !== c.charAt(0))
                    throw je("notcsel", c);
                var g = c + "-animation";
                b.$$registeredAnimations[c.substr(1)] = g;
                a.factory(g, d);
            };
            this.customFilter = function (a) { 1 === arguments.length && (c = C(a) ? a : null); return c; };
            this.classNameFilter = function (a) { if (1 === arguments.length && (d = a instanceof RegExp ? a : null) && /[(\s|\/)]ng-animate[(\s|\/)]/.test(d.toString()))
                throw d = null, je("nongcls", "ng-animate"); return d; };
            this.$get = ["$$animateQueue", function (a) {
                    function b(a, c, d) {
                        if (d) {
                            var e;
                            a: {
                                for (e = 0; e < d.length; e++) {
                                    var f = d[e];
                                    if (1 === f.nodeType) {
                                        e = f;
                                        break a;
                                    }
                                }
                                e = void 0;
                            }
                            !e ||
                                e.parentNode || e.previousElementSibling || (d = null);
                        }
                        d ? d.after(a) : c.prepend(a);
                    }
                    return { on: a.on, off: a.off, pin: a.pin, enabled: a.enabled, cancel: function (a) { a.end && a.end(); }, enter: function (c, d, h, l) { d = d && z(d); h = h && z(h); d = d || h.parent(); b(c, d, h); return a.push(c, "enter", Ja(l)); }, move: function (c, d, h, l) { d = d && z(d); h = h && z(h); d = d || h.parent(); b(c, d, h); return a.push(c, "move", Ja(l)); }, leave: function (b, c) { return a.push(b, "leave", Ja(c), function () { b.remove(); }); }, addClass: function (b, c, d) {
                            d = Ja(d);
                            d.addClass = jb(d.addclass, c);
                            return a.push(b, "addClass", d);
                        }, removeClass: function (b, c, d) { d = Ja(d); d.removeClass = jb(d.removeClass, c); return a.push(b, "removeClass", d); }, setClass: function (b, c, d, f) { f = Ja(f); f.addClass = jb(f.addClass, c); f.removeClass = jb(f.removeClass, d); return a.push(b, "setClass", f); }, animate: function (b, c, d, f, m) { m = Ja(m); m.from = m.from ? P(m.from, c) : c; m.to = m.to ? P(m.to, d) : d; m.tempClasses = jb(m.tempClasses, f || "ng-inline-animate"); return a.push(b, "animate", m); } };
                }];
        }], xf = function () {
        this.$get = ["$$rAF", function (a) {
                function b(b) {
                    d.push(b);
                    1 < d.length ||
                        a(function () { for (var a = 0; a < d.length; a++)
                            d[a](); d = []; });
                }
                var d = [];
                return function () { var a = !1; b(function () { a = !0; }); return function (d) { a ? d() : b(d); }; };
            }];
    }, wf = function () {
        this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function (a, b, d, c, e) {
                function f(a) { this.setHost(a); var b = d(); this._doneCallbacks = []; this._tick = function (a) { c() ? e(a, 0, !1) : b(a); }; this._state = 0; }
                f.chain = function (a, b) { function c() { if (d === a.length)
                    b(!0);
                else
                    a[d](function (a) { !1 === a ? b(!1) : (d++, c()); }); } var d = 0; c(); };
                f.all =
                    function (a, b) { function c(f) { e = e && f; ++d === a.length && b(e); } var d = 0, e = !0; q(a, function (a) { a.done(c); }); };
                f.prototype = { setHost: function (a) { this.host = a || {}; }, done: function (a) { 2 === this._state ? a() : this._doneCallbacks.push(a); }, progress: D, getPromise: function () { if (!this.promise) {
                        var b = this;
                        this.promise = a(function (a, c) { b.done(function (b) { !1 === b ? c() : a(); }); });
                    } return this.promise; }, then: function (a, b) { return this.getPromise().then(a, b); }, "catch": function (a) { return this.getPromise()["catch"](a); }, "finally": function (a) { return this.getPromise()["finally"](a); },
                    pause: function () { this.host.pause && this.host.pause(); }, resume: function () { this.host.resume && this.host.resume(); }, end: function () { this.host.end && this.host.end(); this._resolve(!0); }, cancel: function () { this.host.cancel && this.host.cancel(); this._resolve(!1); }, complete: function (a) { var b = this; 0 === b._state && (b._state = 1, b._tick(function () { b._resolve(a); })); }, _resolve: function (a) { 2 !== this._state && (q(this._doneCallbacks, function (b) { b(a); }), this._doneCallbacks.length = 0, this._state = 2); } };
                return f;
            }];
    }, tf = function () {
        this.$get =
            ["$$rAF", "$q", "$$AnimateRunner", function (a, b, d) { return function (b, e) { function f() { a(function () { g.addClass && (b.addClass(g.addClass), g.addClass = null); g.removeClass && (b.removeClass(g.removeClass), g.removeClass = null); g.to && (b.css(g.to), g.to = null); k || h.complete(); k = !0; }); return h; } var g = e || {}; g.$$prepared || (g = na(g)); g.cleanupStyles && (g.from = g.to = null); g.from && (b.css(g.from), g.from = null); var k, h = new d; return { start: f, end: f }; }; }];
    }, aa = M("$compile"), uc = new function () { };
    $c.$inject = ["$provide", "$$sanitizeUriProvider"];
    Jb.prototype.isFirstChange = function () { return this.previousValue === uc; };
    var qd = /^((?:x|data)[:\-_])/i, vg = /[:\-_]+(.)/g, wd = M("$controller"), vd = /^(\S+)(\s+as\s+([\w$]+))?$/, Ef = function () { this.$get = ["$document", function (a) { return function (b) { b ? !b.nodeType && b instanceof z && (b = b[0]) : b = a[0].body; return b.offsetWidth + 1; }; }]; }, xd = "application/json", xc = { "Content-Type": xd + ";charset=utf-8" }, yg = /^\[|^\{(?!\{)/, zg = { "[": /]$/, "{": /}$/ }, xg = /^\)]\}',?\n/, Kb = M("$http"), Ea = ea.$interpolateMinErr = M("$interpolate");
    Ea.throwNoconcat =
        function (a) { throw Ea("noconcat", a); };
    Ea.interr = function (a, b) { return Ea("interr", a, b.toString()); };
    var Mf = function () { this.$get = function () { function a(a) { var b = function (a) { b.data = a; b.called = !0; }; b.id = a; return b; } var b = ea.callbacks, d = {}; return { createCallback: function (c) { c = "_" + (b.$$counter++).toString(36); var e = "angular.callbacks." + c, f = a(c); d[e] = b[c] = f; return e; }, wasCalled: function (a) { return d[a].called; }, getResponse: function (a) { return d[a].data; }, removeCallback: function (a) { delete b[d[a].id]; delete d[a]; } }; }; }, dh = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, Cg = { http: 80, https: 443, ftp: 21 }, kb = M("$location"), Dg = /^\s*[\\/]{2,}/, eh = { $$absUrl: "", $$html5: !1, $$replace: !1, absUrl: Lb("$$absUrl"), url: function (a) { if (x(a))
            return this.$$url; var b = dh.exec(a); (b[1] || "" === a) && this.path(decodeURIComponent(b[1])); (b[2] || b[1] || "" === a) && this.search(b[3] || ""); this.hash(b[5] || ""); return this; }, protocol: Lb("$$protocol"), host: Lb("$$host"), port: Lb("$$port"), path: Ed("$$path", function (a) {
            a = null !== a ? a.toString() : "";
            return "/" === a.charAt(0) ? a : "/" +
                a;
        }), search: function (a, b) { switch (arguments.length) {
            case 0: return this.$$search;
            case 1:
                if (F(a) || Y(a))
                    a = a.toString(), this.$$search = fc(a);
                else if (G(a))
                    a = na(a, {}), q(a, function (b, c) { null == b && delete a[c]; }), this.$$search = a;
                else
                    throw kb("isrcharg");
                break;
            default: x(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b;
        } this.$$compose(); return this; }, hash: Ed("$$hash", function (a) { return null !== a ? a.toString() : ""; }), replace: function () { this.$$replace = !0; return this; } };
    q([Dd, Bc, Ac], function (a) {
        a.prototype = Object.create(eh);
        a.prototype.state = function (b) { if (!arguments.length)
            return this.$$state; if (a !== Ac || !this.$$html5)
            throw kb("nostate"); this.$$state = x(b) ? null : b; this.$$urlUpdatedByLocation = !0; return this; };
    });
    var Xa = M("$parse"), Hg = {}.constructor.prototype.valueOf, Ub = R();
    q("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (a) { Ub[a] = !0; });
    var fh = { n: "\n", f: "\f", r: "\r", t: "\t", v: "\v", "'": "'", '"': '"' }, Nb = function (a) { this.options = a; };
    Nb.prototype = { constructor: Nb, lex: function (a) {
            this.text = a;
            this.index = 0;
            for (this.tokens =
                []; this.index < this.text.length;)
                if (a = this.text.charAt(this.index), '"' === a || "'" === a)
                    this.readString(a);
                else if (this.isNumber(a) || "." === a && this.isNumber(this.peek()))
                    this.readNumber();
                else if (this.isIdentifierStart(this.peekMultichar()))
                    this.readIdent();
                else if (this.is(a, "(){}[].,;:?"))
                    this.tokens.push({ index: this.index, text: a }), this.index++;
                else if (this.isWhitespace(a))
                    this.index++;
                else {
                    var b = a + this.peek(), d = b + this.peek(2), c = Ub[b], e = Ub[d];
                    Ub[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({ index: this.index,
                        text: a, operator: !0 }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            return this.tokens;
        }, is: function (a, b) { return -1 !== b.indexOf(a); }, peek: function (a) { a = a || 1; return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1; }, isNumber: function (a) { return "0" <= a && "9" >= a && "string" === typeof a; }, isWhitespace: function (a) { return " " === a || "\r" === a || "\t" === a || "\n" === a || "\v" === a || "\u00a0" === a; }, isIdentifierStart: function (a) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(a, this.codePointAt(a)) : this.isValidIdentifierStart(a);
        }, isValidIdentifierStart: function (a) { return "a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a; }, isIdentifierContinue: function (a) { return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(a, this.codePointAt(a)) : this.isValidIdentifierContinue(a); }, isValidIdentifierContinue: function (a, b) { return this.isValidIdentifierStart(a, b) || this.isNumber(a); }, codePointAt: function (a) {
            return 1 === a.length ? a.charCodeAt(0) : (a.charCodeAt(0) << 10) + a.charCodeAt(1) -
                56613888;
        }, peekMultichar: function () { var a = this.text.charAt(this.index), b = this.peek(); if (!b)
            return a; var d = a.charCodeAt(0), c = b.charCodeAt(0); return 55296 <= d && 56319 >= d && 56320 <= c && 57343 >= c ? a + b : a; }, isExpOperator: function (a) { return "-" === a || "+" === a || this.isNumber(a); }, throwError: function (a, b, d) { d = d || this.index; b = u(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d; throw Xa("lexerr", a, b, this.text); }, readNumber: function () {
            for (var a = "", b = this.index; this.index < this.text.length;) {
                var d = N(this.text.charAt(this.index));
                if ("." === d || this.isNumber(d))
                    a += d;
                else {
                    var c = this.peek();
                    if ("e" === d && this.isExpOperator(c))
                        a += d;
                    else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" === a.charAt(a.length - 1))
                        a += d;
                    else if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" !== a.charAt(a.length - 1))
                        break;
                    else
                        this.throwError("Invalid exponent");
                }
                this.index++;
            }
            this.tokens.push({ index: b, text: a, constant: !0, value: Number(a) });
        }, readIdent: function () {
            var a = this.index;
            for (this.index += this.peekMultichar().length; this.index < this.text.length;) {
                var b = this.peekMultichar();
                if (!this.isIdentifierContinue(b))
                    break;
                this.index += b.length;
            }
            this.tokens.push({ index: a, text: this.text.slice(a, this.index), identifier: !0 });
        }, readString: function (a) {
            var b = this.index;
            this.index++;
            for (var d = "", c = a, e = !1; this.index < this.text.length;) {
                var f = this.text.charAt(this.index), c = c + f;
                if (e)
                    "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d +=
                        fh[f] || f, e = !1;
                else if ("\\" === f)
                    e = !0;
                else {
                    if (f === a) {
                        this.index++;
                        this.tokens.push({ index: b, text: c, constant: !0, value: d });
                        return;
                    }
                    d += f;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", b);
        } };
    var r = function (a, b) { this.lexer = a; this.options = b; };
    r.Program = "Program";
    r.ExpressionStatement = "ExpressionStatement";
    r.AssignmentExpression = "AssignmentExpression";
    r.ConditionalExpression = "ConditionalExpression";
    r.LogicalExpression = "LogicalExpression";
    r.BinaryExpression = "BinaryExpression";
    r.UnaryExpression = "UnaryExpression";
    r.CallExpression = "CallExpression";
    r.MemberExpression = "MemberExpression";
    r.Identifier = "Identifier";
    r.Literal = "Literal";
    r.ArrayExpression = "ArrayExpression";
    r.Property = "Property";
    r.ObjectExpression = "ObjectExpression";
    r.ThisExpression = "ThisExpression";
    r.LocalsExpression = "LocalsExpression";
    r.NGValueParameter = "NGValueParameter";
    r.prototype = { ast: function (a) { this.text = a; this.tokens = this.lexer.lex(a); a = this.program(); 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]); return a; },
        program: function () { for (var a = [];;)
            if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), !this.expect(";"))
                return { type: r.Program, body: a }; }, expressionStatement: function () { return { type: r.ExpressionStatement, expression: this.filterChain() }; }, filterChain: function () { for (var a = this.expression(); this.expect("|");)
            a = this.filter(a); return a; }, expression: function () { return this.assignment(); }, assignment: function () {
            var a = this.ternary();
            if (this.expect("=")) {
                if (!Id(a))
                    throw Xa("lval");
                a = { type: r.AssignmentExpression, left: a, right: this.assignment(), operator: "=" };
            }
            return a;
        }, ternary: function () { var a = this.logicalOR(), b, d; return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), { type: r.ConditionalExpression, test: a, alternate: b, consequent: d }) : a; }, logicalOR: function () { for (var a = this.logicalAND(); this.expect("||");)
            a = { type: r.LogicalExpression, operator: "||", left: a, right: this.logicalAND() }; return a; }, logicalAND: function () {
            for (var a = this.equality(); this.expect("&&");)
                a =
                    { type: r.LogicalExpression, operator: "&&", left: a, right: this.equality() };
            return a;
        }, equality: function () { for (var a = this.relational(), b; b = this.expect("==", "!=", "===", "!==");)
            a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.relational() }; return a; }, relational: function () { for (var a = this.additive(), b; b = this.expect("<", ">", "<=", ">=");)
            a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.additive() }; return a; }, additive: function () {
            for (var a = this.multiplicative(), b; b = this.expect("+", "-");)
                a = { type: r.BinaryExpression,
                    operator: b.text, left: a, right: this.multiplicative() };
            return a;
        }, multiplicative: function () { for (var a = this.unary(), b; b = this.expect("*", "/", "%");)
            a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.unary() }; return a; }, unary: function () { var a; return (a = this.expect("+", "-", "!")) ? { type: r.UnaryExpression, operator: a.text, prefix: !0, argument: this.unary() } : this.primary(); }, primary: function () {
            var a;
            this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ?
                a = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? a = na(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? a = { type: r.Literal, value: this.options.literals[this.consume().text] } : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var b; b = this.expect("(", "[", ".");)
                "(" === b.text ? (a = { type: r.CallExpression, callee: a, arguments: this.parseArguments() }, this.consume(")")) :
                    "[" === b.text ? (a = { type: r.MemberExpression, object: a, property: this.expression(), computed: !0 }, this.consume("]")) : "." === b.text ? a = { type: r.MemberExpression, object: a, property: this.identifier(), computed: !1 } : this.throwError("IMPOSSIBLE");
            return a;
        }, filter: function (a) { a = [a]; for (var b = { type: r.CallExpression, callee: this.identifier(), arguments: a, filter: !0 }; this.expect(":");)
            a.push(this.expression()); return b; }, parseArguments: function () {
            var a = [];
            if (")" !== this.peekToken().text) {
                do
                    a.push(this.filterChain());
                while (this.expect(","));
            }
            return a;
        }, identifier: function () { var a = this.consume(); a.identifier || this.throwError("is not a valid identifier", a); return { type: r.Identifier, name: a.text }; }, constant: function () { return { type: r.Literal, value: this.consume().value }; }, arrayDeclaration: function () { var a = []; if ("]" !== this.peekToken().text) {
            do {
                if (this.peek("]"))
                    break;
                a.push(this.expression());
            } while (this.expect(","));
        } this.consume("]"); return { type: r.ArrayExpression, elements: a }; }, object: function () {
            var a = [], b;
            if ("}" !== this.peekToken().text) {
                do {
                    if (this.peek("}"))
                        break;
                    b = { type: r.Property, kind: "init" };
                    this.peek().constant ? (b.key = this.constant(), b.computed = !1, this.consume(":"), b.value = this.expression()) : this.peek().identifier ? (b.key = this.identifier(), b.computed = !1, this.peek(":") ? (this.consume(":"), b.value = this.expression()) : b.value = b.key) : this.peek("[") ? (this.consume("["), b.key = this.expression(), this.consume("]"), b.computed = !0, this.consume(":"), b.value = this.expression()) : this.throwError("invalid key", this.peek());
                    a.push(b);
                } while (this.expect(","));
            }
            this.consume("}");
            return { type: r.ObjectExpression, properties: a };
        }, throwError: function (a, b) { throw Xa("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index)); }, consume: function (a) { if (0 === this.tokens.length)
            throw Xa("ueoe", this.text); var b = this.expect(a); b || this.throwError("is unexpected, expecting [" + a + "]", this.peek()); return b; }, peekToken: function () { if (0 === this.tokens.length)
            throw Xa("ueoe", this.text); return this.tokens[0]; }, peek: function (a, b, d, c) { return this.peekAhead(0, a, b, d, c); }, peekAhead: function (a, b, d, c, e) { if (this.tokens.length > a) {
            a = this.tokens[a];
            var f = a.text;
            if (f === b || f === d || f === c || f === e || !(b || d || c || e))
                return a;
        } return !1; }, expect: function (a, b, d, c) { return (a = this.peek(a, b, d, c)) ? (this.tokens.shift(), a) : !1; }, selfReferential: { "this": { type: r.ThisExpression }, $locals: { type: r.LocalsExpression } } };
    var Gd = 2;
    Kd.prototype = { compile: function (a) {
            var b = this;
            this.state = { nextId: 0, filters: {}, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] };
            U(a, b.$filter);
            var d = "", c;
            this.stage = "assign";
            if (c = Jd(a))
                this.state.computing =
                    "assign", d = this.nextId(), this.recurse(c, d), this.return_(d), d = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            c = Hd(a.body);
            b.stage = "inputs";
            q(c, function (a, c) { var d = "fn" + c; b.state[d] = { vars: [], body: [], own: {} }; b.state.computing = d; var k = b.nextId(); b.recurse(a, k); b.return_(k); b.state.inputs.push({ name: d, isPure: a.isPure }); a.watchId = c; });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(a);
            a = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") +
                d + this.watchFns() + "return fn;";
            a = (new Function("$filter", "getStringValue", "ifDefined", "plus", a))(this.$filter, Eg, Fg, Fd);
            this.state = this.stage = void 0;
            return a;
        }, USE: "use", STRICT: "strict", watchFns: function () { var a = [], b = this.state.inputs, d = this; q(b, function (b) { a.push("var " + b.name + "=" + d.generateFunction(b.name, "s")); b.isPure && a.push(b.name, ".isPure=" + JSON.stringify(b.isPure) + ";"); }); b.length && a.push("fn.inputs=[" + b.map(function (a) { return a.name; }).join(",") + "];"); return a.join(""); }, generateFunction: function (a, b) { return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};"; }, filterPrefix: function () { var a = [], b = this; q(this.state.filters, function (d, c) { a.push(d + "=$filter(" + b.escape(c) + ")"); }); return a.length ? "var " + a.join(",") + ";" : ""; }, varsPrefix: function (a) { return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : ""; }, body: function (a) { return this.state[a].body.join(""); }, recurse: function (a, b, d, c, e, f) {
            var g, k, h = this, l, m, p;
            c = c || D;
            if (!f && u(a.watchId))
                b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0));
            else
                switch (a.type) {
                    case r.Program:
                        q(a.body, function (b, c) { h.recurse(b.expression, void 0, void 0, function (a) { k = a; }); c !== a.body.length - 1 ? h.current().body.push(k, ";") : h.return_(k); });
                        break;
                    case r.Literal:
                        m = this.escape(a.value);
                        this.assign(b, m);
                        c(b || m);
                        break;
                    case r.UnaryExpression:
                        this.recurse(a.argument, void 0, void 0, function (a) { k = a; });
                        m = a.operator + "(" + this.ifDefined(k, 0) + ")";
                        this.assign(b, m);
                        c(m);
                        break;
                    case r.BinaryExpression:
                        this.recurse(a.left, void 0, void 0, function (a) { g = a; });
                        this.recurse(a.right, void 0, void 0, function (a) { k = a; });
                        m = "+" === a.operator ? this.plus(g, k) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(k, 0) : "(" + g + ")" + a.operator + "(" + k + ")";
                        this.assign(b, m);
                        c(m);
                        break;
                    case r.LogicalExpression:
                        b = b || this.nextId();
                        h.recurse(a.left, b);
                        h.if_("&&" === a.operator ? b : h.not(b), h.lazyRecurse(a.right, b));
                        c(b);
                        break;
                    case r.ConditionalExpression:
                        b = b || this.nextId();
                        h.recurse(a.test, b);
                        h.if_(b, h.lazyRecurse(a.alternate, b), h.lazyRecurse(a.consequent, b));
                        c(b);
                        break;
                    case r.Identifier:
                        b = b || this.nextId();
                        d && (d.context = "inputs" === h.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), d.computed = !1, d.name = a.name);
                        h.if_("inputs" === h.stage || h.not(h.getHasOwnProperty("l", a.name)), function () { h.if_("inputs" === h.stage || "s", function () { e && 1 !== e && h.if_(h.isNull(h.nonComputedMember("s", a.name)), h.lazyAssign(h.nonComputedMember("s", a.name), "{}")); h.assign(b, h.nonComputedMember("s", a.name)); }); }, b && h.lazyAssign(b, h.nonComputedMember("l", a.name)));
                        c(b);
                        break;
                    case r.MemberExpression:
                        g = d && (d.context = this.nextId()) || this.nextId();
                        b = b || this.nextId();
                        h.recurse(a.object, g, void 0, function () {
                            h.if_(h.notNull(g), function () {
                                a.computed ? (k = h.nextId(), h.recurse(a.property, k), h.getStringValue(k), e && 1 !== e && h.if_(h.not(h.computedMember(g, k)), h.lazyAssign(h.computedMember(g, k), "{}")), m = h.computedMember(g, k), h.assign(b, m), d && (d.computed = !0, d.name = k)) : (e && 1 !== e && h.if_(h.isNull(h.nonComputedMember(g, a.property.name)), h.lazyAssign(h.nonComputedMember(g, a.property.name), "{}")), m = h.nonComputedMember(g, a.property.name), h.assign(b, m), d && (d.computed = !1, d.name = a.property.name));
                            }, function () { h.assign(b, "undefined"); });
                            c(b);
                        }, !!e);
                        break;
                    case r.CallExpression:
                        b = b || this.nextId();
                        a.filter ? (k = h.filter(a.callee.name), l = [], q(a.arguments, function (a) { var b = h.nextId(); h.recurse(a, b); l.push(b); }), m = k + "(" + l.join(",") + ")", h.assign(b, m), c(b)) : (k = h.nextId(), g = {}, l = [], h.recurse(a.callee, k, g, function () {
                            h.if_(h.notNull(k), function () {
                                q(a.arguments, function (b) {
                                    h.recurse(b, a.constant ?
                                        void 0 : h.nextId(), void 0, function (a) { l.push(a); });
                                });
                                m = g.name ? h.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")" : k + "(" + l.join(",") + ")";
                                h.assign(b, m);
                            }, function () { h.assign(b, "undefined"); });
                            c(b);
                        }));
                        break;
                    case r.AssignmentExpression:
                        k = this.nextId();
                        g = {};
                        this.recurse(a.left, void 0, g, function () { h.if_(h.notNull(g.context), function () { h.recurse(a.right, k); m = h.member(g.context, g.name, g.computed) + a.operator + k; h.assign(b, m); c(b || m); }); }, 1);
                        break;
                    case r.ArrayExpression:
                        l = [];
                        q(a.elements, function (b) {
                            h.recurse(b, a.constant ? void 0 : h.nextId(), void 0, function (a) { l.push(a); });
                        });
                        m = "[" + l.join(",") + "]";
                        this.assign(b, m);
                        c(b || m);
                        break;
                    case r.ObjectExpression:
                        l = [];
                        p = !1;
                        q(a.properties, function (a) { a.computed && (p = !0); });
                        p ? (b = b || this.nextId(), this.assign(b, "{}"), q(a.properties, function (a) { a.computed ? (g = h.nextId(), h.recurse(a.key, g)) : g = a.key.type === r.Identifier ? a.key.name : "" + a.key.value; k = h.nextId(); h.recurse(a.value, k); h.assign(h.member(b, g, a.computed), k); })) : (q(a.properties, function (b) {
                            h.recurse(b.value, a.constant ? void 0 :
                                h.nextId(), void 0, function (a) { l.push(h.escape(b.key.type === r.Identifier ? b.key.name : "" + b.key.value) + ":" + a); });
                        }), m = "{" + l.join(",") + "}", this.assign(b, m));
                        c(b || m);
                        break;
                    case r.ThisExpression:
                        this.assign(b, "s");
                        c(b || "s");
                        break;
                    case r.LocalsExpression:
                        this.assign(b, "l");
                        c(b || "l");
                        break;
                    case r.NGValueParameter: this.assign(b, "v"), c(b || "v");
                }
        }, getHasOwnProperty: function (a, b) { var d = a + "." + b, c = this.current().own; c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")")); return c[d]; }, assign: function (a, b) { if (a)
            return this.current().body.push(a, "=", b, ";"), a; }, filter: function (a) { this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0)); return this.state.filters[a]; }, ifDefined: function (a, b) { return "ifDefined(" + a + "," + this.escape(b) + ")"; }, plus: function (a, b) { return "plus(" + a + "," + b + ")"; }, return_: function (a) { this.current().body.push("return ", a, ";"); }, if_: function (a, b, d) { if (!0 === a)
            b();
        else {
            var c = this.current().body;
            c.push("if(", a, "){");
            b();
            c.push("}");
            d && (c.push("else{"), d(), c.push("}"));
        } },
        not: function (a) { return "!(" + a + ")"; }, isNull: function (a) { return a + "==null"; }, notNull: function (a) { return a + "!=null"; }, nonComputedMember: function (a, b) { var d = /[^$_a-zA-Z0-9]/g; return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b) ? a + "." + b : a + '["' + b.replace(d, this.stringEscapeFn) + '"]'; }, computedMember: function (a, b) { return a + "[" + b + "]"; }, member: function (a, b, d) { return d ? this.computedMember(a, b) : this.nonComputedMember(a, b); }, getStringValue: function (a) { this.assign(a, "getStringValue(" + a + ")"); }, lazyRecurse: function (a, b, d, c, e, f) {
            var g = this;
            return function () { g.recurse(a, b, d, c, e, f); };
        }, lazyAssign: function (a, b) { var d = this; return function () { d.assign(a, b); }; }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4); }, escape: function (a) { if (F(a))
            return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (Y(a))
            return a.toString(); if (!0 === a)
            return "true"; if (!1 === a)
            return "false"; if (null === a)
            return "null"; if ("undefined" === typeof a)
            return "undefined"; throw Xa("esc"); }, nextId: function (a, b) { var d = "v" + this.state.nextId++; a || this.current().vars.push(d + (b ? "=" + b : "")); return d; }, current: function () { return this.state[this.state.computing]; } };
    Ld.prototype = { compile: function (a) {
            var b = this;
            U(a, b.$filter);
            var d, c;
            if (d = Jd(a))
                c = this.recurse(d);
            d = Hd(a.body);
            var e;
            d && (e = [], q(d, function (a, c) { var d = b.recurse(a); d.isPure = a.isPure; a.input = d; e.push(d); a.watchId = c; }));
            var f = [];
            q(a.body, function (a) { f.push(b.recurse(a.expression)); });
            a = 0 === a.body.length ? D : 1 === a.body.length ? f[0] : function (a, b) {
                var c;
                q(f, function (d) {
                    c =
                        d(a, b);
                });
                return c;
            };
            c && (a.assign = function (a, b, d) { return c(a, d, b); });
            e && (a.inputs = e);
            return a;
        }, recurse: function (a, b, d) {
            var c, e, f = this, g;
            if (a.input)
                return this.inputs(a.input, a.watchId);
            switch (a.type) {
                case r.Literal: return this.value(a.value, b);
                case r.UnaryExpression: return e = this.recurse(a.argument), this["unary" + a.operator](e, b);
                case r.BinaryExpression: return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);
                case r.LogicalExpression: return c = this.recurse(a.left), e = this.recurse(a.right),
                    this["binary" + a.operator](c, e, b);
                case r.ConditionalExpression: return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b);
                case r.Identifier: return f.identifier(a.name, b, d);
                case r.MemberExpression: return c = this.recurse(a.object, !1, !!d), a.computed || (e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d) : this.nonComputedMember(c, e, b, d);
                case r.CallExpression: return g = [], q(a.arguments, function (a) { g.push(f.recurse(a)); }),
                    a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), a.filter ? function (a, c, d, f) { for (var p = [], n = 0; n < g.length; ++n)
                    p.push(g[n](a, c, d, f)); a = e.apply(void 0, p, f); return b ? { context: void 0, name: void 0, value: a } : a; } : function (a, c, d, f) { var p = e(a, c, d, f), n; if (null != p.value) {
                    n = [];
                    for (var q = 0; q < g.length; ++q)
                        n.push(g[q](a, c, d, f));
                    n = p.value.apply(p.context, n);
                } return b ? { value: n } : n; };
                case r.AssignmentExpression: return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function (a, d, f, g) {
                    var p = c(a, d, f, g);
                    a = e(a, d, f, g);
                    p.context[p.name] = a;
                    return b ? { value: a } : a;
                };
                case r.ArrayExpression: return g = [], q(a.elements, function (a) { g.push(f.recurse(a)); }), function (a, c, d, e) { for (var f = [], n = 0; n < g.length; ++n)
                    f.push(g[n](a, c, d, e)); return b ? { value: f } : f; };
                case r.ObjectExpression: return g = [], q(a.properties, function (a) { a.computed ? g.push({ key: f.recurse(a.key), computed: !0, value: f.recurse(a.value) }) : g.push({ key: a.key.type === r.Identifier ? a.key.name : "" + a.key.value, computed: !1, value: f.recurse(a.value) }); }), function (a, c, d, e) { for (var f = {}, n = 0; n < g.length; ++n)
                    g[n].computed ? f[g[n].key(a, c, d, e)] = g[n].value(a, c, d, e) : f[g[n].key] = g[n].value(a, c, d, e); return b ? { value: f } : f; };
                case r.ThisExpression: return function (a) { return b ? { value: a } : a; };
                case r.LocalsExpression: return function (a, c) { return b ? { value: c } : c; };
                case r.NGValueParameter: return function (a, c, d) { return b ? { value: d } : d; };
            }
        }, "unary+": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = u(d) ? +d : 0; return b ? { value: d } : d; }; }, "unary-": function (a, b) {
            return function (d, c, e, f) {
                d = a(d, c, e, f);
                d = u(d) ? -d : -0;
                return b ? { value: d } : d;
            };
        }, "unary!": function (a, b) { return function (d, c, e, f) { d = !a(d, c, e, f); return b ? { value: d } : d; }; }, "binary+": function (a, b, d) { return function (c, e, f, g) { var k = a(c, e, f, g); c = b(c, e, f, g); k = Fd(k, c); return d ? { value: k } : k; }; }, "binary-": function (a, b, d) { return function (c, e, f, g) { var k = a(c, e, f, g); c = b(c, e, f, g); k = (u(k) ? k : 0) - (u(c) ? c : 0); return d ? { value: k } : k; }; }, "binary*": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) * b(c, e, f, g); return d ? { value: c } : c; }; }, "binary/": function (a, b, d) {
            return function (c, e, f, g) { c = a(c, e, f, g) / b(c, e, f, g); return d ? { value: c } : c; };
        }, "binary%": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) % b(c, e, f, g); return d ? { value: c } : c; }; }, "binary===": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) === b(c, e, f, g); return d ? { value: c } : c; }; }, "binary!==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) !== b(c, e, f, g); return d ? { value: c } : c; }; }, "binary==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) == b(c, e, f, g); return d ? { value: c } : c; }; }, "binary!=": function (a, b, d) {
            return function (c, e, f, g) { c = a(c, e, f, g) != b(c, e, f, g); return d ? { value: c } : c; };
        }, "binary<": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) < b(c, e, f, g); return d ? { value: c } : c; }; }, "binary>": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) > b(c, e, f, g); return d ? { value: c } : c; }; }, "binary<=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) <= b(c, e, f, g); return d ? { value: c } : c; }; }, "binary>=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) >= b(c, e, f, g); return d ? { value: c } : c; }; }, "binary&&": function (a, b, d) {
            return function (c, e, f, g) {
                c =
                    a(c, e, f, g) && b(c, e, f, g);
                return d ? { value: c } : c;
            };
        }, "binary||": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) || b(c, e, f, g); return d ? { value: c } : c; }; }, "ternary?:": function (a, b, d, c) { return function (e, f, g, k) { e = a(e, f, g, k) ? b(e, f, g, k) : d(e, f, g, k); return c ? { value: e } : e; }; }, value: function (a, b) { return function () { return b ? { context: void 0, name: void 0, value: a } : a; }; }, identifier: function (a, b, d) {
            return function (c, e, f, g) {
                c = e && a in e ? e : c;
                d && 1 !== d && c && null == c[a] && (c[a] = {});
                e = c ? c[a] : void 0;
                return b ? { context: c, name: a, value: e } :
                    e;
            };
        }, computedMember: function (a, b, d, c) { return function (e, f, g, k) { var h = a(e, f, g, k), l, m; null != h && (l = b(e, f, g, k), l += "", c && 1 !== c && h && !h[l] && (h[l] = {}), m = h[l]); return d ? { context: h, name: l, value: m } : m; }; }, nonComputedMember: function (a, b, d, c) { return function (e, f, g, k) { e = a(e, f, g, k); c && 1 !== c && e && null == e[b] && (e[b] = {}); f = null != e ? e[b] : void 0; return d ? { context: e, name: b, value: f } : f; }; }, inputs: function (a, b) { return function (d, c, e, f) { return f ? f[b] : a(d, c, e); }; } };
    Mb.prototype = { constructor: Mb, parse: function (a) {
            a = this.getAst(a);
            var b = this.astCompiler.compile(a.ast), d = a.ast;
            b.literal = 0 === d.body.length || 1 === d.body.length && (d.body[0].expression.type === r.Literal || d.body[0].expression.type === r.ArrayExpression || d.body[0].expression.type === r.ObjectExpression);
            b.constant = a.ast.constant;
            b.oneTime = a.oneTime;
            return b;
        }, getAst: function (a) { var b = !1; a = a.trim(); ":" === a.charAt(0) && ":" === a.charAt(1) && (b = !0, a = a.substring(2)); return { ast: this.ast.ast(a), oneTime: b }; } };
    var wa = M("$sce"), fa = { HTML: "html", CSS: "css", URL: "url", RESOURCE_URL: "resourceUrl", JS: "js" }, Dc = /_([a-z])/g, Jg = M("$compile"), W = y.document.createElement("a"), Qd = ma(y.location.href);
    Rd.$inject = ["$document"];
    gd.$inject = ["$provide"];
    var Yd = 22, Xd = ".", Fc = "0";
    Sd.$inject = ["$locale"];
    Ud.$inject = ["$locale"];
    var Ug = { yyyy: ca("FullYear", 4, 0, !1, !0), yy: ca("FullYear", 2, 0, !0, !0), y: ca("FullYear", 1, 0, !1, !0), MMMM: mb("Month"), MMM: mb("Month", !0), MM: ca("Month", 2, 1), M: ca("Month", 1, 1), LLLL: mb("Month", !1, !0), dd: ca("Date", 2), d: ca("Date", 1), HH: ca("Hours", 2), H: ca("Hours", 1), hh: ca("Hours", 2, -12), h: ca("Hours", 1, -12), mm: ca("Minutes", 2), m: ca("Minutes", 1), ss: ca("Seconds", 2), s: ca("Seconds", 1), sss: ca("Milliseconds", 3), EEEE: mb("Day"), EEE: mb("Day", !0), a: function (a, b) { return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1]; }, Z: function (a, b, d) { a = -1 * d; return a = (0 <= a ? "+" : "") + (Ob(Math[0 < a ? "floor" : "ceil"](a / 60), 2) + Ob(Math.abs(a % 60), 2)); }, ww: $d(2), w: $d(1), G: Gc, GG: Gc, GGG: Gc, GGGG: function (a, b) { return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1]; } }, Tg = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, Sg = /^-?\d+$/;
    Td.$inject = ["$locale"];
    var Ng = ka(N), Og = ka(ub);
    Vd.$inject = ["$parse"];
    var Je = ka({ restrict: "E", compile: function (a, b) { if (!b.href && !b.xlinkHref)
            return function (a, b) { if ("a" === b[0].nodeName.toLowerCase()) {
                var e = "[object SVGAnimatedString]" === ha.call(b.prop("href")) ? "xlink:href" : "href";
                b.on("click", function (a) { b.attr(e) || a.preventDefault(); });
            } }; } }), vb = {};
    q(Gb, function (a, b) {
        function d(a, d, e) { a.$watch(e[c], function (a) { e.$set(b, !!a); }); }
        if ("multiple" !== a) {
            var c = Da("ng-" + b), e = d;
            "checked" === a && (e = function (a, b, e) {
                e.ngModel !==
                    e[c] && d(a, b, e);
            });
            vb[c] = function () { return { restrict: "A", priority: 100, link: e }; };
        }
    });
    q(ud, function (a, b) { vb[b] = function () { return { priority: 100, link: function (a, c, e) { if ("ngPattern" === b && "/" === e.ngPattern.charAt(0) && (c = e.ngPattern.match(Yg))) {
            e.$set("ngPattern", new RegExp(c[1], c[2]));
            return;
        } a.$watch(e[b], function (a) { e.$set(b, a); }); } }; }; });
    q(["src", "srcset", "href"], function (a) {
        var b = Da("ng-" + a);
        vb[b] = function () {
            return { priority: 99, link: function (d, c, e) {
                    var f = a, g = a;
                    "href" === a && "[object SVGAnimatedString]" === ha.call(c.prop("href")) &&
                        (g = "xlinkHref", e.$attr[g] = "xlink:href", f = null);
                    e.$observe(b, function (b) { b ? (e.$set(g, b), Ba && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null); });
                } };
        };
    });
    var Qb = { $addControl: D, $$renameControl: function (a, b) { a.$name = b; }, $removeControl: D, $setValidity: D, $setDirty: D, $setPristine: D, $setSubmitted: D };
    Pb.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
    Pb.prototype = { $rollbackViewValue: function () { q(this.$$controls, function (a) { a.$rollbackViewValue(); }); }, $commitViewValue: function () { q(this.$$controls, function (a) { a.$commitViewValue(); }); },
        $addControl: function (a) { Ha(a.$name, "input"); this.$$controls.push(a); a.$name && (this[a.$name] = a); a.$$parentForm = this; }, $$renameControl: function (a, b) { var d = a.$name; this[d] === a && delete this[d]; this[b] = a; a.$name = b; }, $removeControl: function (a) {
            a.$name && this[a.$name] === a && delete this[a.$name];
            q(this.$pending, function (b, d) { this.$setValidity(d, null, a); }, this);
            q(this.$error, function (b, d) { this.$setValidity(d, null, a); }, this);
            q(this.$$success, function (b, d) { this.$setValidity(d, null, a); }, this);
            cb(this.$$controls, a);
            a.$$parentForm = Qb;
        }, $setDirty: function () { this.$$animate.removeClass(this.$$element, Ya); this.$$animate.addClass(this.$$element, Vb); this.$dirty = !0; this.$pristine = !1; this.$$parentForm.$setDirty(); }, $setPristine: function () { this.$$animate.setClass(this.$$element, Ya, Vb + " ng-submitted"); this.$dirty = !1; this.$pristine = !0; this.$submitted = !1; q(this.$$controls, function (a) { a.$setPristine(); }); }, $setUntouched: function () { q(this.$$controls, function (a) { a.$setUntouched(); }); }, $setSubmitted: function () {
            this.$$animate.addClass(this.$$element, "ng-submitted");
            this.$submitted = !0;
            this.$$parentForm.$setSubmitted();
        } };
    ce({ clazz: Pb, set: function (a, b, d) { var c = a[b]; c ? -1 === c.indexOf(d) && c.push(d) : a[b] = [d]; }, unset: function (a, b, d) { var c = a[b]; c && (cb(c, d), 0 === c.length && delete a[b]); } });
    var ke = function (a) {
        return ["$timeout", "$parse", function (b, d) {
                function c(a) { return "" === a ? d('this[""]').assign : d(a).assign || D; }
                return { name: "form", restrict: a ? "EAC" : "E", require: ["form", "^^?form"], controller: Pb, compile: function (d, f) {
                        d.addClass(Ya).addClass(nb);
                        var g = f.name ? "name" :
                            a && f.ngForm ? "ngForm" : !1;
                        return { pre: function (a, d, e, f) {
                                var p = f[0];
                                if (!("action" in e)) {
                                    var n = function (b) { a.$apply(function () { p.$commitViewValue(); p.$setSubmitted(); }); b.preventDefault(); };
                                    d[0].addEventListener("submit", n);
                                    d.on("$destroy", function () { b(function () { d[0].removeEventListener("submit", n); }, 0, !1); });
                                }
                                (f[1] || p.$$parentForm).$addControl(p);
                                var q = g ? c(p.$name) : D;
                                g && (q(a, p), e.$observe(g, function (b) { p.$name !== b && (q(a, void 0), p.$$parentForm.$$renameControl(p, b), q = c(p.$name), q(a, p)); }));
                                d.on("$destroy", function () {
                                    p.$$parentForm.$removeControl(p);
                                    q(a, void 0);
                                    P(p, Qb);
                                });
                            } };
                    } };
            }];
    }, Ke = ke(), We = ke(!0), Vg = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, gh = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, hh = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, Wg = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, le = /^(\d{4,})-(\d{2})-(\d{2})$/, me = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Nc = /^(\d{4,})-W(\d\d)$/, ne = /^(\d{4,})-(\d\d)$/, oe = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, ee = R();
    q(["date", "datetime-local", "month", "time", "week"], function (a) { ee[a] = !0; });
    var pe = { text: function (a, b, d, c, e, f) { Va(a, b, d, c, e, f); Ic(c); }, date: ob("date", le, Rb(le, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local": ob("datetimelocal", me, Rb(me, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"), time: ob("time", oe, Rb(oe, ["HH", "mm",
            "ss", "sss"]), "HH:mm:ss.sss"), week: ob("week", Nc, function (a, b) { if (da(a))
            return a; if (F(a)) {
            Nc.lastIndex = 0;
            var d = Nc.exec(a);
            if (d) {
                var c = +d[1], e = +d[2], f = d = 0, g = 0, k = 0, h = Zd(c), e = 7 * (e - 1);
                b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), k = b.getMilliseconds());
                return new Date(c, 0, h.getDate() + e, d, f, g, k);
            }
        } return NaN; }, "yyyy-Www"), month: ob("month", ne, Rb(ne, ["yyyy", "MM"]), "yyyy-MM"), number: function (a, b, d, c, e, f) {
            Jc(a, b, d, c);
            fe(c);
            Va(a, b, d, c, e, f);
            var g, k;
            if (u(d.min) || d.ngMin)
                c.$validators.min = function (a) {
                    return c.$isEmpty(a) ||
                        x(g) || a >= g;
                }, d.$observe("min", function (a) { g = Wa(a); c.$validate(); });
            if (u(d.max) || d.ngMax)
                c.$validators.max = function (a) { return c.$isEmpty(a) || x(k) || a <= k; }, d.$observe("max", function (a) { k = Wa(a); c.$validate(); });
            if (u(d.step) || d.ngStep) {
                var h;
                c.$validators.step = function (a, b) { return c.$isEmpty(b) || x(h) || ge(b, g || 0, h); };
                d.$observe("step", function (a) { h = Wa(a); c.$validate(); });
            }
        }, url: function (a, b, d, c, e, f) { Va(a, b, d, c, e, f); Ic(c); c.$$parserName = "url"; c.$validators.url = function (a, b) { var d = a || b; return c.$isEmpty(d) || gh.test(d); }; },
        email: function (a, b, d, c, e, f) { Va(a, b, d, c, e, f); Ic(c); c.$$parserName = "email"; c.$validators.email = function (a, b) { var d = a || b; return c.$isEmpty(d) || hh.test(d); }; }, radio: function (a, b, d, c) { var e = !d.ngTrim || "false" !== Q(d.ngTrim); x(d.name) && b.attr("name", ++qb); b.on("click", function (a) { var g; b[0].checked && (g = d.value, e && (g = Q(g)), c.$setViewValue(g, a && a.type)); }); c.$render = function () { var a = d.value; e && (a = Q(a)); b[0].checked = a === c.$viewValue; }; d.$observe("value", c.$render); }, range: function (a, b, d, c, e, f) {
            function g(a, c) {
                b.attr(a, d[a]);
                d.$observe(a, c);
            }
            function k(a) { p = Wa(a); X(c.$modelValue) || (m ? (a = b.val(), p > a && (a = p, b.val(a)), c.$setViewValue(a)) : c.$validate()); }
            function h(a) { n = Wa(a); X(c.$modelValue) || (m ? (a = b.val(), n < a && (b.val(n), a = n < p ? p : n), c.$setViewValue(a)) : c.$validate()); }
            function l(a) { q = Wa(a); X(c.$modelValue) || (m && c.$viewValue !== b.val() ? c.$setViewValue(b.val()) : c.$validate()); }
            Jc(a, b, d, c);
            fe(c);
            Va(a, b, d, c, e, f);
            var m = c.$$hasNativeValidators && "range" === b[0].type, p = m ? 0 : void 0, n = m ? 100 : void 0, q = m ? 1 : void 0, r = b[0].validity;
            a = u(d.min);
            e = u(d.max);
            f = u(d.step);
            var E = c.$render;
            c.$render = m && u(r.rangeUnderflow) && u(r.rangeOverflow) ? function () { E(); c.$setViewValue(b.val()); } : E;
            a && (c.$validators.min = m ? function () { return !0; } : function (a, b) { return c.$isEmpty(b) || x(p) || b >= p; }, g("min", k));
            e && (c.$validators.max = m ? function () { return !0; } : function (a, b) { return c.$isEmpty(b) || x(n) || b <= n; }, g("max", h));
            f && (c.$validators.step = m ? function () { return !r.stepMismatch; } : function (a, b) { return c.$isEmpty(b) || x(q) || ge(b, p || 0, q); }, g("step", l));
        }, checkbox: function (a, b, d, c, e, f, g, k) { var h = he(k, a, "ngTrueValue", d.ngTrueValue, !0), l = he(k, a, "ngFalseValue", d.ngFalseValue, !1); b.on("click", function (a) { c.$setViewValue(b[0].checked, a && a.type); }); c.$render = function () { b[0].checked = c.$viewValue; }; c.$isEmpty = function (a) { return !1 === a; }; c.$formatters.push(function (a) { return sa(a, h); }); c.$parsers.push(function (a) { return a ? h : l; }); }, hidden: D, button: D, submit: D, reset: D, file: D }, ad = ["$browser", "$sniffer", "$filter", "$parse", function (a, b, d, c) {
            return { restrict: "E", require: ["?ngModel"], link: { pre: function (e, f, g, k) { k[0] && (pe[N(g.type)] || pe.text)(e, f, g, k[0], b, a, d, c); } } };
        }], ih = /^(true|false|\d+)$/, of = function () { function a(a, d, c) { var e = u(c) ? c : 9 === Ba ? "" : null; a.prop("value", e); d.$set("value", c); } return { restrict: "A", priority: 100, compile: function (b, d) { return ih.test(d.ngValue) ? function (b, d, f) { b = b.$eval(f.ngValue); a(d, f, b); } : function (b, d, f) { b.$watch(f.ngValue, function (b) { a(d, f, b); }); }; } }; }, Oe = ["$compile", function (a) {
            return { restrict: "AC", compile: function (b) {
                    a.$$addBindingClass(b);
                    return function (b, c, e) {
                        a.$$addBindingInfo(c, e.ngBind);
                        c = c[0];
                        b.$watch(e.ngBind, function (a) { c.textContent = hc(a); });
                    };
                } };
        }], Qe = ["$interpolate", "$compile", function (a, b) { return { compile: function (d) { b.$$addBindingClass(d); return function (c, d, f) { c = a(d.attr(f.$attr.ngBindTemplate)); b.$$addBindingInfo(d, c.expressions); d = d[0]; f.$observe("ngBindTemplate", function (a) { d.textContent = x(a) ? "" : a; }); }; } }; }], Pe = ["$sce", "$parse", "$compile", function (a, b, d) {
            return { restrict: "A", compile: function (c, e) {
                    var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function (b) { return a.valueOf(b); });
                    d.$$addBindingClass(c);
                    return function (b, c, e) { d.$$addBindingInfo(c, e.ngBindHtml); b.$watch(g, function () { var d = f(b); c.html(a.getTrustedHtml(d) || ""); }); };
                } };
        }], nf = ka({ restrict: "A", require: "ngModel", link: function (a, b, d, c) { c.$viewChangeListeners.push(function () { a.$eval(d.ngChange); }); } }), Re = Lc("", !0), Te = Lc("Odd", 0), Se = Lc("Even", 1), Ue = Ra({ compile: function (a, b) { b.$set("ngCloak", void 0); a.removeClass("ng-cloak"); } }), Ve = [function () { return { restrict: "A", scope: !0, controller: "@", priority: 500 }; }], fd = {}, jh = { blur: !0, focus: !0 };
    q("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (a) { var b = Da("ng-" + a); fd[b] = ["$parse", "$rootScope", function (d, c) { return { restrict: "A", compile: function (e, f) { var g = d(f[b]); return function (b, d) { d.on(a, function (d) { var e = function () { g(b, { $event: d }); }; jh[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e); }); }; } }; }]; });
    var Ye = ["$animate", "$compile", function (a, b) {
            return { multiElement: !0, transclude: "element", priority: 600,
                terminal: !0, restrict: "A", $$tlb: !0, link: function (d, c, e, f, g) { var k, h, l; d.$watch(e.ngIf, function (d) { d ? h || g(function (d, f) { h = f; d[d.length++] = b.$$createComment("end ngIf", e.ngIf); k = { clone: d }; a.enter(d, c.parent(), c); }) : (l && (l.remove(), l = null), h && (h.$destroy(), h = null), k && (l = tb(k.clone), a.leave(l).done(function (a) { !1 !== a && (l = null); }), k = null)); }); } };
        }], Ze = ["$templateRequest", "$anchorScroll", "$animate", function (a, b, d) {
            return { restrict: "ECA", priority: 400, terminal: !0, transclude: "element", controller: ea.noop, compile: function (c, e) {
                    var f = e.ngInclude || e.src, g = e.onload || "", k = e.autoscroll;
                    return function (c, e, m, p, n) {
                        var q = 0, r, E, A, s = function () { E && (E.remove(), E = null); r && (r.$destroy(), r = null); A && (d.leave(A).done(function (a) { !1 !== a && (E = null); }), E = A, A = null); };
                        c.$watch(f, function (f) {
                            var m = function (a) { !1 === a || !u(k) || k && !c.$eval(k) || b(); }, w = ++q;
                            f ? (a(f, !0).then(function (a) { if (!c.$$destroyed && w === q) {
                                var b = c.$new();
                                p.template = a;
                                a = n(b, function (a) { s(); d.enter(a, null, e).done(m); });
                                r = b;
                                A = a;
                                r.$emit("$includeContentLoaded", f);
                                c.$eval(g);
                            } }, function () {
                                c.$$destroyed ||
                                    w !== q || (s(), c.$emit("$includeContentError", f));
                            }), c.$emit("$includeContentRequested", f)) : (s(), p.template = null);
                        });
                    };
                } };
        }], qf = ["$compile", function (a) { return { restrict: "ECA", priority: -400, require: "ngInclude", link: function (b, d, c, e) { ha.call(d[0]).match(/SVG/) ? (d.empty(), a(hd(e.template, y.document).childNodes)(b, function (a) { d.append(a); }, { futureParentElement: d })) : (d.html(e.template), a(d.contents())(b)); } }; }], $e = Ra({ priority: 450, compile: function () { return { pre: function (a, b, d) { a.$eval(d.ngInit); } }; } }), mf = function () {
        return { restrict: "A",
            priority: 100, require: "ngModel", link: function (a, b, d, c) { var e = d.ngList || ", ", f = "false" !== d.ngTrim, g = f ? Q(e) : e; c.$parsers.push(function (a) { if (!x(a)) {
                var b = [];
                a && q(a.split(g), function (a) { a && b.push(f ? Q(a) : a); });
                return b;
            } }); c.$formatters.push(function (a) { if (I(a))
                return a.join(e); }); c.$isEmpty = function (a) { return !a || !a.length; }; } };
    }, nb = "ng-valid", be = "ng-invalid", Ya = "ng-pristine", Vb = "ng-dirty", pb = M("ngModel");
    Sb.$inject = "$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" ");
    Sb.prototype = { $$initGetterSetters: function () { if (this.$options.getOption("getterSetter")) {
            var a = this.$$parse(this.$$attr.ngModel + "()"), b = this.$$parse(this.$$attr.ngModel + "($$$p)");
            this.$$ngModelGet = function (b) { var c = this.$$parsedNgModel(b); C(c) && (c = a(b)); return c; };
            this.$$ngModelSet = function (a, c) { C(this.$$parsedNgModel(a)) ? b(a, { $$$p: c }) : this.$$parsedNgModelAssign(a, c); };
        }
        else if (!this.$$parsedNgModel.assign)
            throw pb("nonassign", this.$$attr.ngModel, za(this.$$element)); }, $render: D, $isEmpty: function (a) {
            return x(a) ||
                "" === a || null === a || a !== a;
        }, $$updateEmptyClasses: function (a) { this.$isEmpty(a) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), this.$$animate.addClass(this.$$element, "ng-not-empty")); }, $setPristine: function () { this.$dirty = !1; this.$pristine = !0; this.$$animate.removeClass(this.$$element, Vb); this.$$animate.addClass(this.$$element, Ya); }, $setDirty: function () {
            this.$dirty = !0;
            this.$pristine = !1;
            this.$$animate.removeClass(this.$$element, Ya);
            this.$$animate.addClass(this.$$element, Vb);
            this.$$parentForm.$setDirty();
        }, $setUntouched: function () { this.$touched = !1; this.$untouched = !0; this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched"); }, $setTouched: function () { this.$touched = !0; this.$untouched = !1; this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched"); }, $rollbackViewValue: function () { this.$$timeout.cancel(this.$$pendingDebounce); this.$viewValue = this.$$lastCommittedViewValue; this.$render(); }, $validate: function () {
            if (!X(this.$modelValue)) {
                var a = this.$$lastCommittedViewValue, b = this.$$rawModelValue, d = this.$valid, c = this.$modelValue, e = this.$options.getOption("allowInvalid"), f = this;
                this.$$runValidators(b, a, function (a) { e || d === a || (f.$modelValue = a ? b : void 0, f.$modelValue !== c && f.$$writeModelToScope()); });
            }
        }, $$runValidators: function (a, b, d) {
            function c() { var c = !0; q(h.$validators, function (d, e) { var g = Boolean(d(a, b)); c = c && g; f(e, g); }); return c ? !0 : (q(h.$asyncValidators, function (a, b) { f(b, null); }), !1); }
            function e() {
                var c = [], d = !0;
                q(h.$asyncValidators, function (e, g) { var h = e(a, b); if (!h || !C(h.then))
                    throw pb("nopromise", h); f(g, void 0); c.push(h.then(function () { f(g, !0); }, function () { d = !1; f(g, !1); })); });
                c.length ? h.$$q.all(c).then(function () { g(d); }, D) : g(!0);
            }
            function f(a, b) { k === h.$$currentValidationRunId && h.$setValidity(a, b); }
            function g(a) { k === h.$$currentValidationRunId && d(a); }
            this.$$currentValidationRunId++;
            var k = this.$$currentValidationRunId, h = this;
            (function () {
                var a = h.$$parserName || "parse";
                if (x(h.$$parserValid))
                    f(a, null);
                else
                    return h.$$parserValid || (q(h.$validators, function (a, b) { f(b, null); }), q(h.$asyncValidators, function (a, b) { f(b, null); })), f(a, h.$$parserValid), h.$$parserValid;
                return !0;
            })() ? c() ? e() : g(!1) : g(!1);
        }, $commitViewValue: function () { var a = this.$viewValue; this.$$timeout.cancel(this.$$pendingDebounce); if (this.$$lastCommittedViewValue !== a || "" === a && this.$$hasNativeValidators)
            this.$$updateEmptyClasses(a), this.$$lastCommittedViewValue = a, this.$pristine && this.$setDirty(), this.$$parseAndValidate(); }, $$parseAndValidate: function () {
            var a = this.$$lastCommittedViewValue, b = this;
            if (this.$$parserValid =
                x(a) ? void 0 : !0)
                for (var d = 0; d < this.$parsers.length; d++)
                    if (a = this.$parsers[d](a), x(a)) {
                        this.$$parserValid = !1;
                        break;
                    }
            X(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
            var c = this.$modelValue, e = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = a;
            e && (this.$modelValue = a, b.$modelValue !== c && b.$$writeModelToScope());
            this.$$runValidators(a, this.$$lastCommittedViewValue, function (d) { e || (b.$modelValue = d ? a : void 0, b.$modelValue !== c && b.$$writeModelToScope()); });
        }, $$writeModelToScope: function () {
            this.$$ngModelSet(this.$$scope, this.$modelValue);
            q(this.$viewChangeListeners, function (a) { try {
                a();
            }
            catch (b) {
                this.$$exceptionHandler(b);
            } }, this);
        }, $setViewValue: function (a, b) { this.$viewValue = a; this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(b); }, $$debounceViewValueCommit: function (a) {
            var b = this.$options.getOption("debounce");
            Y(b[a]) ? b = b[a] : Y(b["default"]) && (b = b["default"]);
            this.$$timeout.cancel(this.$$pendingDebounce);
            var d = this;
            0 < b ? this.$$pendingDebounce = this.$$timeout(function () { d.$commitViewValue(); }, b) : this.$$scope.$root.$$phase ?
                this.$commitViewValue() : this.$$scope.$apply(function () { d.$commitViewValue(); });
        }, $overrideModelOptions: function (a) { this.$options = this.$options.createChild(a); this.$$setUpdateOnEvents(); }, $processModelValue: function () { var a = this.$$format(); this.$viewValue !== a && (this.$$updateEmptyClasses(a), this.$viewValue = this.$$lastCommittedViewValue = a, this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, D)); }, $$format: function () {
            for (var a = this.$formatters, b = a.length, d = this.$modelValue; b--;)
                d = a[b](d);
            return d;
        }, $$setModelValue: function (a) { this.$modelValue = this.$$rawModelValue = a; this.$$parserValid = void 0; this.$processModelValue(); }, $$setUpdateOnEvents: function () { this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler); if (this.$$updateEvents = this.$options.getOption("updateOn"))
            this.$$element.on(this.$$updateEvents, this.$$updateEventHandler); }, $$updateEventHandler: function (a) { this.$$debounceViewValueCommit(a && a.type); } };
    ce({ clazz: Sb, set: function (a, b) { a[b] = !0; }, unset: function (a, b) { delete a[b]; } });
    var lf = ["$rootScope", function (a) {
            return { restrict: "A", require: ["ngModel", "^?form", "^?ngModelOptions"], controller: Sb, priority: 1, compile: function (b) {
                    b.addClass(Ya).addClass("ng-untouched").addClass(nb);
                    return { pre: function (a, b, e, f) { var g = f[0]; b = f[1] || g.$$parentForm; if (f = f[2])
                            g.$options = f.$options; g.$$initGetterSetters(); b.$addControl(g); e.$observe("name", function (a) { g.$name !== a && g.$$parentForm.$$renameControl(g, a); }); a.$on("$destroy", function () { g.$$parentForm.$removeControl(g); }); }, post: function (b, c, e, f) { function g() { k.$setTouched(); } var k = f[0]; k.$$setUpdateOnEvents(); c.on("blur", function () { k.$touched || (a.$$phase ? b.$evalAsync(g) : b.$apply(g)); }); } };
                } };
        }], Tb, kh = /(\s+|^)default(\s+|$)/;
    Mc.prototype = { getOption: function (a) { return this.$$options[a]; }, createChild: function (a) {
            var b = !1;
            a = P({}, a);
            q(a, function (d, c) {
                "$inherit" === d ? "*" === c ? b = !0 : (a[c] = this.$$options[c], "updateOn" === c && (a.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === c && (a.updateOnDefault = !1, a[c] = Q(d.replace(kh, function () {
                    a.updateOnDefault =
                        !0;
                    return " ";
                })));
            }, this);
            b && (delete a["*"], ie(a, this.$$options));
            ie(a, Tb.$$options);
            return new Mc(a);
        } };
    Tb = new Mc({ updateOn: "", updateOnDefault: !0, debounce: 0, getterSetter: !1, allowInvalid: !1, timezone: null });
    var pf = function () {
        function a(a, d) { this.$$attrs = a; this.$$scope = d; }
        a.$inject = ["$attrs", "$scope"];
        a.prototype = { $onInit: function () { var a = this.parentCtrl ? this.parentCtrl.$options : Tb, d = this.$$scope.$eval(this.$$attrs.ngModelOptions); this.$options = a.createChild(d); } };
        return { restrict: "A", priority: 10, require: { parentCtrl: "?^^ngModelOptions" },
            bindToController: !0, controller: a };
    }, af = Ra({ terminal: !0, priority: 1E3 }), lh = M("ngOptions"), mh = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, jf = ["$compile", "$document", "$parse", function (a, b, d) {
            function c(a, b, c) {
                function e(a, b, c, d, f) { this.selectValue = a; this.viewValue = b; this.label = c; this.group = d; this.disabled = f; }
                function f(a) {
                    var b;
                    if (!q && ja(a))
                        b = a;
                    else {
                        b = [];
                        for (var c in a)
                            a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c);
                    }
                    return b;
                }
                var p = a.match(mh);
                if (!p)
                    throw lh("iexp", a, za(b));
                var n = p[5] || p[7], q = p[6];
                a = / as /.test(p[0]) && p[1];
                var r = p[9];
                b = d(p[2] ? p[1] : n);
                var E = a && d(a) || b, A = r && d(r), s = r ? function (a, b) { return A(c, b); } : function (a) { return Na(a); }, u = function (a, b) { return s(a, t(a, b)); }, z = d(p[2] || p[1]), w = d(p[3] || ""), H = d(p[4] || ""), y = d(p[8]), x = {}, t = q ? function (a, b) { x[q] = b; x[n] = a; return x; } : function (a) { x[n] = a; return x; };
                return { trackBy: r, getTrackByValue: u,
                    getWatchables: d(y, function (a) { var b = []; a = a || []; for (var d = f(a), e = d.length, g = 0; g < e; g++) {
                        var k = a === d ? g : d[g], l = a[k], k = t(l, k), l = s(l, k);
                        b.push(l);
                        if (p[2] || p[1])
                            l = z(c, k), b.push(l);
                        p[4] && (k = H(c, k), b.push(k));
                    } return b; }), getOptions: function () {
                        for (var a = [], b = {}, d = y(c) || [], g = f(d), k = g.length, n = 0; n < k; n++) {
                            var p = d === g ? n : g[n], q = t(d[p], p), B = E(c, q), p = s(B, q), A = z(c, q), x = w(c, q), q = H(c, q), B = new e(p, B, A, x, q);
                            a.push(B);
                            b[p] = B;
                        }
                        return { items: a, selectValueMap: b, getOptionFromViewValue: function (a) { return b[u(a)]; }, getViewValueFromOption: function (a) {
                                return r ?
                                    na(a.viewValue) : a.viewValue;
                            } };
                    } };
            }
            var e = y.document.createElement("option"), f = y.document.createElement("optgroup");
            return { restrict: "A", terminal: !0, require: ["select", "ngModel"], link: { pre: function (a, b, c, d) { d[0].registerOption = D; }, post: function (d, k, h, l) {
                        function m(a) { var b = (a = s.getOptionFromViewValue(a)) && a.element; b && !b.selected && (b.selected = !0); return a; }
                        function p(a, b) { a.element = b; b.disabled = a.disabled; a.label !== b.label && (b.label = a.label, b.textContent = a.label); b.value = a.selectValue; }
                        var n = l[0], r = l[1], v = h.multiple;
                        l = 0;
                        for (var E = k.children(), A = E.length; l < A; l++)
                            if ("" === E[l].value) {
                                n.hasEmptyOption = !0;
                                n.emptyOption = E.eq(l);
                                break;
                            }
                        k.empty();
                        l = !!n.emptyOption;
                        z(e.cloneNode(!1)).val("?");
                        var s, x = c(h.ngOptions, k, d), y = b[0].createDocumentFragment();
                        n.generateUnknownOptionValue = function (a) { return "?"; };
                        v ? (n.writeValue = function (a) { if (s) {
                            var b = a && a.map(m) || [];
                            s.items.forEach(function (a) { a.element.selected && -1 === Array.prototype.indexOf.call(b, a) && (a.element.selected = !1); });
                        } }, n.readValue = function () {
                            var a = k.val() ||
                                [], b = [];
                            q(a, function (a) { (a = s.selectValueMap[a]) && !a.disabled && b.push(s.getViewValueFromOption(a)); });
                            return b;
                        }, x.trackBy && d.$watchCollection(function () { if (I(r.$viewValue))
                            return r.$viewValue.map(function (a) { return x.getTrackByValue(a); }); }, function () { r.$render(); })) : (n.writeValue = function (a) {
                            if (s) {
                                var b = k[0].options[k[0].selectedIndex], c = s.getOptionFromViewValue(a);
                                b && b.removeAttribute("selected");
                                c ? (k[0].value !== c.selectValue && (n.removeUnknownOption(), k[0].value = c.selectValue, c.element.selected = !0),
                                    c.element.setAttribute("selected", "selected")) : n.selectUnknownOrEmptyOption(a);
                            }
                        }, n.readValue = function () { var a = s.selectValueMap[k.val()]; return a && !a.disabled ? (n.unselectEmptyOption(), n.removeUnknownOption(), s.getViewValueFromOption(a)) : null; }, x.trackBy && d.$watch(function () { return x.getTrackByValue(r.$viewValue); }, function () { r.$render(); }));
                        l && (a(n.emptyOption)(d), k.prepend(n.emptyOption), 8 === n.emptyOption[0].nodeType ? (n.hasEmptyOption = !1, n.registerOption = function (a, b) {
                            "" === b.val() && (n.hasEmptyOption =
                                !0, n.emptyOption = b, n.emptyOption.removeClass("ng-scope"), r.$render(), b.on("$destroy", function () { var a = n.$isEmptyOptionSelected(); n.hasEmptyOption = !1; n.emptyOption = void 0; a && r.$render(); }));
                        }) : n.emptyOption.removeClass("ng-scope"));
                        d.$watchCollection(x.getWatchables, function () {
                            var a = s && n.readValue();
                            if (s)
                                for (var b = s.items.length - 1; 0 <= b; b--) {
                                    var c = s.items[b];
                                    u(c.group) ? Fb(c.element.parentNode) : Fb(c.element);
                                }
                            s = x.getOptions();
                            var d = {};
                            s.items.forEach(function (a) {
                                var b;
                                if (u(a.group)) {
                                    b = d[a.group];
                                    b || (b =
                                        f.cloneNode(!1), y.appendChild(b), b.label = null === a.group ? "null" : a.group, d[a.group] = b);
                                    var c = e.cloneNode(!1);
                                    b.appendChild(c);
                                    p(a, c);
                                }
                                else
                                    b = e.cloneNode(!1), y.appendChild(b), p(a, b);
                            });
                            k[0].appendChild(y);
                            r.$render();
                            r.$isEmpty(a) || (b = n.readValue(), (x.trackBy || v ? sa(a, b) : a === b) || (r.$setViewValue(b), r.$render()));
                        });
                    } } };
        }], bf = ["$locale", "$interpolate", "$log", function (a, b, d) {
            var c = /{}/g, e = /^when(Minus)?(.+)$/;
            return { link: function (f, g, k) {
                    function h(a) { g.text(a || ""); }
                    var l = k.count, m = k.$attr.when && g.attr(k.$attr.when), p = k.offset || 0, n = f.$eval(m) || {}, r = {}, v = b.startSymbol(), E = b.endSymbol(), A = v + l + "-" + p + E, s = ea.noop, u;
                    q(k, function (a, b) { var c = e.exec(b); c && (c = (c[1] ? "-" : "") + N(c[2]), n[c] = g.attr(k.$attr[b])); });
                    q(n, function (a, d) { r[d] = b(a.replace(c, A)); });
                    f.$watch(l, function (b) { var c = parseFloat(b), e = X(c); e || c in n || (c = a.pluralCat(c - p)); c === u || e && X(u) || (s(), e = r[c], x(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), s = D, h()) : s = f.$watch(e, h), u = c); });
                } };
        }], cf = ["$parse", "$animate", "$compile", function (a, b, d) {
            var c = M("ngRepeat"), e = function (a, b, c, d, e, m, p) { a[c] = d; e && (a[e] = m); a.$index = b; a.$first = 0 === b; a.$last = b === p - 1; a.$middle = !(a.$first || a.$last); a.$odd = !(a.$even = 0 === (b & 1)); };
            return { restrict: "A", multiElement: !0, transclude: "element", priority: 1E3, terminal: !0, $$tlb: !0, compile: function (f, g) {
                    var k = g.ngRepeat, h = d.$$createComment("end ngRepeat", k), l = k.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                    if (!l)
                        throw c("iexp", k);
                    var m = l[1], p = l[2], n = l[3], r = l[4], l = m.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                    if (!l)
                        throw c("iidexp", m);
                    var v = l[3] || l[1], u = l[2];
                    if (n && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(n) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(n)))
                        throw c("badident", n);
                    var A, s, x, z, w = { $id: Na };
                    r ? A = a(r) : (x = function (a, b) { return Na(b); }, z = function (a) { return a; });
                    return function (a, d, f, g, l) {
                        A && (s = function (b, c, d) { u && (w[u] = b); w[v] = c; w.$index = d; return A(a, w); });
                        var m = R();
                        a.$watchCollection(p, function (f) {
                            var g, p, r = d[0], t, A = R(), w, B, y, C, F, D, G;
                            n && (a[n] = f);
                            if (ja(f))
                                F =
                                    f, p = s || x;
                            else
                                for (G in p = s || z, F = [], f)
                                    ra.call(f, G) && "$" !== G.charAt(0) && F.push(G);
                            w = F.length;
                            G = Array(w);
                            for (g = 0; g < w; g++)
                                if (B = f === F ? g : F[g], y = f[B], C = p(B, y, g), m[C])
                                    D = m[C], delete m[C], A[C] = D, G[g] = D;
                                else {
                                    if (A[C])
                                        throw q(G, function (a) { a && a.scope && (m[a.id] = a); }), c("dupes", k, C, y);
                                    G[g] = { id: C, scope: void 0, clone: void 0 };
                                    A[C] = !0;
                                }
                            for (t in m) {
                                D = m[t];
                                C = tb(D.clone);
                                b.leave(C);
                                if (C[0].parentNode)
                                    for (g = 0, p = C.length; g < p; g++)
                                        C[g].$$NG_REMOVED = !0;
                                D.scope.$destroy();
                            }
                            for (g = 0; g < w; g++)
                                if (B = f === F ? g : F[g], y = f[B], D = G[g], D.scope) {
                                    t =
                                        r;
                                    do
                                        t = t.nextSibling;
                                    while (t && t.$$NG_REMOVED);
                                    D.clone[0] !== t && b.move(tb(D.clone), null, r);
                                    r = D.clone[D.clone.length - 1];
                                    e(D.scope, g, v, y, u, B, w);
                                }
                                else
                                    l(function (a, c) { D.scope = c; var d = h.cloneNode(!1); a[a.length++] = d; b.enter(a, null, r); r = d; D.clone = a; A[D.id] = D; e(D.scope, g, v, y, u, B, w); });
                            m = A;
                        });
                    };
                } };
        }], df = ["$animate", function (a) { return { restrict: "A", multiElement: !0, link: function (b, d, c) { b.$watch(c.ngShow, function (b) { a[b ? "removeClass" : "addClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }); }); } }; }], Xe = ["$animate", function (a) {
            return { restrict: "A",
                multiElement: !0, link: function (b, d, c) { b.$watch(c.ngHide, function (b) { a[b ? "addClass" : "removeClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }); }); } };
        }], ef = Ra(function (a, b, d) { a.$watch(d.ngStyle, function (a, d) { d && a !== d && q(d, function (a, c) { b.css(c, ""); }); a && b.css(a); }, !0); }), ff = ["$animate", "$compile", function (a, b) {
            return { require: "ngSwitch", controller: ["$scope", function () { this.cases = {}; }], link: function (d, c, e, f) {
                    var g = [], k = [], h = [], l = [], m = function (a, b) { return function (c) { !1 !== c && a.splice(b, 1); }; };
                    d.$watch(e.ngSwitch ||
                        e.on, function (c) { for (var d, e; h.length;)
                        a.cancel(h.pop()); d = 0; for (e = l.length; d < e; ++d) {
                        var r = tb(k[d].clone);
                        l[d].$destroy();
                        (h[d] = a.leave(r)).done(m(h, d));
                    } k.length = 0; l.length = 0; (g = f.cases["!" + c] || f.cases["?"]) && q(g, function (c) { c.transclude(function (d, e) { l.push(e); var f = c.element; d[d.length++] = b.$$createComment("end ngSwitchWhen"); k.push({ clone: d }); a.enter(d, f.parent(), f); }); }); });
                } };
        }], gf = Ra({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) {
            a = d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function (a, b, c) { return c[b - 1] !== a; });
            q(a, function (a) { c.cases["!" + a] = c.cases["!" + a] || []; c.cases["!" + a].push({ transclude: e, element: b }); });
        } }), hf = Ra({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) { c.cases["?"] = c.cases["?"] || []; c.cases["?"].push({ transclude: e, element: b }); } }), nh = M("ngTransclude"), kf = ["$compile", function (a) {
            return { restrict: "EAC", compile: function (b) {
                    var d = a(b.contents());
                    b.empty();
                    return function (a, b, f, g, k) {
                        function h() { d(a, function (a) { b.append(a); }); }
                        if (!k)
                            throw nh("orphan", za(b));
                        f.ngTransclude === f.$attr.ngTransclude && (f.ngTransclude = "");
                        f = f.ngTransclude || f.ngTranscludeSlot;
                        k(function (a, c) { var d; if (d = a.length)
                            a: {
                                d = 0;
                                for (var f = a.length; d < f; d++) {
                                    var g = a[d];
                                    if (g.nodeType !== Ma || g.nodeValue.trim()) {
                                        d = !0;
                                        break a;
                                    }
                                }
                                d = void 0;
                            } d ? b.append(a) : (h(), c.$destroy()); }, null, f);
                        f && !k.isSlotFilled(f) && h();
                    };
                } };
        }], Le = ["$templateCache", function (a) { return { restrict: "E", terminal: !0, compile: function (b, d) { "text/ng-template" === d.type && a.put(d.id, b[0].text); } }; }], oh = { $setViewValue: D, $render: D }, ph = ["$element",
        "$scope", function (a, b) {
            function d() { g || (g = !0, b.$$postDigest(function () { g = !1; e.ngModelCtrl.$render(); })); }
            function c(a) { k || (k = !0, b.$$postDigest(function () { b.$$destroyed || (k = !1, e.ngModelCtrl.$setViewValue(e.readValue()), a && e.ngModelCtrl.$render()); })); }
            var e = this, f = new Hb;
            e.selectValueMap = {};
            e.ngModelCtrl = oh;
            e.multiple = !1;
            e.unknownOption = z(y.document.createElement("option"));
            e.hasEmptyOption = !1;
            e.emptyOption = void 0;
            e.renderUnknownOption = function (b) {
                b = e.generateUnknownOptionValue(b);
                e.unknownOption.val(b);
                a.prepend(e.unknownOption);
                Fa(e.unknownOption, !0);
                a.val(b);
            };
            e.updateUnknownOption = function (b) { b = e.generateUnknownOptionValue(b); e.unknownOption.val(b); Fa(e.unknownOption, !0); a.val(b); };
            e.generateUnknownOptionValue = function (a) { return "? " + Na(a) + " ?"; };
            e.removeUnknownOption = function () { e.unknownOption.parent() && e.unknownOption.remove(); };
            e.selectEmptyOption = function () { e.emptyOption && (a.val(""), Fa(e.emptyOption, !0)); };
            e.unselectEmptyOption = function () { e.hasEmptyOption && Fa(e.emptyOption, !1); };
            b.$on("$destroy", function () { e.renderUnknownOption = D; });
            e.readValue = function () { var b = a.val(), b = b in e.selectValueMap ? e.selectValueMap[b] : b; return e.hasOption(b) ? b : null; };
            e.writeValue = function (b) { var c = a[0].options[a[0].selectedIndex]; c && Fa(z(c), !1); e.hasOption(b) ? (e.removeUnknownOption(), c = Na(b), a.val(c in e.selectValueMap ? c : b), Fa(z(a[0].options[a[0].selectedIndex]), !0)) : e.selectUnknownOrEmptyOption(b); };
            e.addOption = function (a, b) {
                if (8 !== b[0].nodeType) {
                    Ha(a, '"option value"');
                    "" === a && (e.hasEmptyOption = !0, e.emptyOption =
                        b);
                    var c = f.get(a) || 0;
                    f.set(a, c + 1);
                    d();
                }
            };
            e.removeOption = function (a) { var b = f.get(a); b && (1 === b ? (f.delete(a), "" === a && (e.hasEmptyOption = !1, e.emptyOption = void 0)) : f.set(a, b - 1)); };
            e.hasOption = function (a) { return !!f.get(a); };
            e.$hasEmptyOption = function () { return e.hasEmptyOption; };
            e.$isUnknownOptionSelected = function () { return a[0].options[0] === e.unknownOption[0]; };
            e.$isEmptyOptionSelected = function () { return e.hasEmptyOption && a[0].options[a[0].selectedIndex] === e.emptyOption[0]; };
            e.selectUnknownOrEmptyOption = function (a) {
                null ==
                    a && e.emptyOption ? (e.removeUnknownOption(), e.selectEmptyOption()) : e.unknownOption.parent().length ? e.updateUnknownOption(a) : e.renderUnknownOption(a);
            };
            var g = !1, k = !1;
            e.registerOption = function (a, b, f, g, k) {
                if (f.$attr.ngValue) {
                    var q, r = NaN;
                    f.$observe("value", function (a) { var d, f = b.prop("selected"); u(r) && (e.removeOption(q), delete e.selectValueMap[r], d = !0); r = Na(a); q = a; e.selectValueMap[r] = a; e.addOption(a, b); b.attr("value", r); d && f && c(); });
                }
                else
                    g ? f.$observe("value", function (a) {
                        e.readValue();
                        var d, f = b.prop("selected");
                        u(q) && (e.removeOption(q), d = !0);
                        q = a;
                        e.addOption(a, b);
                        d && f && c();
                    }) : k ? a.$watch(k, function (a, d) { f.$set("value", a); var g = b.prop("selected"); d !== a && e.removeOption(d); e.addOption(a, b); d && g && c(); }) : e.addOption(f.value, b);
                f.$observe("disabled", function (a) { if ("true" === a || a && b.prop("selected"))
                    e.multiple ? c(!0) : (e.ngModelCtrl.$setViewValue(null), e.ngModelCtrl.$render()); });
                b.on("$destroy", function () { var a = e.readValue(), b = f.value; e.removeOption(b); d(); (e.multiple && a && -1 !== a.indexOf(b) || a === b) && c(!0); });
            };
        }], Me = function () {
        return { restrict: "E",
            require: ["select", "?ngModel"], controller: ph, priority: 1, link: { pre: function (a, b, d, c) {
                    var e = c[0], f = c[1];
                    if (f) {
                        if (e.ngModelCtrl = f, b.on("change", function () { e.removeUnknownOption(); a.$apply(function () { f.$setViewValue(e.readValue()); }); }), d.multiple) {
                            e.multiple = !0;
                            e.readValue = function () { var a = []; q(b.find("option"), function (b) { b.selected && !b.disabled && (b = b.value, a.push(b in e.selectValueMap ? e.selectValueMap[b] : b)); }); return a; };
                            e.writeValue = function (a) {
                                q(b.find("option"), function (b) {
                                    var c = !!a && (-1 !== Array.prototype.indexOf.call(a, b.value) || -1 !== Array.prototype.indexOf.call(a, e.selectValueMap[b.value]));
                                    c !== b.selected && Fa(z(b), c);
                                });
                            };
                            var g, k = NaN;
                            a.$watch(function () { k !== f.$viewValue || sa(g, f.$viewValue) || (g = pa(f.$viewValue), f.$render()); k = f.$viewValue; });
                            f.$isEmpty = function (a) { return !a || 0 === a.length; };
                        }
                    }
                    else
                        e.registerOption = D;
                }, post: function (a, b, d, c) { var e = c[1]; if (e) {
                    var f = c[0];
                    e.$render = function () { f.writeValue(e.$viewValue); };
                } } } };
    }, Ne = ["$interpolate", function (a) {
            return { restrict: "E", priority: 100, compile: function (b, d) {
                    var c, e;
                    u(d.ngValue) ||
                        (u(d.value) ? c = a(d.value, !0) : (e = a(b.text(), !0)) || d.$set("value", b.text()));
                    return function (a, b, d) { var h = b.parent(); (h = h.data("$selectController") || h.parent().data("$selectController")) && h.registerOption(a, b, d, c, e); };
                } };
        }], cd = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { c && (d.required = !0, c.$validators.required = function (a, b) { return !d.required || !c.$isEmpty(b); }, d.$observe("required", function () { c.$validate(); })); } }; }, bd = function () {
        return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) {
                var e, f = d.ngPattern || d.pattern;
                d.$observe("pattern", function (a) { F(a) && 0 < a.length && (a = new RegExp("^" + a + "$")); if (a && !a.test)
                    throw M("ngPattern")("noregexp", f, a, za(b)); e = a || void 0; c.$validate(); });
                c.$validators.pattern = function (a, b) { return c.$isEmpty(b) || x(e) || e.test(b); };
            } } };
    }, ed = function () {
        return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) {
                if (c) {
                    var e = -1;
                    d.$observe("maxlength", function (a) { a = Z(a); e = X(a) ? -1 : a; c.$validate(); });
                    c.$validators.maxlength = function (a, b) {
                        return 0 > e || c.$isEmpty(b) ||
                            b.length <= e;
                    };
                }
            } };
    }, dd = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) {
            var e = 0;
            d.$observe("minlength", function (a) { e = Z(a) || 0; c.$validate(); });
            c.$validators.minlength = function (a, b) { return c.$isEmpty(b) || b.length >= e; };
        } } }; };
    y.angular.bootstrap ? y.console && console.log("WARNING: Tried to load AngularJS more than once.") : (De(), Ge(ea), ea.module("ngLocale", [], ["$provide", function (a) {
            function b(a) { a += ""; var b = a.indexOf("."); return -1 == b ? 0 : a.length - b - 1; }
            a.value("$locale", { DATETIME_FORMATS: { AMPMS: ["AM",
                        "PM"], DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), ERANAMES: ["Before Christ", "Anno Domini"], ERAS: ["BC", "AD"], FIRSTDAYOFWEEK: 6, MONTH: "January February March April May June July August September October November December".split(" "), SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "), SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), STANDALONEMONTH: "January February March April May June July August September October November December".split(" "), WEEKENDRANGE: [5,
                        6], fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", medium: "MMM d, y h:mm:ss a", mediumDate: "MMM d, y", mediumTime: "h:mm:ss a", "short": "M/d/yy h:mm a", shortDate: "M/d/yy", shortTime: "h:mm a" }, NUMBER_FORMATS: { CURRENCY_SYM: "$", DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{ gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: "" }, { gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: "-\u00a4", negSuf: "", posPre: "\u00a4", posSuf: "" }] }, id: "en-us", localeID: "en_US", pluralCat: function (a, c) { var e = a | 0, f = c; void 0 === f && (f = Math.min(b(a), 3)); Math.pow(10, f); return 1 == e && 0 == f ? "one" : "other"; } });
        }]), z(function () { ye(y.document, Wc); }));
})(window);
!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
angular.module("ngLocale", [], ["$provide", function ($provide) {
        var PLURAL_CATEGORY = { ZERO: "zero", ONE: "one", TWO: "two", FEW: "few", MANY: "many", OTHER: "other" };
        $provide.value("$locale", {
            "DATETIME_FORMATS": {
                "AMPMS": [
                    "AM",
                    "PM"
                ],
                "DAY": [
                    "dimanche",
                    "lundi",
                    "mardi",
                    "mercredi",
                    "jeudi",
                    "vendredi",
                    "samedi"
                ],
                "ERANAMES": [
                    "avant J\u00e9sus-Christ",
                    "apr\u00e8s J\u00e9sus-Christ"
                ],
                "ERAS": [
                    "av. J.-C.",
                    "ap. J.-C."
                ],
                "FIRSTDAYOFWEEK": 0,
                "MONTH": [
                    "janvier",
                    "f\u00e9vrier",
                    "mars",
                    "avril",
                    "mai",
                    "juin",
                    "juillet",
                    "ao\u00fbt",
                    "septembre",
                    "octobre",
                    "novembre",
                    "d\u00e9cembre"
                ],
                "SHORTDAY": [
                    "dim.",
                    "lun.",
                    "mar.",
                    "mer.",
                    "jeu.",
                    "ven.",
                    "sam."
                ],
                "SHORTMONTH": [
                    "janv.",
                    "f\u00e9vr.",
                    "mars",
                    "avr.",
                    "mai",
                    "juin",
                    "juil.",
                    "ao\u00fbt",
                    "sept.",
                    "oct.",
                    "nov.",
                    "d\u00e9c."
                ],
                "STANDALONEMONTH": [
                    "janvier",
                    "f\u00e9vrier",
                    "mars",
                    "avril",
                    "mai",
                    "juin",
                    "juillet",
                    "ao\u00fbt",
                    "septembre",
                    "octobre",
                    "novembre",
                    "d\u00e9cembre"
                ],
                "WEEKENDRANGE": [
                    5,
                    6
                ],
                "fullDate": "EEEE d MMMM y",
                "longDate": "d MMMM y",
                "medium": "d MMM y HH:mm:ss",
                "mediumDate": "d MMM y",
                "mediumTime": "HH:mm:ss",
                "short": "dd/MM/y HH:mm",
                "shortDate": "dd/MM/y",
                "shortTime": "HH:mm"
            },
            "NUMBER_FORMATS": {
                "CURRENCY_SYM": "\u20ac",
                "DECIMAL_SEP": ",",
                "GROUP_SEP": "\u00a0",
                "PATTERNS": [
                    {
                        "gSize": 3,
                        "lgSize": 3,
                        "maxFrac": 3,
                        "minFrac": 0,
                        "minInt": 1,
                        "negPre": "-",
                        "negSuf": "",
                        "posPre": "",
                        "posSuf": ""
                    },
                    {
                        "gSize": 3,
                        "lgSize": 3,
                        "maxFrac": 2,
                        "minFrac": 2,
                        "minInt": 1,
                        "negPre": "-",
                        "negSuf": "\u00a0\u00a4",
                        "posPre": "",
                        "posSuf": "\u00a0\u00a4"
                    }
                ]
            },
            "id": "fr-fr",
            "localeID": "fr_FR",
            "pluralCat": function (n, opt_precision) { var i = n | 0; if (i == 0 || i == 1) {
                return PLURAL_CATEGORY.ONE;
            } return PLURAL_CATEGORY.OTHER; }
        });
    }]);
angular.module("ui.bootstrap", ["ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module('ui.bootstrap.collapse', [])
    .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function ($animate, $q, $parse, $injector) {
        var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
        return {
            link: function (scope, element, attrs) {
                var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed), horizontal = false, css = {}, cssTo = {};
                init();
                function init() {
                    horizontal = !!('horizontal' in attrs);
                    if (horizontal) {
                        css = {
                            width: ''
                        };
                        cssTo = { width: '0' };
                    }
                    else {
                        css = {
                            height: ''
                        };
                        cssTo = { height: '0' };
                    }
                    if (!scope.$eval(attrs.uibCollapse)) {
                        element.addClass('in')
                            .addClass('collapse')
                            .attr('aria-expanded', true)
                            .attr('aria-hidden', false)
                            .css(css);
                    }
                }
                function getScrollFromElement(element) {
                    if (horizontal) {
                        return { width: element.scrollWidth + 'px' };
                    }
                    return { height: element.scrollHeight + 'px' };
                }
                function expand() {
                    if (element.hasClass('collapse') && element.hasClass('in')) {
                        return;
                    }
                    $q.resolve(expandingExpr(scope))
                        .then(function () {
                        element.removeClass('collapse')
                            .addClass('collapsing')
                            .attr('aria-expanded', true)
                            .attr('aria-hidden', false);
                        if ($animateCss) {
                            $animateCss(element, {
                                addClass: 'in',
                                easing: 'ease',
                                css: {
                                    overflow: 'hidden'
                                },
                                to: getScrollFromElement(element[0])
                            }).start()['finally'](expandDone);
                        }
                        else {
                            $animate.addClass(element, 'in', {
                                css: {
                                    overflow: 'hidden'
                                },
                                to: getScrollFromElement(element[0])
                            }).then(expandDone);
                        }
                    }, angular.noop);
                }
                function expandDone() {
                    element.removeClass('collapsing')
                        .addClass('collapse')
                        .css(css);
                    expandedExpr(scope);
                }
                function collapse() {
                    if (!element.hasClass('collapse') && !element.hasClass('in')) {
                        return collapseDone();
                    }
                    $q.resolve(collapsingExpr(scope))
                        .then(function () {
                        element
                            .css(getScrollFromElement(element[0]))
                            .removeClass('collapse')
                            .addClass('collapsing')
                            .attr('aria-expanded', false)
                            .attr('aria-hidden', true);
                        if ($animateCss) {
                            $animateCss(element, {
                                removeClass: 'in',
                                to: cssTo
                            }).start()['finally'](collapseDone);
                        }
                        else {
                            $animate.removeClass(element, 'in', {
                                to: cssTo
                            }).then(collapseDone);
                        }
                    }, angular.noop);
                }
                function collapseDone() {
                    element.css(cssTo);
                    element.removeClass('collapsing')
                        .addClass('collapse');
                    collapsedExpr(scope);
                }
                scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
                    if (shouldCollapse) {
                        collapse();
                    }
                    else {
                        expand();
                    }
                });
            }
        };
    }]);
angular.module('ui.bootstrap.tabindex', [])
    .directive('uibTabindexToggle', function () {
    return {
        restrict: 'A',
        link: function (scope, elem, attrs) {
            attrs.$observe('disabled', function (disabled) {
                attrs.$set('tabindex', disabled ? -1 : null);
            });
        }
    };
});
angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])
    .constant('uibAccordionConfig', {
    closeOthers: true
})
    .controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
        this.groups = [];
        this.closeOthers = function (openGroup) {
            var closeOthers = angular.isDefined($attrs.closeOthers) ?
                $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
            if (closeOthers) {
                angular.forEach(this.groups, function (group) {
                    if (group !== openGroup) {
                        group.isOpen = false;
                    }
                });
            }
        };
        this.addGroup = function (groupScope) {
            var that = this;
            this.groups.push(groupScope);
            groupScope.$on('$destroy', function (event) {
                that.removeGroup(groupScope);
            });
        };
        this.removeGroup = function (group) {
            var index = this.groups.indexOf(group);
            if (index !== -1) {
                this.groups.splice(index, 1);
            }
        };
    }])
    .directive('uibAccordion', function () {
    return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
    };
})
    .directive('uibAccordionGroup', function () {
    return {
        require: '^uibAccordion',
        transclude: true,
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
            heading: '@',
            panelClass: '@?',
            isOpen: '=?',
            isDisabled: '=?'
        },
        controller: function () {
            this.setHeading = function (element) {
                this.heading = element;
            };
        },
        link: function (scope, element, attrs, accordionCtrl) {
            element.addClass('panel');
            accordionCtrl.addGroup(scope);
            scope.openClass = attrs.openClass || 'panel-open';
            scope.panelClass = attrs.panelClass || 'panel-default';
            scope.$watch('isOpen', function (value) {
                element.toggleClass(scope.openClass, !!value);
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
            });
            scope.toggleOpen = function ($event) {
                if (!scope.isDisabled) {
                    if (!$event || $event.which === 32) {
                        scope.isOpen = !scope.isOpen;
                    }
                }
            };
            var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
            scope.headingId = id + '-tab';
            scope.panelId = id + '-panel';
        }
    };
})
    .directive('uibAccordionHeading', function () {
    return {
        transclude: true,
        template: '',
        replace: true,
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
})
    .directive('uibAccordionTransclude', function () {
    return {
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, controller) {
            scope.$watch(function () { return controller[attrs.uibAccordionTransclude]; }, function (heading) {
                if (heading) {
                    var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                    elem.html('');
                    elem.append(heading);
                }
            });
        }
    };
    function getHeaderSelectors() {
        return 'uib-accordion-header,' +
            'data-uib-accordion-header,' +
            'x-uib-accordion-header,' +
            'uib\\:accordion-header,' +
            '[uib-accordion-header],' +
            '[data-uib-accordion-header],' +
            '[x-uib-accordion-header]';
    }
});
angular.module('ui.bootstrap.alert', [])
    .controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function ($scope, $element, $attrs, $interpolate, $timeout) {
        $scope.closeable = !!$attrs.close;
        $element.addClass('alert');
        $attrs.$set('role', 'alert');
        if ($scope.closeable) {
            $element.addClass('alert-dismissible');
        }
        var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
            $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
        if (dismissOnTimeout) {
            $timeout(function () {
                $scope.close();
            }, parseInt(dismissOnTimeout, 10));
        }
    }])
    .directive('uibAlert', function () {
    return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        scope: {
            close: '&'
        }
    };
});
angular.module('ui.bootstrap.buttons', [])
    .constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
})
    .controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
        this.activeClass = buttonConfig.activeClass || 'active';
        this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }])
    .directive('uibBtnRadio', ['$parse', function ($parse) {
        return {
            require: ['uibBtnRadio', 'ngModel'],
            controller: 'UibButtonsController',
            controllerAs: 'buttons',
            link: function (scope, element, attrs, ctrls) {
                var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                var uncheckableExpr = $parse(attrs.uibUncheckable);
                element.find('input').css({ display: 'none' });
                ngModelCtrl.$render = function () {
                    element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
                };
                element.on(buttonsCtrl.toggleEvent, function () {
                    if (attrs.disabled) {
                        return;
                    }
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    if (!isActive || angular.isDefined(attrs.uncheckable)) {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                            ngModelCtrl.$render();
                        });
                    }
                });
                if (attrs.uibUncheckable) {
                    scope.$watch(uncheckableExpr, function (uncheckable) {
                        attrs.$set('uncheckable', uncheckable ? '' : undefined);
                    });
                }
            }
        };
    }])
    .directive('uibBtnCheckbox', function () {
    return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find('input').css({ display: 'none' });
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            };
            element.on(buttonsCtrl.toggleEvent, function () {
                if (attrs.disabled) {
                    return;
                }
                scope.$apply(function () {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
        }
    };
});
angular.module('ui.bootstrap.carousel', [])
    .controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
        var self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = 'uib-slideDirection', currentIndex = $scope.active, currentInterval, isPlaying;
        var destroyed = false;
        $element.addClass('carousel');
        self.addSlide = function (slide, element) {
            slides.push({
                slide: slide,
                element: element
            });
            slides.sort(function (a, b) {
                return +a.slide.index - +b.slide.index;
            });
            if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
                if ($scope.$currentTransition) {
                    $scope.$currentTransition = null;
                }
                currentIndex = slide.index;
                $scope.active = slide.index;
                setActive(currentIndex);
                self.select(slides[findSlideIndex(slide)]);
                if (slides.length === 1) {
                    $scope.play();
                }
            }
        };
        self.getCurrentIndex = function () {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide.index === currentIndex) {
                    return i;
                }
            }
        };
        self.next = $scope.next = function () {
            var newIndex = (self.getCurrentIndex() + 1) % slides.length;
            if (newIndex === 0 && $scope.noWrap()) {
                $scope.pause();
                return;
            }
            return self.select(slides[newIndex], 'next');
        };
        self.prev = $scope.prev = function () {
            var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
            if ($scope.noWrap() && newIndex === slides.length - 1) {
                $scope.pause();
                return;
            }
            return self.select(slides[newIndex], 'prev');
        };
        self.removeSlide = function (slide) {
            var index = findSlideIndex(slide);
            slides.splice(index, 1);
            if (slides.length > 0 && currentIndex === index) {
                if (index >= slides.length) {
                    currentIndex = slides.length - 1;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[slides.length - 1]);
                }
                else {
                    currentIndex = index;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[index]);
                }
            }
            else if (currentIndex > index) {
                currentIndex--;
                $scope.active = currentIndex;
            }
            if (slides.length === 0) {
                currentIndex = null;
                $scope.active = null;
            }
        };
        self.select = $scope.select = function (nextSlide, direction) {
            var nextIndex = findSlideIndex(nextSlide.slide);
            if (direction === undefined) {
                direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
            }
            if (nextSlide.slide.index !== currentIndex &&
                !$scope.$currentTransition) {
                goNext(nextSlide.slide, nextIndex, direction);
            }
        };
        $scope.indexOfSlide = function (slide) {
            return +slide.slide.index;
        };
        $scope.isActive = function (slide) {
            return $scope.active === slide.slide.index;
        };
        $scope.isPrevDisabled = function () {
            return $scope.active === 0 && $scope.noWrap();
        };
        $scope.isNextDisabled = function () {
            return $scope.active === slides.length - 1 && $scope.noWrap();
        };
        $scope.pause = function () {
            if (!$scope.noPause) {
                isPlaying = false;
                resetTimer();
            }
        };
        $scope.play = function () {
            if (!isPlaying) {
                isPlaying = true;
                restartTimer();
            }
        };
        $element.on('mouseenter', $scope.pause);
        $element.on('mouseleave', $scope.play);
        $scope.$on('$destroy', function () {
            destroyed = true;
            resetTimer();
        });
        $scope.$watch('noTransition', function (noTransition) {
            $animate.enabled($element, !noTransition);
        });
        $scope.$watch('interval', restartTimer);
        $scope.$watchCollection('slides', resetTransition);
        $scope.$watch('active', function (index) {
            if (angular.isNumber(index) && currentIndex !== index) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i].slide.index === index) {
                        index = i;
                        break;
                    }
                }
                var slide = slides[index];
                if (slide) {
                    setActive(index);
                    self.select(slides[index]);
                    currentIndex = index;
                }
            }
        });
        function getSlideByIndex(index) {
            for (var i = 0, l = slides.length; i < l; ++i) {
                if (slides[i].index === index) {
                    return slides[i];
                }
            }
        }
        function setActive(index) {
            for (var i = 0; i < slides.length; i++) {
                slides[i].slide.active = i === index;
            }
        }
        function goNext(slide, index, direction) {
            if (destroyed) {
                return;
            }
            angular.extend(slide, { direction: direction });
            angular.extend(slides[currentIndex].slide || {}, { direction: direction });
            if ($animate.enabled($element) && !$scope.$currentTransition &&
                slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();
                if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
                    slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
                }
                $scope.$currentTransition = true;
                $animate.on('addClass', slides[index].element, function (element, phase) {
                    if (phase === 'close') {
                        $scope.$currentTransition = null;
                        $animate.off('addClass', element);
                    }
                });
            }
            $scope.active = slide.index;
            currentIndex = slide.index;
            setActive(index);
            restartTimer();
        }
        function findSlideIndex(slide) {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide === slide) {
                    return i;
                }
            }
        }
        function resetTimer() {
            if (currentInterval) {
                $interval.cancel(currentInterval);
                currentInterval = null;
            }
        }
        function resetTransition(slides) {
            if (!slides.length) {
                $scope.$currentTransition = null;
            }
        }
        function restartTimer() {
            resetTimer();
            var interval = +$scope.interval;
            if (!isNaN(interval) && interval > 0) {
                currentInterval = $interval(timerFn, interval);
            }
        }
        function timerFn() {
            var interval = +$scope.interval;
            if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
                $scope.next();
            }
            else {
                $scope.pause();
            }
        }
    }])
    .directive('uibCarousel', function () {
    return {
        transclude: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
            active: '=',
            interval: '=',
            noTransition: '=',
            noPause: '=',
            noWrap: '&'
        }
    };
})
    .directive('uibSlide', ['$animate', function ($animate) {
        return {
            require: '^uibCarousel',
            restrict: 'A',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/slide.html';
            },
            scope: {
                actual: '=?',
                index: '=?'
            },
            link: function (scope, element, attrs, carouselCtrl) {
                element.addClass('item');
                carouselCtrl.addSlide(scope, element);
                scope.$on('$destroy', function () {
                    carouselCtrl.removeSlide(scope);
                });
                scope.$watch('active', function (active) {
                    $animate[active ? 'addClass' : 'removeClass'](element, 'active');
                });
            }
        };
    }])
    .animation('.item', ['$animateCss',
    function ($animateCss) {
        var SLIDE_DIRECTION = 'uib-slideDirection';
        function removeClass(element, className, callback) {
            element.removeClass(className);
            if (callback) {
                callback();
            }
        }
        return {
            beforeAddClass: function (element, className, done) {
                if (className === 'active') {
                    var stopped = false;
                    var direction = element.data(SLIDE_DIRECTION);
                    var directionClass = direction === 'next' ? 'left' : 'right';
                    var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
                    element.addClass(direction);
                    $animateCss(element, { addClass: directionClass })
                        .start()
                        .done(removeClassFn);
                    return function () {
                        stopped = true;
                    };
                }
                done();
            },
            beforeRemoveClass: function (element, className, done) {
                if (className === 'active') {
                    var stopped = false;
                    var direction = element.data(SLIDE_DIRECTION);
                    var directionClass = direction === 'next' ? 'left' : 'right';
                    var removeClassFn = removeClass.bind(this, element, directionClass, done);
                    $animateCss(element, { addClass: directionClass })
                        .start()
                        .done(removeClassFn);
                    return function () {
                        stopped = true;
                    };
                }
                done();
            }
        };
    }]);
angular.module('ui.bootstrap.dateparser', [])
    .service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function ($log, $locale, dateFilter, orderByFilter, filterFilter) {
        var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var localeId;
        var formatCodeToRegex;
        this.init = function () {
            localeId = $locale.id;
            this.parsers = {};
            this.formatters = {};
            formatCodeToRegex = [
                {
                    key: 'yyyy',
                    regex: '\\d{4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yyyy');
                    }
                },
                {
                    key: 'yy',
                    regex: '\\d{2}',
                    apply: function (value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yy');
                    }
                },
                {
                    key: 'y',
                    regex: '\\d{1,4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'y');
                    }
                },
                {
                    key: 'M!',
                    regex: '0?[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) {
                        var value = date.getMonth();
                        if (/^[0-9]$/.test(value)) {
                            return dateFilter(date, 'MM');
                        }
                        return dateFilter(date, 'M');
                    }
                },
                {
                    key: 'MMMM',
                    regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMMM'); }
                },
                {
                    key: 'MMM',
                    regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMM'); }
                },
                {
                    key: 'MM',
                    regex: '0[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'MM'); }
                },
                {
                    key: 'M',
                    regex: '[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'M'); }
                },
                {
                    key: 'd!',
                    regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) {
                        var value = date.getDate();
                        if (/^[1-9]$/.test(value)) {
                            return dateFilter(date, 'dd');
                        }
                        return dateFilter(date, 'd');
                    }
                },
                {
                    key: 'dd',
                    regex: '[0-2][0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'dd'); }
                },
                {
                    key: 'd',
                    regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'd'); }
                },
                {
                    key: 'EEEE',
                    regex: $locale.DATETIME_FORMATS.DAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEEE'); }
                },
                {
                    key: 'EEE',
                    regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEE'); }
                },
                {
                    key: 'HH',
                    regex: '(?:0|1)[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'HH'); }
                },
                {
                    key: 'hh',
                    regex: '0[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'hh'); }
                },
                {
                    key: 'H',
                    regex: '1?[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'H'); }
                },
                {
                    key: 'h',
                    regex: '[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'h'); }
                },
                {
                    key: 'mm',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'mm'); }
                },
                {
                    key: 'm',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'm'); }
                },
                {
                    key: 'sss',
                    regex: '[0-9][0-9][0-9]',
                    apply: function (value) { this.milliseconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'sss'); }
                },
                {
                    key: 'ss',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'ss'); }
                },
                {
                    key: 's',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 's'); }
                },
                {
                    key: 'a',
                    regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
                    apply: function (value) {
                        if (this.hours === 12) {
                            this.hours = 0;
                        }
                        if (value === 'PM') {
                            this.hours += 12;
                        }
                    },
                    formatter: function (date) { return dateFilter(date, 'a'); }
                },
                {
                    key: 'Z',
                    regex: '[+-]\\d{4}',
                    apply: function (value) {
                        var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                        this.hours += toInt(sign + hours);
                        this.minutes += toInt(sign + minutes);
                    },
                    formatter: function (date) {
                        return dateFilter(date, 'Z');
                    }
                },
                {
                    key: 'ww',
                    regex: '[0-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'ww'); }
                },
                {
                    key: 'w',
                    regex: '[0-9]|[1-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'w'); }
                },
                {
                    key: 'GGGG',
                    regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
                    formatter: function (date) { return dateFilter(date, 'GGGG'); }
                },
                {
                    key: 'GGG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GGG'); }
                },
                {
                    key: 'GG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GG'); }
                },
                {
                    key: 'G',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'G'); }
                }
            ];
            if (angular.version.major >= 1 && angular.version.minor > 4) {
                formatCodeToRegex.push({
                    key: 'LLLL',
                    regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'LLLL'); }
                });
            }
        };
        this.init();
        function getFormatCodeToRegex(key) {
            return filterFilter(formatCodeToRegex, { key: key }, true)[0];
        }
        this.getParser = function (key) {
            var f = getFormatCodeToRegex(key);
            return f && f.apply || null;
        };
        this.overrideParser = function (key, parser) {
            var f = getFormatCodeToRegex(key);
            if (f && angular.isFunction(parser)) {
                this.parsers = {};
                f.apply = parser;
            }
        }.bind(this);
        function createParser(format) {
            var map = [], regex = format.split('');
            var quoteIndex = format.indexOf('\'');
            if (quoteIndex > -1) {
                var inLiteral = false;
                format = format.split('');
                for (var i = quoteIndex; i < format.length; i++) {
                    if (inLiteral) {
                        if (format[i] === '\'') {
                            if (i + 1 < format.length && format[i + 1] === '\'') {
                                format[i + 1] = '$';
                                regex[i + 1] = '';
                            }
                            else {
                                regex[i] = '';
                                inLiteral = false;
                            }
                        }
                        format[i] = '$';
                    }
                    else {
                        if (format[i] === '\'') {
                            format[i] = '$';
                            regex[i] = '';
                            inLiteral = true;
                        }
                    }
                }
                format = format.join('');
            }
            angular.forEach(formatCodeToRegex, function (data) {
                var index = format.indexOf(data.key);
                if (index > -1) {
                    format = format.split('');
                    regex[index] = '(' + data.regex + ')';
                    format[index] = '$';
                    for (var i = index + 1, n = index + data.key.length; i < n; i++) {
                        regex[i] = '';
                        format[i] = '$';
                    }
                    format = format.join('');
                    map.push({
                        index: index,
                        key: data.key,
                        apply: data.apply,
                        matcher: data.regex
                    });
                }
            });
            return {
                regex: new RegExp('^' + regex.join('') + '$'),
                map: orderByFilter(map, 'index')
            };
        }
        function createFormatter(format) {
            var formatters = [];
            var i = 0;
            var formatter, literalIdx;
            while (i < format.length) {
                if (angular.isNumber(literalIdx)) {
                    if (format.charAt(i) === '\'') {
                        if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
                            formatters.push(constructLiteralFormatter(format, literalIdx, i));
                            literalIdx = null;
                        }
                    }
                    else if (i === format.length) {
                        while (literalIdx < format.length) {
                            formatter = constructFormatterFromIdx(format, literalIdx);
                            formatters.push(formatter);
                            literalIdx = formatter.endIdx;
                        }
                    }
                    i++;
                    continue;
                }
                if (format.charAt(i) === '\'') {
                    literalIdx = i;
                    i++;
                    continue;
                }
                formatter = constructFormatterFromIdx(format, i);
                formatters.push(formatter.parser);
                i = formatter.endIdx;
            }
            return formatters;
        }
        function constructLiteralFormatter(format, literalIdx, endIdx) {
            return function () {
                return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
            };
        }
        function constructFormatterFromIdx(format, i) {
            var currentPosStr = format.substr(i);
            for (var j = 0; j < formatCodeToRegex.length; j++) {
                if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
                    var data = formatCodeToRegex[j];
                    return {
                        endIdx: i + data.key.length,
                        parser: data.formatter
                    };
                }
            }
            return {
                endIdx: i + 1,
                parser: function () {
                    return currentPosStr.charAt(0);
                }
            };
        }
        this.filter = function (date, format) {
            if (!angular.isDate(date) || isNaN(date) || !format) {
                return '';
            }
            format = $locale.DATETIME_FORMATS[format] || format;
            if ($locale.id !== localeId) {
                this.init();
            }
            if (!this.formatters[format]) {
                this.formatters[format] = createFormatter(format);
            }
            var formatters = this.formatters[format];
            return formatters.reduce(function (str, formatter) {
                return str + formatter(date);
            }, '');
        };
        this.parse = function (input, format, baseDate) {
            if (!angular.isString(input) || !format) {
                return input;
            }
            format = $locale.DATETIME_FORMATS[format] || format;
            format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
            if ($locale.id !== localeId) {
                this.init();
            }
            if (!this.parsers[format]) {
                this.parsers[format] = createParser(format, 'apply');
            }
            var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = false;
            if (results && results.length) {
                var fields, dt;
                if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                    fields = {
                        year: baseDate.getFullYear(),
                        month: baseDate.getMonth(),
                        date: baseDate.getDate(),
                        hours: baseDate.getHours(),
                        minutes: baseDate.getMinutes(),
                        seconds: baseDate.getSeconds(),
                        milliseconds: baseDate.getMilliseconds()
                    };
                }
                else {
                    if (baseDate) {
                        $log.warn('dateparser:', 'baseDate is not a valid date');
                    }
                    fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
                }
                for (var i = 1, n = results.length; i < n; i++) {
                    var mapper = map[i - 1];
                    if (mapper.matcher === 'Z') {
                        tzOffset = true;
                    }
                    if (mapper.apply) {
                        mapper.apply.call(fields, results[i]);
                    }
                }
                var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
                    Date.prototype.setFullYear;
                var timesetter = tzOffset ? Date.prototype.setUTCHours :
                    Date.prototype.setHours;
                if (isValid(fields.year, fields.month, fields.date)) {
                    if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
                        dt = new Date(baseDate);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
                    }
                    else {
                        dt = new Date(0);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
                    }
                }
                return dt;
            }
        };
        function isValid(year, month, date) {
            if (date < 1) {
                return false;
            }
            if (month === 1 && date > 28) {
                return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
            }
            if (month === 3 || month === 5 || month === 8 || month === 10) {
                return date < 31;
            }
            return true;
        }
        function toInt(str) {
            return parseInt(str, 10);
        }
        this.toTimezone = toTimezone;
        this.fromTimezone = fromTimezone;
        this.timezoneToOffset = timezoneToOffset;
        this.addDateMinutes = addDateMinutes;
        this.convertTimezoneToLocal = convertTimezoneToLocal;
        function toTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
        }
        function fromTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
        }
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(/:/g, '');
            var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
    }]);
angular.module('ui.bootstrap.isClass', [])
    .directive('uibIsClass', [
    '$animate',
    function ($animate) {
        var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
        var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
        var dataPerTracked = {};
        return {
            restrict: 'A',
            compile: function (tElement, tAttrs) {
                var linkedScopes = [];
                var instances = [];
                var expToData = {};
                var lastActivated = null;
                var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
                var onExp = onExpMatches[2];
                var expsStr = onExpMatches[1];
                var exps = expsStr.split(',');
                return linkFn;
                function linkFn(scope, element, attrs) {
                    linkedScopes.push(scope);
                    instances.push({
                        scope: scope,
                        element: element
                    });
                    exps.forEach(function (exp, k) {
                        addForExp(exp, scope);
                    });
                    scope.$on('$destroy', removeScope);
                }
                function addForExp(exp, scope) {
                    var matches = exp.match(IS_REGEXP);
                    var clazz = scope.$eval(matches[1]);
                    var compareWithExp = matches[2];
                    var data = expToData[exp];
                    if (!data) {
                        var watchFn = function (compareWithVal) {
                            var newActivated = null;
                            instances.some(function (instance) {
                                var thisVal = instance.scope.$eval(onExp);
                                if (thisVal === compareWithVal) {
                                    newActivated = instance;
                                    return true;
                                }
                            });
                            if (data.lastActivated !== newActivated) {
                                if (data.lastActivated) {
                                    $animate.removeClass(data.lastActivated.element, clazz);
                                }
                                if (newActivated) {
                                    $animate.addClass(newActivated.element, clazz);
                                }
                                data.lastActivated = newActivated;
                            }
                        };
                        expToData[exp] = data = {
                            lastActivated: null,
                            scope: scope,
                            watchFn: watchFn,
                            compareWithExp: compareWithExp,
                            watcher: scope.$watch(compareWithExp, watchFn)
                        };
                    }
                    data.watchFn(scope.$eval(compareWithExp));
                }
                function removeScope(e) {
                    var removedScope = e.targetScope;
                    var index = linkedScopes.indexOf(removedScope);
                    linkedScopes.splice(index, 1);
                    instances.splice(index, 1);
                    if (linkedScopes.length) {
                        var newWatchScope = linkedScopes[0];
                        angular.forEach(expToData, function (data) {
                            if (data.scope === removedScope) {
                                data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                                data.scope = newWatchScope;
                            }
                        });
                    }
                    else {
                        expToData = {};
                    }
                }
            }
        };
    }
]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])
    .value('$datepickerSuppressError', false)
    .value('$datepickerLiteralWarning', true)
    .constant('uibDatepickerConfig', {
    datepickerMode: 'day',
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    maxDate: null,
    maxMode: 'year',
    minDate: null,
    minMode: 'day',
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4
})
    .controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
    function ($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
        var self = this, ngModelCtrl = { $setViewValue: angular.noop }, ngModelOptions = {}, watchListeners = [];
        $element.addClass('uib-datepicker');
        $attrs.$set('role', 'application');
        if (!$scope.datepickerOptions) {
            $scope.datepickerOptions = {};
        }
        this.modes = ['day', 'month', 'year'];
        [
            'customClass',
            'dateDisabled',
            'datepickerMode',
            'formatDay',
            'formatDayHeader',
            'formatDayTitle',
            'formatMonth',
            'formatMonthTitle',
            'formatYear',
            'maxDate',
            'maxMode',
            'minDate',
            'minMode',
            'monthColumns',
            'showWeeks',
            'shortcutPropagation',
            'startingDay',
            'yearColumns',
            'yearRows'
        ].forEach(function (key) {
            switch (key) {
                case 'customClass':
                case 'dateDisabled':
                    $scope[key] = $scope.datepickerOptions[key] || angular.noop;
                    break;
                case 'datepickerMode':
                    $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
                        $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
                    break;
                case 'formatDay':
                case 'formatDayHeader':
                case 'formatDayTitle':
                case 'formatMonth':
                case 'formatMonthTitle':
                case 'formatYear':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                        $interpolate($scope.datepickerOptions[key])($scope.$parent) :
                        datepickerConfig[key];
                    break;
                case 'monthColumns':
                case 'showWeeks':
                case 'shortcutPropagation':
                case 'yearColumns':
                case 'yearRows':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                        $scope.datepickerOptions[key] : datepickerConfig[key];
                    break;
                case 'startingDay':
                    if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                        self.startingDay = $scope.datepickerOptions.startingDay;
                    }
                    else if (angular.isNumber(datepickerConfig.startingDay)) {
                        self.startingDay = datepickerConfig.startingDay;
                    }
                    else {
                        self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
                    }
                    break;
                case 'maxDate':
                case 'minDate':
                    $scope.$watch('datepickerOptions.' + key, function (value) {
                        if (value) {
                            if (angular.isDate(value)) {
                                self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
                            }
                            else {
                                if ($datepickerLiteralWarning) {
                                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                                }
                                self[key] = new Date(dateFilter(value, 'medium'));
                            }
                        }
                        else {
                            self[key] = datepickerConfig[key] ?
                                dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :
                                null;
                        }
                        self.refreshView();
                    });
                    break;
                case 'maxMode':
                case 'minMode':
                    if ($scope.datepickerOptions[key]) {
                        $scope.$watch(function () { return $scope.datepickerOptions[key]; }, function (value) {
                            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
                            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
                                key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                                $scope.datepickerMode = self[key];
                                $scope.datepickerOptions.datepickerMode = self[key];
                            }
                        });
                    }
                    else {
                        self[key] = $scope[key] = datepickerConfig[key] || null;
                    }
                    break;
            }
        });
        $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
        $scope.disabled = angular.isDefined($attrs.disabled) || false;
        if (angular.isDefined($attrs.ngDisabled)) {
            watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
                $scope.disabled = disabled;
                self.refreshView();
            }));
        }
        $scope.isActive = function (dateObject) {
            if (self.compare(dateObject.date, self.activeDate) === 0) {
                $scope.activeDateId = dateObject.uid;
                return true;
            }
            return false;
        };
        this.init = function (ngModelCtrl_) {
            ngModelCtrl = ngModelCtrl_;
            ngModelOptions = extractOptions(ngModelCtrl);
            if ($scope.datepickerOptions.initDate) {
                self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
                $scope.$watch('datepickerOptions.initDate', function (initDate) {
                    if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                        self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
                        self.refreshView();
                    }
                });
            }
            else {
                self.activeDate = new Date();
            }
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
            this.activeDate = !isNaN(date) ?
                dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :
                dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
            ngModelCtrl.$render = function () {
                self.render();
            };
        };
        this.render = function () {
            if (ngModelCtrl.$viewValue) {
                var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
                if (isValid) {
                    this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                }
                else if (!$datepickerSuppressError) {
                    $log.error('Datepicker directive: "ng-model" value must be a Date object');
                }
            }
            this.refreshView();
        };
        this.refreshView = function () {
            if (this.element) {
                $scope.selectedDt = null;
                this._refreshView();
                if ($scope.activeDt) {
                    $scope.activeDateId = $scope.activeDt.uid;
                }
                var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                ngModelCtrl.$setValidity('dateDisabled', !date ||
                    this.element && !this.isDisabled(date));
            }
        };
        this.createDateObject = function (date, format) {
            var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
            var today = new Date();
            today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
            var time = this.compare(date, today);
            var dt = {
                date: date,
                label: dateParser.filter(date, format),
                selected: model && this.compare(date, model) === 0,
                disabled: this.isDisabled(date),
                past: time < 0,
                current: time === 0,
                future: time > 0,
                customClass: this.customClass(date) || null
            };
            if (model && this.compare(date, model) === 0) {
                $scope.selectedDt = dt;
            }
            if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
                $scope.activeDt = dt;
            }
            return dt;
        };
        this.isDisabled = function (date) {
            return $scope.disabled ||
                this.minDate && this.compare(date, this.minDate) < 0 ||
                this.maxDate && this.compare(date, this.maxDate) > 0 ||
                $scope.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
        };
        this.customClass = function (date) {
            return $scope.customClass({ date: date, mode: $scope.datepickerMode });
        };
        this.split = function (arr, size) {
            var arrays = [];
            while (arr.length > 0) {
                arrays.push(arr.splice(0, size));
            }
            return arrays;
        };
        $scope.select = function (date) {
            if ($scope.datepickerMode === self.minMode) {
                var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
                dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
                ngModelCtrl.$setViewValue(dt);
                ngModelCtrl.$render();
            }
            else {
                self.activeDate = date;
                setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
                $scope.$emit('uib:datepicker.mode');
            }
            $scope.$broadcast('uib:datepicker.focus');
        };
        $scope.move = function (direction) {
            var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
            self.activeDate.setFullYear(year, month, 1);
            self.refreshView();
        };
        $scope.toggleMode = function (direction) {
            direction = direction || 1;
            if ($scope.datepickerMode === self.maxMode && direction === 1 ||
                $scope.datepickerMode === self.minMode && direction === -1) {
                return;
            }
            setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
            $scope.$emit('uib:datepicker.mode');
        };
        $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
        var focusElement = function () {
            self.element[0].focus();
        };
        $scope.$on('uib:datepicker.focus', focusElement);
        $scope.keydown = function (evt) {
            var key = $scope.keys[evt.which];
            if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
                return;
            }
            evt.preventDefault();
            if (!self.shortcutPropagation) {
                evt.stopPropagation();
            }
            if (key === 'enter' || key === 'space') {
                if (self.isDisabled(self.activeDate)) {
                    return;
                }
                $scope.select(self.activeDate);
            }
            else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
                $scope.toggleMode(key === 'up' ? 1 : -1);
            }
            else {
                self.handleKeyDown(key, evt);
                self.refreshView();
            }
        };
        $element.on('keydown', function (evt) {
            $scope.$apply(function () {
                $scope.keydown(evt);
            });
        });
        $scope.$on('$destroy', function () {
            while (watchListeners.length) {
                watchListeners.shift()();
            }
        });
        function setMode(mode) {
            $scope.datepickerMode = mode;
            $scope.datepickerOptions.datepickerMode = mode;
        }
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = ngModelCtrl.$options ||
                    $scope.datepickerOptions.ngModelOptions ||
                    datepickerConfig.ngModelOptions ||
                    {};
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                var timezone = ngModelCtrl.$options.getOption('timezone') ||
                    ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||
                    (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);
                ngModelOptions = ngModelCtrl.$options
                    .createChild(datepickerConfig.ngModelOptions)
                    .createChild($scope.datepickerOptions.ngModelOptions)
                    .createChild(ngModelCtrl.$options)
                    .createChild({ timezone: timezone });
            }
            return ngModelOptions;
        }
    }])
    .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        this.step = { months: 1 };
        this.element = $element;
        function getDaysInMonth(year, month) {
            return month === 1 && year % 4 === 0 &&
                (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
        }
        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            scope.showWeeks = ctrl.showWeeks;
            ctrl.refreshView();
        };
        this.getDates = function (startDate, n) {
            var dates = new Array(n), current = new Date(startDate), i = 0, date;
            while (i < n) {
                date = new Date(current);
                dates[i++] = date;
                current.setDate(current.getDate() + 1);
            }
            return dates;
        };
        this._refreshView = function () {
            var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
            firstDayOfMonth.setFullYear(year, month, 1);
            var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ?
                7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
            if (numDisplayedFromPreviousMonth > 0) {
                firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
            }
            var days = this.getDates(firstDate, 42);
            for (var i = 0; i < 42; i++) {
                days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
                    secondary: days[i].getMonth() !== month,
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.labels = new Array(7);
            for (var j = 0; j < 7; j++) {
                scope.labels[j] = {
                    abbr: dateFilter(days[j].date, this.formatDayHeader),
                    full: dateFilter(days[j].date, 'EEEE')
                };
            }
            scope.title = dateFilter(this.activeDate, this.formatDayTitle);
            scope.rows = this.split(days, 7);
            if (scope.showWeeks) {
                scope.weekNumbers = [];
                var thursdayIndex = (4 + 7 - this.startingDay) % 7, numWeeks = scope.rows.length;
                for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                    scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
                }
            }
        };
        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };
        function getISO8601WeekNumber(date) {
            var checkDate = new Date(date);
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            var time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        }
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getDate();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - 7;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + 7;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
                this.activeDate.setMonth(month, 1);
                date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
            }
            else if (key === 'home') {
                date = 1;
            }
            else if (key === 'end') {
                date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
            }
            this.activeDate.setDate(date);
        };
    }])
    .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        this.step = { years: 1 };
        this.element = $element;
        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            ctrl.refreshView();
        };
        this._refreshView = function () {
            var months = new Array(12), year = this.activeDate.getFullYear(), date;
            for (var i = 0; i < 12; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(year, i, 1);
                months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
            scope.rows = this.split(months, this.monthColumns);
            scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
        };
        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getMonth();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - this.monthColumns;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + this.monthColumns;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
                this.activeDate.setFullYear(year);
            }
            else if (key === 'home') {
                date = 0;
            }
            else if (key === 'end') {
                date = 11;
            }
            this.activeDate.setMonth(date);
        };
    }])
    .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var columns, range;
        this.element = $element;
        function getStartingYear(year) {
            return parseInt((year - 1) / range, 10) * range + 1;
        }
        this.yearpickerInit = function () {
            columns = this.yearColumns;
            range = this.yearRows * columns;
            this.step = { years: range };
        };
        this._refreshView = function () {
            var years = new Array(range), date;
            for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(start + i, 0, 1);
                years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.title = [years[0].label, years[range - 1].label].join(' - ');
            scope.rows = this.split(years, columns);
            scope.columns = columns;
        };
        this.compare = function (date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
        };
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getFullYear();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - columns;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + columns;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                date += (key === 'pageup' ? -1 : 1) * range;
            }
            else if (key === 'home') {
                date = getStartingYear(this.activeDate.getFullYear());
            }
            else if (key === 'end') {
                date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
            }
            this.activeDate.setFullYear(date);
        };
    }])
    .directive('uibDatepicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
        },
        scope: {
            datepickerOptions: '=?'
        },
        require: ['uibDatepicker', '^ngModel'],
        restrict: 'A',
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
})
    .directive('uibDaypicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        restrict: 'A',
        controller: 'UibDaypickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
})
    .directive('uibMonthpicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        restrict: 'A',
        controller: 'UibMonthpickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
})
    .directive('uibYearpicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        restrict: 'A',
        controller: 'UibYearpickerController',
        link: function (scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]);
            ctrl.yearpickerInit();
            ctrl.refreshView();
        }
    };
});
angular.module('ui.bootstrap.position', [])
    .factory('$uibPosition', ['$document', '$window', function ($document, $window) {
        var SCROLLBAR_WIDTH;
        var BODY_SCROLLBAR_WIDTH;
        var OVERFLOW_REGEX = {
            normal: /(auto|scroll)/,
            hidden: /(auto|scroll|hidden)/
        };
        var PLACEMENT_REGEX = {
            auto: /\s?auto?\s?/i,
            primary: /^(top|bottom|left|right)$/,
            secondary: /^(top|bottom|left|right|center)$/,
            vertical: /^(top|bottom)$/
        };
        var BODY_REGEX = /(HTML|BODY)/;
        return {
            getRawNode: function (elem) {
                return elem.nodeName ? elem : elem[0] || elem;
            },
            parseStyle: function (value) {
                value = parseFloat(value);
                return isFinite(value) ? value : 0;
            },
            offsetParent: function (elem) {
                elem = this.getRawNode(elem);
                var offsetParent = elem.offsetParent || $document[0].documentElement;
                function isStaticPositioned(el) {
                    return ($window.getComputedStyle(el).position || 'static') === 'static';
                }
                while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || $document[0].documentElement;
            },
            scrollbarWidth: function (isBody) {
                if (isBody) {
                    if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                        var bodyElem = $document.find('body');
                        bodyElem.addClass('uib-position-body-scrollbar-measure');
                        BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
                        BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
                        bodyElem.removeClass('uib-position-body-scrollbar-measure');
                    }
                    return BODY_SCROLLBAR_WIDTH;
                }
                if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                    var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                    $document.find('body').append(scrollElem);
                    SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
                    SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
                    scrollElem.remove();
                }
                return SCROLLBAR_WIDTH;
            },
            scrollbarPadding: function (elem) {
                elem = this.getRawNode(elem);
                var elemStyle = $window.getComputedStyle(elem);
                var paddingRight = this.parseStyle(elemStyle.paddingRight);
                var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
                var scrollParent = this.scrollParent(elem, false, true);
                var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));
                return {
                    scrollbarWidth: scrollbarWidth,
                    widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                    right: paddingRight + scrollbarWidth,
                    originalRight: paddingRight,
                    heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                    bottom: paddingBottom + scrollbarWidth,
                    originalBottom: paddingBottom
                };
            },
            isScrollable: function (elem, includeHidden) {
                elem = this.getRawNode(elem);
                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var elemStyle = $window.getComputedStyle(elem);
                return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
            },
            scrollParent: function (elem, includeHidden, includeSelf) {
                elem = this.getRawNode(elem);
                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var documentEl = $document[0].documentElement;
                var elemStyle = $window.getComputedStyle(elem);
                if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
                    return elem;
                }
                var excludeStatic = elemStyle.position === 'absolute';
                var scrollParent = elem.parentElement || documentEl;
                if (scrollParent === documentEl || elemStyle.position === 'fixed') {
                    return documentEl;
                }
                while (scrollParent.parentElement && scrollParent !== documentEl) {
                    var spStyle = $window.getComputedStyle(scrollParent);
                    if (excludeStatic && spStyle.position !== 'static') {
                        excludeStatic = false;
                    }
                    if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
                        break;
                    }
                    scrollParent = scrollParent.parentElement;
                }
                return scrollParent;
            },
            position: function (elem, includeMagins) {
                elem = this.getRawNode(elem);
                var elemOffset = this.offset(elem);
                if (includeMagins) {
                    var elemStyle = $window.getComputedStyle(elem);
                    elemOffset.top -= this.parseStyle(elemStyle.marginTop);
                    elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
                }
                var parent = this.offsetParent(elem);
                var parentOffset = { top: 0, left: 0 };
                if (parent !== $document[0].documentElement) {
                    parentOffset = this.offset(parent);
                    parentOffset.top += parent.clientTop - parent.scrollTop;
                    parentOffset.left += parent.clientLeft - parent.scrollLeft;
                }
                return {
                    width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                    top: Math.round(elemOffset.top - parentOffset.top),
                    left: Math.round(elemOffset.left - parentOffset.left)
                };
            },
            offset: function (elem) {
                elem = this.getRawNode(elem);
                var elemBCR = elem.getBoundingClientRect();
                return {
                    width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                    top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                    left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
                };
            },
            viewportOffset: function (elem, useDocument, includePadding) {
                elem = this.getRawNode(elem);
                includePadding = includePadding !== false ? true : false;
                var elemBCR = elem.getBoundingClientRect();
                var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };
                var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
                var offsetParentBCR = offsetParent.getBoundingClientRect();
                offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
                offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
                if (offsetParent === $document[0].documentElement) {
                    offsetBCR.top += $window.pageYOffset;
                    offsetBCR.left += $window.pageXOffset;
                }
                offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
                offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
                if (includePadding) {
                    var offsetParentStyle = $window.getComputedStyle(offsetParent);
                    offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
                    offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
                    offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
                    offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
                }
                return {
                    top: Math.round(elemBCR.top - offsetBCR.top),
                    bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                    left: Math.round(elemBCR.left - offsetBCR.left),
                    right: Math.round(offsetBCR.right - elemBCR.right)
                };
            },
            parsePlacement: function (placement) {
                var autoPlace = PLACEMENT_REGEX.auto.test(placement);
                if (autoPlace) {
                    placement = placement.replace(PLACEMENT_REGEX.auto, '');
                }
                placement = placement.split('-');
                placement[0] = placement[0] || 'top';
                if (!PLACEMENT_REGEX.primary.test(placement[0])) {
                    placement[0] = 'top';
                }
                placement[1] = placement[1] || 'center';
                if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
                    placement[1] = 'center';
                }
                if (autoPlace) {
                    placement[2] = true;
                }
                else {
                    placement[2] = false;
                }
                return placement;
            },
            positionElements: function (hostElem, targetElem, placement, appendToBody) {
                hostElem = this.getRawNode(hostElem);
                targetElem = this.getRawNode(targetElem);
                var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
                var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
                placement = this.parsePlacement(placement);
                var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
                var targetElemPos = { top: 0, left: 0, placement: '' };
                if (placement[2]) {
                    var viewportOffset = this.viewportOffset(hostElem, appendToBody);
                    var targetElemStyle = $window.getComputedStyle(targetElem);
                    var adjustedSize = {
                        width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                        height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                    };
                    placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                        placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                            placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                                placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                                    placement[0];
                    placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                        placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                            placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                                placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                                    placement[1];
                    if (placement[1] === 'center') {
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                            if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                                placement[1] = 'left';
                            }
                            else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                                placement[1] = 'right';
                            }
                        }
                        else {
                            var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                            if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                                placement[1] = 'top';
                            }
                            else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                                placement[1] = 'bottom';
                            }
                        }
                    }
                }
                switch (placement[0]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top - targetHeight;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left - targetWidth;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width;
                        break;
                }
                switch (placement[1]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                        break;
                    case 'center':
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
                        }
                        else {
                            targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
                        }
                        break;
                }
                targetElemPos.top = Math.round(targetElemPos.top);
                targetElemPos.left = Math.round(targetElemPos.left);
                targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
                return targetElemPos;
            },
            adjustTop: function (placementClasses, containerPosition, initialHeight, currentHeight) {
                if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
                    return {
                        top: containerPosition.top - currentHeight + 'px'
                    };
                }
            },
            positionArrow: function (elem, placement) {
                elem = this.getRawNode(elem);
                var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
                if (!innerElem) {
                    return;
                }
                var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
                var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
                if (!arrowElem) {
                    return;
                }
                var arrowCss = {
                    top: '',
                    bottom: '',
                    left: '',
                    right: ''
                };
                placement = this.parsePlacement(placement);
                if (placement[1] === 'center') {
                    angular.element(arrowElem).css(arrowCss);
                    return;
                }
                var borderProp = 'border-' + placement[0] + '-width';
                var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
                var borderRadiusProp = 'border-';
                if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    borderRadiusProp += placement[0] + '-' + placement[1];
                }
                else {
                    borderRadiusProp += placement[1] + '-' + placement[0];
                }
                borderRadiusProp += '-radius';
                var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                switch (placement[0]) {
                    case 'top':
                        arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'bottom':
                        arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'left':
                        arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'right':
                        arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
                        break;
                }
                arrowCss[placement[1]] = borderRadius;
                angular.element(arrowElem).css(arrowCss);
            }
        };
    }]);
angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])
    .value('$datepickerPopupLiteralWarning', true)
    .constant('uibDatepickerPopupConfig', {
    altInputFormats: [],
    appendToBody: false,
    clearText: 'Clear',
    closeOnDateSelection: true,
    closeText: 'Done',
    currentText: 'Today',
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
    datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
    html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
    },
    onOpenFocus: true,
    showButtonBar: true,
    placement: 'auto bottom-left'
})
    .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
    function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
        var cache = {}, isHtml5DateInput = false;
        var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];
        this.init = function (_ngModel_) {
            ngModel = _ngModel_;
            ngModelOptions = extractOptions(ngModel);
            closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
                $scope.$parent.$eval($attrs.closeOnDateSelection) :
                datepickerPopupConfig.closeOnDateSelection;
            appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
                $scope.$parent.$eval($attrs.datepickerAppendToBody) :
                datepickerPopupConfig.appendToBody;
            onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
                $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
            datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
                $attrs.datepickerPopupTemplateUrl :
                datepickerPopupConfig.datepickerPopupTemplateUrl;
            datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
                $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
            altInputFormats = angular.isDefined($attrs.altInputFormats) ?
                $scope.$parent.$eval($attrs.altInputFormats) :
                datepickerPopupConfig.altInputFormats;
            $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
                $scope.$parent.$eval($attrs.showButtonBar) :
                datepickerPopupConfig.showButtonBar;
            if (datepickerPopupConfig.html5Types[$attrs.type]) {
                dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
                isHtml5DateInput = true;
            }
            else {
                dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
                $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
                    var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                    if (newDateFormat !== dateFormat) {
                        dateFormat = newDateFormat;
                        ngModel.$modelValue = null;
                        if (!dateFormat) {
                            throw new Error('uibDatepickerPopup must have a date format specified.');
                        }
                    }
                });
            }
            if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
            }
            if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
                throw new Error('HTML5 date input types do not support custom formats.');
            }
            popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
            popupEl.attr({
                'ng-model': 'date',
                'ng-change': 'dateSelection(date)',
                'template-url': datepickerPopupTemplateUrl
            });
            datepickerEl = angular.element(popupEl.children()[0]);
            datepickerEl.attr('template-url', datepickerTemplateUrl);
            if (!$scope.datepickerOptions) {
                $scope.datepickerOptions = {};
            }
            if (isHtml5DateInput) {
                if ($attrs.type === 'month') {
                    $scope.datepickerOptions.datepickerMode = 'month';
                    $scope.datepickerOptions.minMode = 'month';
                }
            }
            datepickerEl.attr('datepicker-options', 'datepickerOptions');
            if (!isHtml5DateInput) {
                ngModel.$$parserName = 'date';
                ngModel.$validators.date = validator;
                ngModel.$parsers.unshift(parseDate);
                ngModel.$formatters.push(function (value) {
                    if (ngModel.$isEmpty(value)) {
                        $scope.date = value;
                        return value;
                    }
                    if (angular.isNumber(value)) {
                        value = new Date(value);
                    }
                    $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
                    return dateParser.filter($scope.date, dateFormat);
                });
            }
            else {
                ngModel.$formatters.push(function (value) {
                    $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
                    return value;
                });
            }
            ngModel.$viewChangeListeners.push(function () {
                $scope.date = parseDateString(ngModel.$viewValue);
            });
            $element.on('keydown', inputKeydownBind);
            $popup = $compile(popupEl)($scope);
            popupEl.remove();
            if (appendToBody) {
                $document.find('body').append($popup);
            }
            else {
                $element.after($popup);
            }
            $scope.$on('$destroy', function () {
                if ($scope.isOpen === true) {
                    if (!$rootScope.$$phase) {
                        $scope.$apply(function () {
                            $scope.isOpen = false;
                        });
                    }
                }
                $popup.remove();
                $element.off('keydown', inputKeydownBind);
                $document.off('click', documentClickBind);
                if (scrollParentEl) {
                    scrollParentEl.off('scroll', positionPopup);
                }
                angular.element($window).off('resize', positionPopup);
                while (watchListeners.length) {
                    watchListeners.shift()();
                }
            });
        };
        $scope.getText = function (key) {
            return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
        };
        $scope.isDisabled = function (date) {
            if (date === 'today') {
                date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
            }
            var dates = {};
            angular.forEach(['minDate', 'maxDate'], function (key) {
                if (!$scope.datepickerOptions[key]) {
                    dates[key] = null;
                }
                else if (angular.isDate($scope.datepickerOptions[key])) {
                    dates[key] = new Date($scope.datepickerOptions[key]);
                }
                else {
                    if ($datepickerPopupLiteralWarning) {
                        $log.warn('Literal date support has been deprecated, please switch to date object usage');
                    }
                    dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
                }
            });
            return $scope.datepickerOptions &&
                dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
                dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
        };
        $scope.compare = function (date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        };
        $scope.dateSelection = function (dt) {
            $scope.date = dt;
            var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
            $element.val(date);
            ngModel.$setViewValue(date);
            if (closeOnDateSelection) {
                $scope.isOpen = false;
                $element[0].focus();
            }
        };
        $scope.keydown = function (evt) {
            if (evt.which === 27) {
                evt.stopPropagation();
                $scope.isOpen = false;
                $element[0].focus();
            }
        };
        $scope.select = function (date, evt) {
            evt.stopPropagation();
            if (date === 'today') {
                var today = new Date();
                if (angular.isDate($scope.date)) {
                    date = new Date($scope.date);
                    date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
                }
                else {
                    date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
                    date.setHours(0, 0, 0, 0);
                }
            }
            $scope.dateSelection(date);
        };
        $scope.close = function (evt) {
            evt.stopPropagation();
            $scope.isOpen = false;
            $element[0].focus();
        };
        $scope.disabled = angular.isDefined($attrs.disabled) || false;
        if ($attrs.ngDisabled) {
            watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
                $scope.disabled = disabled;
            }));
        }
        $scope.$watch('isOpen', function (value) {
            if (value) {
                if (!$scope.disabled) {
                    $timeout(function () {
                        positionPopup();
                        if (onOpenFocus) {
                            $scope.$broadcast('uib:datepicker.focus');
                        }
                        $document.on('click', documentClickBind);
                        var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                        if (appendToBody || $position.parsePlacement(placement)[2]) {
                            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                            if (scrollParentEl) {
                                scrollParentEl.on('scroll', positionPopup);
                            }
                        }
                        else {
                            scrollParentEl = null;
                        }
                        angular.element($window).on('resize', positionPopup);
                    }, 0, false);
                }
                else {
                    $scope.isOpen = false;
                }
            }
            else {
                $document.off('click', documentClickBind);
                if (scrollParentEl) {
                    scrollParentEl.off('scroll', positionPopup);
                }
                angular.element($window).off('resize', positionPopup);
            }
        });
        function cameltoDash(string) {
            return string.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
        }
        function parseDateString(viewValue) {
            var date = dateParser.parse(viewValue, dateFormat, $scope.date);
            if (isNaN(date)) {
                for (var i = 0; i < altInputFormats.length; i++) {
                    date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
                    if (!isNaN(date)) {
                        return date;
                    }
                }
            }
            return date;
        }
        function parseDate(viewValue) {
            if (angular.isNumber(viewValue)) {
                viewValue = new Date(viewValue);
            }
            if (!viewValue) {
                return null;
            }
            if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                return viewValue;
            }
            if (angular.isString(viewValue)) {
                var date = parseDateString(viewValue);
                if (!isNaN(date)) {
                    return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
                }
            }
            return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
        }
        function validator(modelValue, viewValue) {
            var value = modelValue || viewValue;
            if (!$attrs.ngRequired && !value) {
                return true;
            }
            if (angular.isNumber(value)) {
                value = new Date(value);
            }
            if (!value) {
                return true;
            }
            if (angular.isDate(value) && !isNaN(value)) {
                return true;
            }
            if (angular.isString(value)) {
                return !isNaN(parseDateString(value));
            }
            return false;
        }
        function documentClickBind(event) {
            if (!$scope.isOpen && $scope.disabled) {
                return;
            }
            var popup = $popup[0];
            var dpContainsTarget = $element[0].contains(event.target);
            var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
            if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
                $scope.$apply(function () {
                    $scope.isOpen = false;
                });
            }
        }
        function inputKeydownBind(evt) {
            if (evt.which === 27 && $scope.isOpen) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.$apply(function () {
                    $scope.isOpen = false;
                });
                $element[0].focus();
            }
            else if (evt.which === 40 && !$scope.isOpen) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.$apply(function () {
                    $scope.isOpen = true;
                });
            }
        }
        function positionPopup() {
            if ($scope.isOpen) {
                var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
                var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                var position = $position.positionElements($element, dpElement, placement, appendToBody);
                dpElement.css({ top: position.top + 'px', left: position.left + 'px' });
                if (dpElement.hasClass('uib-position-measure')) {
                    dpElement.removeClass('uib-position-measure');
                }
            }
        }
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = angular.isObject(ngModelCtrl.$options) ?
                    ngModelCtrl.$options :
                    {
                        timezone: null
                    };
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                ngModelOptions = ngModelCtrl.$options;
            }
            return ngModelOptions;
        }
        $scope.$on('uib:datepicker.mode', function () {
            $timeout(positionPopup, 0, false);
        });
    }])
    .directive('uibDatepickerPopup', function () {
    return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
            datepickerOptions: '=?',
            isOpen: '=?',
            currentText: '@',
            clearText: '@',
            closeText: '@'
        },
        link: function (scope, element, attrs, ctrls) {
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
})
    .directive('uibDatepickerPopupWrap', function () {
    return {
        restrict: 'A',
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
        }
    };
});
angular.module('ui.bootstrap.debounce', [])
    .factory('$$debounce', ['$timeout', function ($timeout) {
        return function (callback, debounceTime) {
            var timeoutPromise;
            return function () {
                var self = this;
                var args = Array.prototype.slice.call(arguments);
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }
                timeoutPromise = $timeout(function () {
                    callback.apply(self, args);
                }, debounceTime);
            };
        };
    }]);
angular.module('ui.bootstrap.multiMap', [])
    .factory('$$multiMap', function () {
    return {
        createNew: function () {
            var map = {};
            return {
                entries: function () {
                    return Object.keys(map).map(function (key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function (key) {
                    return map[key];
                },
                hasKey: function (key) {
                    return !!map[key];
                },
                keys: function () {
                    return Object.keys(map);
                },
                put: function (key, value) {
                    if (!map[key]) {
                        map[key] = [];
                    }
                    map[key].push(value);
                },
                remove: function (key, value) {
                    var values = map[key];
                    if (!values) {
                        return;
                    }
                    var idx = values.indexOf(value);
                    if (idx !== -1) {
                        values.splice(idx, 1);
                    }
                    if (!values.length) {
                        delete map[key];
                    }
                }
            };
        }
    };
});
angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])
    .constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
})
    .service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function ($document, $rootScope, $$multiMap) {
        var openScope = null;
        var openedContainers = $$multiMap.createNew();
        this.isOnlyOpen = function (dropdownScope, appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openDropdown = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }
                    return toClose;
                }, {});
                if (openDropdown) {
                    return openedDropdowns.length === 1;
                }
            }
            return false;
        };
        this.open = function (dropdownScope, element, appendTo) {
            if (!openScope) {
                $document.on('click', closeDropdown);
            }
            if (openScope && openScope !== dropdownScope) {
                openScope.isOpen = false;
            }
            openScope = dropdownScope;
            if (!appendTo) {
                return;
            }
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openedScopes = openedDropdowns.map(function (dropdown) {
                    return dropdown.scope;
                });
                if (openedScopes.indexOf(dropdownScope) === -1) {
                    openedContainers.put(appendTo, {
                        scope: dropdownScope
                    });
                }
            }
            else {
                openedContainers.put(appendTo, {
                    scope: dropdownScope
                });
            }
        };
        this.close = function (dropdownScope, element, appendTo) {
            if (openScope === dropdownScope) {
                $document.off('click', closeDropdown);
                $document.off('keydown', this.keybindFilter);
                openScope = null;
            }
            if (!appendTo) {
                return;
            }
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var dropdownToClose = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }
                    return toClose;
                }, {});
                if (dropdownToClose) {
                    openedContainers.remove(appendTo, dropdownToClose);
                }
            }
        };
        var closeDropdown = function (evt) {
            if (!openScope || !openScope.isOpen) {
                return;
            }
            if (evt && openScope.getAutoClose() === 'disabled') {
                return;
            }
            if (evt && evt.which === 3) {
                return;
            }
            var toggleElement = openScope.getToggleElement();
            if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
                return;
            }
            var dropdownElement = openScope.getDropdownElement();
            if (evt && openScope.getAutoClose() === 'outsideClick' &&
                dropdownElement && dropdownElement[0].contains(evt.target)) {
                return;
            }
            openScope.focusToggleElement();
            openScope.isOpen = false;
            if (!$rootScope.$$phase) {
                openScope.$apply();
            }
        };
        this.keybindFilter = function (evt) {
            if (!openScope) {
                return;
            }
            var dropdownElement = openScope.getDropdownElement();
            var toggleElement = openScope.getToggleElement();
            var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
            var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            if (evt.which === 27) {
                evt.stopPropagation();
                openScope.focusToggleElement();
                closeDropdown();
            }
            else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
                evt.preventDefault();
                evt.stopPropagation();
                openScope.focusDropdownEntry(evt.which);
            }
        };
    }])
    .controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
        var self = this, scope = $scope.$new(), templateScope, appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, getIsOpen, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, keynavEnabled = false, selectedOption = null, body = $document.find('body');
        $element.addClass('dropdown');
        this.init = function () {
            if ($attrs.isOpen) {
                getIsOpen = $parse($attrs.isOpen);
                setIsOpen = getIsOpen.assign;
                $scope.$watch(getIsOpen, function (value) {
                    scope.isOpen = !!value;
                });
            }
            keynavEnabled = angular.isDefined($attrs.keyboardNav);
        };
        this.toggle = function (open) {
            scope.isOpen = arguments.length ? !!open : !scope.isOpen;
            if (angular.isFunction(setIsOpen)) {
                setIsOpen(scope, scope.isOpen);
            }
            return scope.isOpen;
        };
        this.isOpen = function () {
            return scope.isOpen;
        };
        scope.getToggleElement = function () {
            return self.toggleElement;
        };
        scope.getAutoClose = function () {
            return $attrs.autoClose || 'always';
        };
        scope.getElement = function () {
            return $element;
        };
        scope.isKeynavEnabled = function () {
            return keynavEnabled;
        };
        scope.focusDropdownEntry = function (keyCode) {
            var elems = self.dropdownMenu ?
                angular.element(self.dropdownMenu).find('a') :
                $element.find('ul').eq(0).find('a');
            switch (keyCode) {
                case 40: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = 0;
                    }
                    else {
                        self.selectedOption = self.selectedOption === elems.length - 1 ?
                            self.selectedOption :
                            self.selectedOption + 1;
                    }
                    break;
                }
                case 38: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = elems.length - 1;
                    }
                    else {
                        self.selectedOption = self.selectedOption === 0 ?
                            0 : self.selectedOption - 1;
                    }
                    break;
                }
            }
            elems[self.selectedOption].focus();
        };
        scope.getDropdownElement = function () {
            return self.dropdownMenu;
        };
        scope.focusToggleElement = function () {
            if (self.toggleElement) {
                self.toggleElement[0].focus();
            }
        };
        function removeDropdownMenu() {
            $element.append(self.dropdownMenu);
        }
        scope.$watch('isOpen', function (isOpen, wasOpen) {
            var appendTo = null, appendToBody = false;
            if (angular.isDefined($attrs.dropdownAppendTo)) {
                var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
                if (appendToEl) {
                    appendTo = angular.element(appendToEl);
                }
            }
            if (angular.isDefined($attrs.dropdownAppendToBody)) {
                var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
                if (appendToBodyValue !== false) {
                    appendToBody = true;
                }
            }
            if (appendToBody && !appendTo) {
                appendTo = body;
            }
            if (appendTo && self.dropdownMenu) {
                if (isOpen) {
                    appendTo.append(self.dropdownMenu);
                    $element.on('$destroy', removeDropdownMenu);
                }
                else {
                    $element.off('$destroy', removeDropdownMenu);
                    removeDropdownMenu();
                }
            }
            if (appendTo && self.dropdownMenu) {
                var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true), css, rightalign, scrollbarPadding, scrollbarWidth = 0;
                css = {
                    top: pos.top + 'px',
                    display: isOpen ? 'block' : 'none'
                };
                rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
                if (!rightalign) {
                    css.left = pos.left + 'px';
                    css.right = 'auto';
                }
                else {
                    css.left = 'auto';
                    scrollbarPadding = $position.scrollbarPadding(appendTo);
                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        scrollbarWidth = scrollbarPadding.scrollbarWidth;
                    }
                    css.right = window.innerWidth - scrollbarWidth -
                        (pos.left + $element.prop('offsetWidth')) + 'px';
                }
                if (!appendToBody) {
                    var appendOffset = $position.offset(appendTo);
                    css.top = pos.top - appendOffset.top + 'px';
                    if (!rightalign) {
                        css.left = pos.left - appendOffset.left + 'px';
                    }
                    else {
                        css.right = window.innerWidth -
                            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
                    }
                }
                self.dropdownMenu.css(css);
            }
            var openContainer = appendTo ? appendTo : $element;
            var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
            var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
            var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);
            if (hasOpenClass === !isOpen) {
                var toggleClass;
                if (appendTo) {
                    toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
                }
                else {
                    toggleClass = isOpen ? 'addClass' : 'removeClass';
                }
                $animate[toggleClass](openContainer, dropdownOpenClass).then(function () {
                    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                        toggleInvoker($scope, { open: !!isOpen });
                    }
                });
            }
            if (isOpen) {
                if (self.dropdownMenuTemplateUrl) {
                    $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
                        templateScope = scope.$new();
                        $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                            var newEl = dropdownElement;
                            self.dropdownMenu.replaceWith(newEl);
                            self.dropdownMenu = newEl;
                            $document.on('keydown', uibDropdownService.keybindFilter);
                        });
                    });
                }
                else {
                    $document.on('keydown', uibDropdownService.keybindFilter);
                }
                scope.focusToggleElement();
                uibDropdownService.open(scope, $element, appendTo);
            }
            else {
                uibDropdownService.close(scope, $element, appendTo);
                if (self.dropdownMenuTemplateUrl) {
                    if (templateScope) {
                        templateScope.$destroy();
                    }
                    var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                    self.dropdownMenu.replaceWith(newEl);
                    self.dropdownMenu = newEl;
                }
                self.selectedOption = null;
            }
            if (angular.isFunction(setIsOpen)) {
                setIsOpen($scope, isOpen);
            }
        });
    }])
    .directive('uibDropdown', function () {
    return {
        controller: 'UibDropdownController',
        link: function (scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
})
    .directive('uibDropdownMenu', function () {
    return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
                return;
            }
            element.addClass('dropdown-menu');
            var tplUrl = attrs.templateUrl;
            if (tplUrl) {
                dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
            }
            if (!dropdownCtrl.dropdownMenu) {
                dropdownCtrl.dropdownMenu = element;
            }
        }
    };
})
    .directive('uibDropdownToggle', function () {
    return {
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return;
            }
            element.addClass('dropdown-toggle');
            dropdownCtrl.toggleElement = element;
            var toggleDropdown = function (event) {
                event.preventDefault();
                if (!element.hasClass('disabled') && !attrs.disabled) {
                    scope.$apply(function () {
                        dropdownCtrl.toggle();
                    });
                }
            };
            element.on('click', toggleDropdown);
            element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
            scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                element.attr('aria-expanded', !!isOpen);
            });
            scope.$on('$destroy', function () {
                element.off('click', toggleDropdown);
            });
        }
    };
});
angular.module('ui.bootstrap.stackedMap', [])
    .factory('$$stackedMap', function () {
    return {
        createNew: function () {
            var stack = [];
            return {
                add: function (key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function (key) {
                    for (var i = 0; i < stack.length; i++) {
                        if (key === stack[i].key) {
                            return stack[i];
                        }
                    }
                },
                keys: function () {
                    var keys = [];
                    for (var i = 0; i < stack.length; i++) {
                        keys.push(stack[i].key);
                    }
                    return keys;
                },
                top: function () {
                    return stack[stack.length - 1];
                },
                remove: function (key) {
                    var idx = -1;
                    for (var i = 0; i < stack.length; i++) {
                        if (key === stack[i].key) {
                            idx = i;
                            break;
                        }
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function () {
                    return stack.pop();
                },
                length: function () {
                    return stack.length;
                }
            };
        }
    };
});
angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
    .provider('$uibResolve', function () {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function (resolver) {
        this.resolver = resolver;
    };
    this.$get = ['$injector', '$q', function ($injector, $q) {
            var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
            return {
                resolve: function (invocables, locals, parent, self) {
                    if (resolver) {
                        return resolver.resolve(invocables, locals, parent, self);
                    }
                    var promises = [];
                    angular.forEach(invocables, function (value) {
                        if (angular.isFunction(value) || angular.isArray(value)) {
                            promises.push($q.resolve($injector.invoke(value)));
                        }
                        else if (angular.isString(value)) {
                            promises.push($q.resolve($injector.get(value)));
                        }
                        else {
                            promises.push($q.resolve(value));
                        }
                    });
                    return $q.all(promises).then(function (resolves) {
                        var resolveObj = {};
                        var resolveIter = 0;
                        angular.forEach(invocables, function (value, key) {
                            resolveObj[key] = resolves[resolveIter++];
                        });
                        return resolveObj;
                    });
                }
            };
        }];
})
    .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
    function ($animate, $injector, $modalStack) {
        return {
            restrict: 'A',
            compile: function (tElement, tAttrs) {
                tElement.addClass(tAttrs.backdropClass);
                return linkFn;
            }
        };
        function linkFn(scope, element, attrs) {
            if (attrs.modalInClass) {
                $animate.addClass(element, attrs.modalInClass);
                scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                    var done = setIsAsync();
                    if (scope.modalOptions.animation) {
                        $animate.removeClass(element, attrs.modalInClass).then(done);
                    }
                    else {
                        done();
                    }
                });
            }
        }
    }])
    .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
    function ($modalStack, $q, $animateCss, $document) {
        return {
            scope: {
                index: '@'
            },
            restrict: 'A',
            transclude: true,
            templateUrl: function (tElement, tAttrs) {
                return tAttrs.templateUrl || 'uib/template/modal/window.html';
            },
            link: function (scope, element, attrs) {
                element.addClass(attrs.windowTopClass || '');
                scope.size = attrs.size;
                scope.close = function (evt) {
                    var modal = $modalStack.getTop();
                    if (modal && modal.value.backdrop &&
                        modal.value.backdrop !== 'static' &&
                        evt.target === evt.currentTarget) {
                        evt.preventDefault();
                        evt.stopPropagation();
                        $modalStack.dismiss(modal.key, 'backdrop click');
                    }
                };
                element.on('click', scope.close);
                scope.$isRendered = true;
                var modalRenderDeferObj = $q.defer();
                scope.$$postDigest(function () {
                    modalRenderDeferObj.resolve();
                });
                modalRenderDeferObj.promise.then(function () {
                    var animationPromise = null;
                    if (attrs.modalInClass) {
                        animationPromise = $animateCss(element, {
                            addClass: attrs.modalInClass
                        }).start();
                        scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                            var done = setIsAsync();
                            $animateCss(element, {
                                removeClass: attrs.modalInClass
                            }).start().then(done);
                        });
                    }
                    $q.when(animationPromise).then(function () {
                        var modal = $modalStack.getTop();
                        if (modal) {
                            $modalStack.modalRendered(modal.key);
                        }
                        if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                            var inputWithAutofocus = element[0].querySelector('[autofocus]');
                            if (inputWithAutofocus) {
                                inputWithAutofocus.focus();
                            }
                            else {
                                element[0].focus();
                            }
                        }
                    });
                });
            }
        };
    }])
    .directive('uibModalAnimationClass', function () {
    return {
        compile: function (tElement, tAttrs) {
            if (tAttrs.modalAnimation) {
                tElement.addClass(tAttrs.uibModalAnimationClass);
            }
        }
    };
})
    .directive('uibModalTransclude', ['$animate', function ($animate) {
        return {
            link: function (scope, element, attrs, controller, transclude) {
                transclude(scope.$parent, function (clone) {
                    element.empty();
                    $animate.enter(clone, element);
                });
            }
        };
    }])
    .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
        var OPENED_MODAL_CLASS = 'modal-open';
        var backdropDomEl, backdropScope;
        var openedWindows = $$stackedMap.createNew();
        var openedClasses = $$multiMap.createNew();
        var $modalStack = {
            NOW_CLOSING_EVENT: 'modal.stack.now-closing'
        };
        var topModalIndex = 0;
        var previousTopOpenedModal = null;
        var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';
        var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
            'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
            'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
        var scrollbarPadding;
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name) {
            var separator = '-';
            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }
        function isVisible(element) {
            return !!(element.offsetWidth ||
                element.offsetHeight ||
                element.getClientRects().length);
        }
        function backdropIndex() {
            var topBackdropIndex = -1;
            var opened = openedWindows.keys();
            for (var i = 0; i < opened.length; i++) {
                if (openedWindows.get(opened[i]).value.backdrop) {
                    topBackdropIndex = i;
                }
            }
            if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
                topBackdropIndex = topModalIndex;
            }
            return topBackdropIndex;
        }
        $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
            if (backdropScope) {
                backdropScope.index = newBackdropIndex;
            }
        });
        function removeModalWindow(modalInstance, elementToReceiveFocus) {
            var modalWindow = openedWindows.get(modalInstance).value;
            var appendToElement = modalWindow.appendTo;
            openedWindows.remove(modalInstance);
            previousTopOpenedModal = openedWindows.top();
            if (previousTopOpenedModal) {
                topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
            }
            removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
                var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
                openedClasses.remove(modalBodyClass, modalInstance);
                var areAnyOpen = openedClasses.hasKey(modalBodyClass);
                appendToElement.toggleClass(modalBodyClass, areAnyOpen);
                if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                    if (scrollbarPadding.originalRight) {
                        appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
                    }
                    else {
                        appendToElement.css({ paddingRight: '' });
                    }
                    scrollbarPadding = null;
                }
                toggleTopWindowClass(true);
            }, modalWindow.closedDeferred);
            checkRemoveBackdrop();
            if (elementToReceiveFocus && elementToReceiveFocus.focus) {
                elementToReceiveFocus.focus();
            }
            else if (appendToElement.focus) {
                appendToElement.focus();
            }
        }
        function toggleTopWindowClass(toggleSwitch) {
            var modalWindow;
            if (openedWindows.length() > 0) {
                modalWindow = openedWindows.top().value;
                modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
            }
        }
        function checkRemoveBackdrop() {
            if (backdropDomEl && backdropIndex() === -1) {
                var backdropScopeRef = backdropScope;
                removeAfterAnimate(backdropDomEl, backdropScope, function () {
                    backdropScopeRef = null;
                });
                backdropDomEl = undefined;
                backdropScope = undefined;
            }
        }
        function removeAfterAnimate(domEl, scope, done, closedDeferred) {
            var asyncDeferred;
            var asyncPromise = null;
            var setIsAsync = function () {
                if (!asyncDeferred) {
                    asyncDeferred = $q.defer();
                    asyncPromise = asyncDeferred.promise;
                }
                return function asyncDone() {
                    asyncDeferred.resolve();
                };
            };
            scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
            return $q.when(asyncPromise).then(afterAnimating);
            function afterAnimating() {
                if (afterAnimating.done) {
                    return;
                }
                afterAnimating.done = true;
                $animate.leave(domEl).then(function () {
                    if (done) {
                        done();
                    }
                    domEl.remove();
                    if (closedDeferred) {
                        closedDeferred.resolve();
                    }
                });
                scope.$destroy();
            }
        }
        $document.on('keydown', keydownListener);
        $rootScope.$on('$destroy', function () {
            $document.off('keydown', keydownListener);
        });
        function keydownListener(evt) {
            if (evt.isDefaultPrevented()) {
                return evt;
            }
            var modal = openedWindows.top();
            if (modal) {
                switch (evt.which) {
                    case 27: {
                        if (modal.value.keyboard) {
                            evt.preventDefault();
                            $rootScope.$apply(function () {
                                $modalStack.dismiss(modal.key, 'escape key press');
                            });
                        }
                        break;
                    }
                    case 9: {
                        var list = $modalStack.loadFocusElementList(modal);
                        var focusChanged = false;
                        if (evt.shiftKey) {
                            if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                                focusChanged = $modalStack.focusLastFocusableElement(list);
                            }
                        }
                        else {
                            if ($modalStack.isFocusInLastItem(evt, list)) {
                                focusChanged = $modalStack.focusFirstFocusableElement(list);
                            }
                        }
                        if (focusChanged) {
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        break;
                    }
                }
            }
        }
        $modalStack.open = function (modalInstance, modal) {
            var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
            toggleTopWindowClass(false);
            previousTopOpenedModal = openedWindows.top();
            openedWindows.add(modalInstance, {
                deferred: modal.deferred,
                renderDeferred: modal.renderDeferred,
                closedDeferred: modal.closedDeferred,
                modalScope: modal.scope,
                backdrop: modal.backdrop,
                keyboard: modal.keyboard,
                openedClass: modal.openedClass,
                windowTopClass: modal.windowTopClass,
                animation: modal.animation,
                appendTo: modal.appendTo
            });
            openedClasses.put(modalBodyClass, modalInstance);
            var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
            if (currBackdropIndex >= 0 && !backdropDomEl) {
                backdropScope = $rootScope.$new(true);
                backdropScope.modalOptions = modal;
                backdropScope.index = currBackdropIndex;
                backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
                backdropDomEl.attr({
                    'class': 'modal-backdrop',
                    'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
                    'uib-modal-animation-class': 'fade',
                    'modal-in-class': 'in'
                });
                if (modal.backdropClass) {
                    backdropDomEl.addClass(modal.backdropClass);
                }
                if (modal.animation) {
                    backdropDomEl.attr('modal-animation', 'true');
                }
                $compile(backdropDomEl)(backdropScope);
                $animate.enter(backdropDomEl, appendToElement);
                if ($uibPosition.isScrollable(appendToElement)) {
                    scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
                    }
                }
            }
            var content;
            if (modal.component) {
                content = document.createElement(snake_case(modal.component.name));
                content = angular.element(content);
                content.attr({
                    resolve: '$resolve',
                    'modal-instance': '$uibModalInstance',
                    close: '$close($value)',
                    dismiss: '$dismiss($value)'
                });
            }
            else {
                content = modal.content;
            }
            topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
            var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
            angularDomEl.attr({
                'class': 'modal',
                'template-url': modal.windowTemplateUrl,
                'window-top-class': modal.windowTopClass,
                'role': 'dialog',
                'aria-labelledby': modal.ariaLabelledBy,
                'aria-describedby': modal.ariaDescribedBy,
                'size': modal.size,
                'index': topModalIndex,
                'animate': 'animate',
                'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
                'tabindex': -1,
                'uib-modal-animation-class': 'fade',
                'modal-in-class': 'in'
            }).append(content);
            if (modal.windowClass) {
                angularDomEl.addClass(modal.windowClass);
            }
            if (modal.animation) {
                angularDomEl.attr('modal-animation', 'true');
            }
            appendToElement.addClass(modalBodyClass);
            if (modal.scope) {
                modal.scope.$$topModalIndex = topModalIndex;
            }
            $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
            openedWindows.top().value.modalDomEl = angularDomEl;
            openedWindows.top().value.modalOpener = modalOpener;
            applyAriaHidden(angularDomEl);
            function applyAriaHidden(el) {
                if (!el || el[0].tagName === 'BODY') {
                    return;
                }
                getSiblings(el).forEach(function (sibling) {
                    var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true', ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);
                    if (!ariaHiddenCount) {
                        ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
                    }
                    sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
                    sibling.setAttribute('aria-hidden', 'true');
                });
                return applyAriaHidden(el.parent());
                function getSiblings(el) {
                    var children = el.parent() ? el.parent().children() : [];
                    return Array.prototype.filter.call(children, function (child) {
                        return child !== el[0];
                    });
                }
            }
        };
        function broadcastClosing(modalWindow, resultOrReason, closing) {
            return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
        }
        function unhideBackgroundElements() {
            Array.prototype.forEach.call(document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'), function (hiddenEl) {
                var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10), newHiddenCount = ariaHiddenCount - 1;
                hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);
                if (!newHiddenCount) {
                    hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
                    hiddenEl.removeAttribute('aria-hidden');
                }
            });
        }
        $modalStack.close = function (modalInstance, result) {
            var modalWindow = openedWindows.get(modalInstance);
            unhideBackgroundElements();
            if (modalWindow && broadcastClosing(modalWindow, result, true)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.resolve(result);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };
        $modalStack.dismiss = function (modalInstance, reason) {
            var modalWindow = openedWindows.get(modalInstance);
            unhideBackgroundElements();
            if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.reject(reason);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };
        $modalStack.dismissAll = function (reason) {
            var topModal = this.getTop();
            while (topModal && this.dismiss(topModal.key, reason)) {
                topModal = this.getTop();
            }
        };
        $modalStack.getTop = function () {
            return openedWindows.top();
        };
        $modalStack.modalRendered = function (modalInstance) {
            var modalWindow = openedWindows.get(modalInstance);
            if (modalWindow) {
                modalWindow.value.renderDeferred.resolve();
            }
        };
        $modalStack.focusFirstFocusableElement = function (list) {
            if (list.length > 0) {
                list[0].focus();
                return true;
            }
            return false;
        };
        $modalStack.focusLastFocusableElement = function (list) {
            if (list.length > 0) {
                list[list.length - 1].focus();
                return true;
            }
            return false;
        };
        $modalStack.isModalFocused = function (evt, modalWindow) {
            if (evt && modalWindow) {
                var modalDomEl = modalWindow.value.modalDomEl;
                if (modalDomEl && modalDomEl.length) {
                    return (evt.target || evt.srcElement) === modalDomEl[0];
                }
            }
            return false;
        };
        $modalStack.isFocusInFirstItem = function (evt, list) {
            if (list.length > 0) {
                return (evt.target || evt.srcElement) === list[0];
            }
            return false;
        };
        $modalStack.isFocusInLastItem = function (evt, list) {
            if (list.length > 0) {
                return (evt.target || evt.srcElement) === list[list.length - 1];
            }
            return false;
        };
        $modalStack.loadFocusElementList = function (modalWindow) {
            if (modalWindow) {
                var modalDomE1 = modalWindow.value.modalDomEl;
                if (modalDomE1 && modalDomE1.length) {
                    var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                    return elements ?
                        Array.prototype.filter.call(elements, function (element) {
                            return isVisible(element);
                        }) : elements;
                }
            }
        };
        return $modalStack;
    }])
    .provider('$uibModal', function () {
    var $modalProvider = {
        options: {
            animation: true,
            backdrop: true,
            keyboard: true
        },
        $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
            function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
                var $modal = {};
                function getTemplatePromise(options) {
                    return options.template ? $q.when(options.template) :
                        $templateRequest(angular.isFunction(options.templateUrl) ?
                            options.templateUrl() : options.templateUrl);
                }
                var promiseChain = null;
                $modal.getPromiseChain = function () {
                    return promiseChain;
                };
                $modal.open = function (modalOptions) {
                    var modalResultDeferred = $q.defer();
                    var modalOpenedDeferred = $q.defer();
                    var modalClosedDeferred = $q.defer();
                    var modalRenderDeferred = $q.defer();
                    var modalInstance = {
                        result: modalResultDeferred.promise,
                        opened: modalOpenedDeferred.promise,
                        closed: modalClosedDeferred.promise,
                        rendered: modalRenderDeferred.promise,
                        close: function (result) {
                            return $modalStack.close(modalInstance, result);
                        },
                        dismiss: function (reason) {
                            return $modalStack.dismiss(modalInstance, reason);
                        }
                    };
                    modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                    modalOptions.resolve = modalOptions.resolve || {};
                    modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
                    if (!modalOptions.appendTo.length) {
                        throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
                    }
                    if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
                        throw new Error('One of component or template or templateUrl options is required.');
                    }
                    var templateAndResolvePromise;
                    if (modalOptions.component) {
                        templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
                    }
                    else {
                        templateAndResolvePromise =
                            $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
                    }
                    function resolveWithTemplate() {
                        return templateAndResolvePromise;
                    }
                    var samePromise;
                    samePromise = promiseChain = $q.all([promiseChain])
                        .then(resolveWithTemplate, resolveWithTemplate)
                        .then(function resolveSuccess(tplAndVars) {
                        var providedScope = modalOptions.scope || $rootScope;
                        var modalScope = providedScope.$new();
                        modalScope.$close = modalInstance.close;
                        modalScope.$dismiss = modalInstance.dismiss;
                        modalScope.$on('$destroy', function () {
                            if (!modalScope.$$uibDestructionScheduled) {
                                modalScope.$dismiss('$uibUnscheduledDestruction');
                            }
                        });
                        var modal = {
                            scope: modalScope,
                            deferred: modalResultDeferred,
                            renderDeferred: modalRenderDeferred,
                            closedDeferred: modalClosedDeferred,
                            animation: modalOptions.animation,
                            backdrop: modalOptions.backdrop,
                            keyboard: modalOptions.keyboard,
                            backdropClass: modalOptions.backdropClass,
                            windowTopClass: modalOptions.windowTopClass,
                            windowClass: modalOptions.windowClass,
                            windowTemplateUrl: modalOptions.windowTemplateUrl,
                            ariaLabelledBy: modalOptions.ariaLabelledBy,
                            ariaDescribedBy: modalOptions.ariaDescribedBy,
                            size: modalOptions.size,
                            openedClass: modalOptions.openedClass,
                            appendTo: modalOptions.appendTo
                        };
                        var component = {};
                        var ctrlInstance, ctrlInstantiate, ctrlLocals = {};
                        if (modalOptions.component) {
                            constructLocals(component, false, true, false);
                            component.name = modalOptions.component;
                            modal.component = component;
                        }
                        else if (modalOptions.controller) {
                            constructLocals(ctrlLocals, true, false, true);
                            ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                            if (modalOptions.controllerAs && modalOptions.bindToController) {
                                ctrlInstance = ctrlInstantiate.instance;
                                ctrlInstance.$close = modalScope.$close;
                                ctrlInstance.$dismiss = modalScope.$dismiss;
                                angular.extend(ctrlInstance, {
                                    $resolve: ctrlLocals.$scope.$resolve
                                }, providedScope);
                            }
                            ctrlInstance = ctrlInstantiate();
                            if (angular.isFunction(ctrlInstance.$onInit)) {
                                ctrlInstance.$onInit();
                            }
                        }
                        if (!modalOptions.component) {
                            modal.content = tplAndVars[0];
                        }
                        $modalStack.open(modalInstance, modal);
                        modalOpenedDeferred.resolve(true);
                        function constructLocals(obj, template, instanceOnScope, injectable) {
                            obj.$scope = modalScope;
                            obj.$scope.$resolve = {};
                            if (instanceOnScope) {
                                obj.$scope.$uibModalInstance = modalInstance;
                            }
                            else {
                                obj.$uibModalInstance = modalInstance;
                            }
                            var resolves = template ? tplAndVars[1] : tplAndVars;
                            angular.forEach(resolves, function (value, key) {
                                if (injectable) {
                                    obj[key] = value;
                                }
                                obj.$scope.$resolve[key] = value;
                            });
                        }
                    }, function resolveError(reason) {
                        modalOpenedDeferred.reject(reason);
                        modalResultDeferred.reject(reason);
                    })['finally'](function () {
                        if (promiseChain === samePromise) {
                            promiseChain = null;
                        }
                    });
                    return modalInstance;
                };
                return $modal;
            }
        ]
    };
    return $modalProvider;
});
angular.module('ui.bootstrap.paging', [])
    .factory('uibPaging', ['$parse', function ($parse) {
        return {
            create: function (ctrl, $scope, $attrs) {
                ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
                ctrl.ngModelCtrl = { $setViewValue: angular.noop };
                ctrl._watchers = [];
                ctrl.init = function (ngModelCtrl, config) {
                    ctrl.ngModelCtrl = ngModelCtrl;
                    ctrl.config = config;
                    ngModelCtrl.$render = function () {
                        ctrl.render();
                    };
                    if ($attrs.itemsPerPage) {
                        ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                            ctrl.itemsPerPage = parseInt(value, 10);
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }));
                    }
                    else {
                        ctrl.itemsPerPage = config.itemsPerPage;
                    }
                    $scope.$watch('totalItems', function (newTotal, oldTotal) {
                        if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }
                    });
                };
                ctrl.calculateTotalPages = function () {
                    var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                    return Math.max(totalPages || 0, 1);
                };
                ctrl.render = function () {
                    $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
                };
                $scope.selectPage = function (page, evt) {
                    if (evt) {
                        evt.preventDefault();
                    }
                    var clickAllowed = !$scope.ngDisabled || !evt;
                    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
                        if (evt && evt.target) {
                            evt.target.blur();
                        }
                        ctrl.ngModelCtrl.$setViewValue(page);
                        ctrl.ngModelCtrl.$render();
                    }
                };
                $scope.getText = function (key) {
                    return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
                };
                $scope.noPrevious = function () {
                    return $scope.page === 1;
                };
                $scope.noNext = function () {
                    return $scope.page === $scope.totalPages;
                };
                ctrl.updatePage = function () {
                    ctrl.setNumPages($scope.$parent, $scope.totalPages);
                    if ($scope.page > $scope.totalPages) {
                        $scope.selectPage($scope.totalPages);
                    }
                    else {
                        ctrl.ngModelCtrl.$render();
                    }
                };
                $scope.$on('$destroy', function () {
                    while (ctrl._watchers.length) {
                        ctrl._watchers.shift()();
                    }
                });
            }
        };
    }]);
angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
    .controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
        $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
        uibPaging.create(this, $scope, $attrs);
    }])
    .constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: '« Previous',
    nextText: 'Next »',
    align: true
})
    .directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
        return {
            scope: {
                totalItems: '=',
                previousText: '@',
                nextText: '@',
                ngDisabled: '='
            },
            require: ['uibPager', '?ngModel'],
            restrict: 'A',
            controller: 'UibPagerController',
            controllerAs: 'pager',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pager/pager.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pager');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) {
                    return;
                }
                paginationCtrl.init(ngModelCtrl, uibPagerConfig);
            }
        };
    }]);
angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
    .controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
        var ctrl = this;
        var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) { return $scope.$parent.$eval($attrs.pageLabel, { $page: idx }); } : angular.identity;
        $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
        $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
        $attrs.$set('role', 'menu');
        uibPaging.create(this, $scope, $attrs);
        if ($attrs.maxSize) {
            ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
                maxSize = parseInt(value, 10);
                ctrl.render();
            }));
        }
        function makePage(number, text, isActive) {
            return {
                number: number,
                text: text,
                active: isActive
            };
        }
        function getPages(currentPage, totalPages) {
            var pages = [];
            var startPage = 1, endPage = totalPages;
            var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
            if (isMaxSized) {
                if (rotate) {
                    startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                    endPage = startPage + maxSize - 1;
                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = endPage - maxSize + 1;
                    }
                }
                else {
                    startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
                    endPage = Math.min(startPage + maxSize - 1, totalPages);
                }
            }
            for (var number = startPage; number <= endPage; number++) {
                var page = makePage(number, pageLabel(number), number === currentPage);
                pages.push(page);
            }
            if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
                if (startPage > 1) {
                    if (!boundaryLinkNumbers || startPage > 3) {
                        var previousPageSet = makePage(startPage - 1, '...', false);
                        pages.unshift(previousPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (startPage === 3) {
                            var secondPageLink = makePage(2, '2', false);
                            pages.unshift(secondPageLink);
                        }
                        var firstPageLink = makePage(1, '1', false);
                        pages.unshift(firstPageLink);
                    }
                }
                if (endPage < totalPages) {
                    if (!boundaryLinkNumbers || endPage < totalPages - 2) {
                        var nextPageSet = makePage(endPage + 1, '...', false);
                        pages.push(nextPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (endPage === totalPages - 2) {
                            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                            pages.push(secondToLastPageLink);
                        }
                        var lastPageLink = makePage(totalPages, totalPages, false);
                        pages.push(lastPageLink);
                    }
                }
            }
            return pages;
        }
        var originalRender = this.render;
        this.render = function () {
            originalRender();
            if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
                $scope.pages = getPages($scope.page, $scope.totalPages);
            }
        };
    }])
    .constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
})
    .directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
        return {
            scope: {
                totalItems: '=',
                firstText: '@',
                previousText: '@',
                nextText: '@',
                lastText: '@',
                ngDisabled: '='
            },
            require: ['uibPagination', '?ngModel'],
            restrict: 'A',
            controller: 'UibPaginationController',
            controllerAs: 'pagination',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pagination/pagination.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pagination');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) {
                    return;
                }
                paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
            }
        };
    }]);
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])
    .provider('$uibTooltip', function () {
    var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
    };
    var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
    };
    var globalOptions = {};
    this.options = function (value) {
        angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function (letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
            var openedTooltips = $$stackedMap.createNew();
            $document.on('keyup', keypressListener);
            $rootScope.$on('$destroy', function () {
                $document.off('keyup', keypressListener);
            });
            function keypressListener(e) {
                if (e.which === 27) {
                    var last = openedTooltips.top();
                    if (last) {
                        last.value.close();
                        last = null;
                    }
                }
            }
            return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
                options = angular.extend({}, defaultOptions, globalOptions, options);
                function getTriggers(trigger) {
                    var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
                    var hide = show.map(function (trigger) {
                        return triggerMap[trigger] || trigger;
                    });
                    return {
                        show: show,
                        hide: hide
                    };
                }
                var directiveName = snake_case(ttType);
                var startSym = $interpolate.startSymbol();
                var endSym = $interpolate.endSymbol();
                var template = '<div ' + directiveName + '-popup ' +
                    'uib-title="' + startSym + 'title' + endSym + '" ' +
                    (options.useContentExp ?
                        'content-exp="contentExp()" ' :
                        'content="' + startSym + 'content' + endSym + '" ') +
                    'origin-scope="origScope" ' +
                    'class="uib-position-measure ' + prefix + '" ' +
                    'tooltip-animation-class="fade"' +
                    'uib-tooltip-classes ' +
                    'ng-class="{ in: isOpen }" ' +
                    '>' +
                    '</div>';
                return {
                    compile: function (tElem, tAttrs) {
                        var tooltipLinker = $compile(template);
                        return function link(scope, element, attrs, tooltipCtrl) {
                            var tooltip;
                            var tooltipLinkedScope;
                            var transitionTimeout;
                            var showTimeout;
                            var hideTimeout;
                            var positionTimeout;
                            var adjustmentTimeout;
                            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                            var triggers = getTriggers(undefined);
                            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                            var ttScope = scope.$new(true);
                            var repositionScheduled = false;
                            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                            var observers = [];
                            var lastPlacement;
                            var positionTooltip = function () {
                                if (!tooltip || !tooltip.html()) {
                                    return;
                                }
                                if (!positionTimeout) {
                                    positionTimeout = $timeout(function () {
                                        var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                        var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                        var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                        tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                                        var placementClasses = ttPosition.placement.split('-');
                                        if (!tooltip.hasClass(placementClasses[0])) {
                                            tooltip.removeClass(lastPlacement.split('-')[0]);
                                            tooltip.addClass(placementClasses[0]);
                                        }
                                        if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                                            tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                                            tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                                        }
                                        adjustmentTimeout = $timeout(function () {
                                            var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                            var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                            if (adjustment) {
                                                tooltip.css(adjustment);
                                            }
                                            adjustmentTimeout = null;
                                        }, 0, false);
                                        if (tooltip.hasClass('uib-position-measure')) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                            tooltip.removeClass('uib-position-measure');
                                        }
                                        else if (lastPlacement !== ttPosition.placement) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                        }
                                        lastPlacement = ttPosition.placement;
                                        positionTimeout = null;
                                    }, 0, false);
                                }
                            };
                            ttScope.origScope = scope;
                            ttScope.isOpen = false;
                            function toggleTooltipBind() {
                                if (!ttScope.isOpen) {
                                    showTooltipBind();
                                }
                                else {
                                    hideTooltipBind();
                                }
                            }
                            function showTooltipBind() {
                                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                                    return;
                                }
                                cancelHide();
                                prepareTooltip();
                                if (ttScope.popupDelay) {
                                    if (!showTimeout) {
                                        showTimeout = $timeout(show, ttScope.popupDelay, false);
                                    }
                                }
                                else {
                                    show();
                                }
                            }
                            function hideTooltipBind() {
                                cancelShow();
                                if (ttScope.popupCloseDelay) {
                                    if (!hideTimeout) {
                                        hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                                    }
                                }
                                else {
                                    hide();
                                }
                            }
                            function show() {
                                cancelShow();
                                cancelHide();
                                if (!ttScope.content) {
                                    return angular.noop;
                                }
                                createTooltip();
                                ttScope.$evalAsync(function () {
                                    ttScope.isOpen = true;
                                    assignIsOpen(true);
                                    positionTooltip();
                                });
                            }
                            function cancelShow() {
                                if (showTimeout) {
                                    $timeout.cancel(showTimeout);
                                    showTimeout = null;
                                }
                                if (positionTimeout) {
                                    $timeout.cancel(positionTimeout);
                                    positionTimeout = null;
                                }
                            }
                            function hide() {
                                if (!ttScope) {
                                    return;
                                }
                                ttScope.$evalAsync(function () {
                                    if (ttScope) {
                                        ttScope.isOpen = false;
                                        assignIsOpen(false);
                                        if (ttScope.animation) {
                                            if (!transitionTimeout) {
                                                transitionTimeout = $timeout(removeTooltip, 150, false);
                                            }
                                        }
                                        else {
                                            removeTooltip();
                                        }
                                    }
                                });
                            }
                            function cancelHide() {
                                if (hideTimeout) {
                                    $timeout.cancel(hideTimeout);
                                    hideTimeout = null;
                                }
                                if (transitionTimeout) {
                                    $timeout.cancel(transitionTimeout);
                                    transitionTimeout = null;
                                }
                            }
                            function createTooltip() {
                                if (tooltip) {
                                    return;
                                }
                                tooltipLinkedScope = ttScope.$new();
                                tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                                    if (appendToBody) {
                                        $document.find('body').append(tooltip);
                                    }
                                    else {
                                        element.after(tooltip);
                                    }
                                });
                                openedTooltips.add(ttScope, {
                                    close: hide
                                });
                                prepObservers();
                            }
                            function removeTooltip() {
                                cancelShow();
                                cancelHide();
                                unregisterObservers();
                                if (tooltip) {
                                    tooltip.remove();
                                    tooltip = null;
                                    if (adjustmentTimeout) {
                                        $timeout.cancel(adjustmentTimeout);
                                    }
                                }
                                openedTooltips.remove(ttScope);
                                if (tooltipLinkedScope) {
                                    tooltipLinkedScope.$destroy();
                                    tooltipLinkedScope = null;
                                }
                            }
                            function prepareTooltip() {
                                ttScope.title = attrs[prefix + 'Title'];
                                if (contentParse) {
                                    ttScope.content = contentParse(scope);
                                }
                                else {
                                    ttScope.content = attrs[ttType];
                                }
                                ttScope.popupClass = attrs[prefix + 'Class'];
                                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                                var placement = $position.parsePlacement(ttScope.placement);
                                lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                            }
                            function assignIsOpen(isOpen) {
                                if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                                    isOpenParse.assign(scope, isOpen);
                                }
                            }
                            ttScope.contentExp = function () {
                                return ttScope.content;
                            };
                            attrs.$observe('disabled', function (val) {
                                if (val) {
                                    cancelShow();
                                }
                                if (val && ttScope.isOpen) {
                                    hide();
                                }
                            });
                            if (isOpenParse) {
                                scope.$watch(isOpenParse, function (val) {
                                    if (ttScope && !val === ttScope.isOpen) {
                                        toggleTooltipBind();
                                    }
                                });
                            }
                            function prepObservers() {
                                observers.length = 0;
                                if (contentParse) {
                                    observers.push(scope.$watch(contentParse, function (val) {
                                        ttScope.content = val;
                                        if (!val && ttScope.isOpen) {
                                            hide();
                                        }
                                    }));
                                    observers.push(tooltipLinkedScope.$watch(function () {
                                        if (!repositionScheduled) {
                                            repositionScheduled = true;
                                            tooltipLinkedScope.$$postDigest(function () {
                                                repositionScheduled = false;
                                                if (ttScope && ttScope.isOpen) {
                                                    positionTooltip();
                                                }
                                            });
                                        }
                                    }));
                                }
                                else {
                                    observers.push(attrs.$observe(ttType, function (val) {
                                        ttScope.content = val;
                                        if (!val && ttScope.isOpen) {
                                            hide();
                                        }
                                        else {
                                            positionTooltip();
                                        }
                                    }));
                                }
                                observers.push(attrs.$observe(prefix + 'Title', function (val) {
                                    ttScope.title = val;
                                    if (ttScope.isOpen) {
                                        positionTooltip();
                                    }
                                }));
                                observers.push(attrs.$observe(prefix + 'Placement', function (val) {
                                    ttScope.placement = val ? val : options.placement;
                                    if (ttScope.isOpen) {
                                        positionTooltip();
                                    }
                                }));
                            }
                            function unregisterObservers() {
                                if (observers.length) {
                                    angular.forEach(observers, function (observer) {
                                        observer();
                                    });
                                    observers.length = 0;
                                }
                            }
                            function bodyHideTooltipBind(e) {
                                if (!ttScope || !ttScope.isOpen || !tooltip) {
                                    return;
                                }
                                if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                                    hideTooltipBind();
                                }
                            }
                            function hideOnEscapeKey(e) {
                                if (e.which === 27) {
                                    hideTooltipBind();
                                }
                            }
                            var unregisterTriggers = function () {
                                triggers.show.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        element.off('click', toggleTooltipBind);
                                    }
                                    else {
                                        element.off(trigger, showTooltipBind);
                                        element.off(trigger, toggleTooltipBind);
                                    }
                                    element.off('keypress', hideOnEscapeKey);
                                });
                                triggers.hide.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        $document.off('click', bodyHideTooltipBind);
                                    }
                                    else {
                                        element.off(trigger, hideTooltipBind);
                                    }
                                });
                            };
                            function prepTriggers() {
                                var showTriggers = [], hideTriggers = [];
                                var val = scope.$eval(attrs[prefix + 'Trigger']);
                                unregisterTriggers();
                                if (angular.isObject(val)) {
                                    Object.keys(val).forEach(function (key) {
                                        showTriggers.push(key);
                                        hideTriggers.push(val[key]);
                                    });
                                    triggers = {
                                        show: showTriggers,
                                        hide: hideTriggers
                                    };
                                }
                                else {
                                    triggers = getTriggers(val);
                                }
                                if (triggers.show !== 'none') {
                                    triggers.show.forEach(function (trigger, idx) {
                                        if (trigger === 'outsideClick') {
                                            element.on('click', toggleTooltipBind);
                                            $document.on('click', bodyHideTooltipBind);
                                        }
                                        else if (trigger === triggers.hide[idx]) {
                                            element.on(trigger, toggleTooltipBind);
                                        }
                                        else if (trigger) {
                                            element.on(trigger, showTooltipBind);
                                            element.on(triggers.hide[idx], hideTooltipBind);
                                        }
                                        element.on('keypress', hideOnEscapeKey);
                                    });
                                }
                            }
                            prepTriggers();
                            var animation = scope.$eval(attrs[prefix + 'Animation']);
                            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                            var appendToBodyVal;
                            var appendKey = prefix + 'AppendToBody';
                            if (appendKey in attrs && attrs[appendKey] === undefined) {
                                appendToBodyVal = true;
                            }
                            else {
                                appendToBodyVal = scope.$eval(attrs[appendKey]);
                            }
                            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                            scope.$on('$destroy', function onDestroyTooltip() {
                                unregisterTriggers();
                                removeTooltip();
                                ttScope = null;
                            });
                        };
                    }
                };
            };
        }];
})
    .directive('uibTooltipTemplateTransclude', [
    '$animate', '$sce', '$compile', '$templateRequest',
    function ($animate, $sce, $compile, $templateRequest) {
        return {
            link: function (scope, elem, attrs) {
                var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
                var changeCounter = 0, currentScope, previousElement, currentElement;
                var cleanupLastIncludeContent = function () {
                    if (previousElement) {
                        previousElement.remove();
                        previousElement = null;
                    }
                    if (currentScope) {
                        currentScope.$destroy();
                        currentScope = null;
                    }
                    if (currentElement) {
                        $animate.leave(currentElement).then(function () {
                            previousElement = null;
                        });
                        previousElement = currentElement;
                        currentElement = null;
                    }
                };
                scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
                    var thisChangeId = ++changeCounter;
                    if (src) {
                        $templateRequest(src, true).then(function (response) {
                            if (thisChangeId !== changeCounter) {
                                return;
                            }
                            var newScope = origScope.$new();
                            var template = response;
                            var clone = $compile(template)(newScope, function (clone) {
                                cleanupLastIncludeContent();
                                $animate.enter(clone, elem);
                            });
                            currentScope = newScope;
                            currentElement = clone;
                            currentScope.$emit('$includeContentLoaded', src);
                        }, function () {
                            if (thisChangeId === changeCounter) {
                                cleanupLastIncludeContent();
                                scope.$emit('$includeContentError', src);
                            }
                        });
                        scope.$emit('$includeContentRequested', src);
                    }
                    else {
                        cleanupLastIncludeContent();
                    }
                });
                scope.$on('$destroy', cleanupLastIncludeContent);
            }
        };
    }
])
    .directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                if (scope.placement) {
                    var position = $uibPosition.parsePlacement(scope.placement);
                    element.addClass(position[0]);
                }
                if (scope.popupClass) {
                    element.addClass(scope.popupClass);
                }
                if (scope.animation) {
                    element.addClass(attrs.tooltipAnimationClass);
                }
            }
        };
    }])
    .directive('uibTooltipPopup', function () {
    return {
        restrict: 'A',
        scope: { content: '@' },
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
})
    .directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }])
    .directive('uibTooltipTemplatePopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
})
    .directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }])
    .directive('uibTooltipHtmlPopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
})
    .directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }]);
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
    .directive('uibPopoverTemplatePopup', function () {
    return {
        restrict: 'A',
        scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/popover/popover-template.html'
    };
})
    .directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
            useContentExp: true
        });
    }])
    .directive('uibPopoverHtmlPopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&', uibTitle: '@' },
        templateUrl: 'uib/template/popover/popover-html.html'
    };
})
    .directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
            useContentExp: true
        });
    }])
    .directive('uibPopoverPopup', function () {
    return {
        restrict: 'A',
        scope: { uibTitle: '@', content: '@' },
        templateUrl: 'uib/template/popover/popover.html'
    };
})
    .directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopover', 'popover', 'click');
    }]);
angular.module('ui.bootstrap.progressbar', [])
    .constant('uibProgressConfig', {
    animate: true,
    max: 100
})
    .controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
        var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
        this.bars = [];
        $scope.max = getMaxOrDefault();
        this.addBar = function (bar, element, attrs) {
            if (!animate) {
                element.css({ 'transition': 'none' });
            }
            this.bars.push(bar);
            bar.max = getMaxOrDefault();
            bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
            bar.$watch('value', function (value) {
                bar.recalculatePercentage();
            });
            bar.recalculatePercentage = function () {
                var totalPercentage = self.bars.reduce(function (total, bar) {
                    bar.percent = +(100 * bar.value / bar.max).toFixed(2);
                    return total + bar.percent;
                }, 0);
                if (totalPercentage > 100) {
                    bar.percent -= totalPercentage - 100;
                }
            };
            bar.$on('$destroy', function () {
                element = null;
                self.removeBar(bar);
            });
        };
        this.removeBar = function (bar) {
            this.bars.splice(this.bars.indexOf(bar), 1);
            this.bars.forEach(function (bar) {
                bar.recalculatePercentage();
            });
        };
        $scope.$watch('maxParam', function (maxParam) {
            self.bars.forEach(function (bar) {
                bar.max = getMaxOrDefault();
                bar.recalculatePercentage();
            });
        });
        function getMaxOrDefault() {
            return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
        }
    }])
    .directive('uibProgress', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {
            maxParam: '=?max'
        },
        templateUrl: 'uib/template/progressbar/progress.html'
    };
})
    .directive('uibBar', function () {
    return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
})
    .directive('uibProgressbar', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
            value: '=',
            maxParam: '=?max',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
        }
    };
});
angular.module('ui.bootstrap.rating', [])
    .constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: true,
    titles: ['one', 'two', 'three', 'four', 'five']
})
    .controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
        var ngModelCtrl = { $setViewValue: angular.noop }, self = this;
        this.init = function (ngModelCtrl_) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;
            ngModelCtrl.$formatters.push(function (value) {
                if (angular.isNumber(value) && value << 0 !== value) {
                    value = Math.round(value);
                }
                return value;
            });
            this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
            this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
            this.enableReset = angular.isDefined($attrs.enableReset) ?
                $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
            var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
            this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
                tmpTitles : ratingConfig.titles;
            var ratingStates = angular.isDefined($attrs.ratingStates) ?
                $scope.$parent.$eval($attrs.ratingStates) :
                new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
            $scope.range = this.buildTemplateObjects(ratingStates);
        };
        this.buildTemplateObjects = function (states) {
            for (var i = 0, n = states.length; i < n; i++) {
                states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
            }
            return states;
        };
        this.getTitle = function (index) {
            if (index >= this.titles.length) {
                return index + 1;
            }
            return this.titles[index];
        };
        $scope.rate = function (value) {
            if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
                var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
                ngModelCtrl.$setViewValue(newViewValue);
                ngModelCtrl.$render();
            }
        };
        $scope.enter = function (value) {
            if (!$scope.readonly) {
                $scope.value = value;
            }
            $scope.onHover({ value: value });
        };
        $scope.reset = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.onLeave();
        };
        $scope.onKeydown = function (evt) {
            if (/(37|38|39|40)/.test(evt.which)) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
            }
        };
        this.render = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.title = self.getTitle($scope.value - 1);
        };
    }])
    .directive('uibRating', function () {
    return {
        require: ['uibRating', 'ngModel'],
        restrict: 'A',
        scope: {
            readonly: '=?readOnly',
            onHover: '&',
            onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        link: function (scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
});
angular.module('ui.bootstrap.tabs', [])
    .controller('UibTabsetController', ['$scope', function ($scope) {
        var ctrl = this, oldIndex;
        ctrl.tabs = [];
        ctrl.select = function (index, evt) {
            if (!destroyed) {
                var previousIndex = findTabIndex(oldIndex);
                var previousSelected = ctrl.tabs[previousIndex];
                if (previousSelected) {
                    previousSelected.tab.onDeselect({
                        $event: evt,
                        $selectedIndex: index
                    });
                    if (evt && evt.isDefaultPrevented()) {
                        return;
                    }
                    previousSelected.tab.active = false;
                }
                var selected = ctrl.tabs[index];
                if (selected) {
                    selected.tab.onSelect({
                        $event: evt
                    });
                    selected.tab.active = true;
                    ctrl.active = selected.index;
                    oldIndex = selected.index;
                }
                else if (!selected && angular.isDefined(oldIndex)) {
                    ctrl.active = null;
                    oldIndex = null;
                }
            }
        };
        ctrl.addTab = function addTab(tab) {
            ctrl.tabs.push({
                tab: tab,
                index: tab.index
            });
            ctrl.tabs.sort(function (t1, t2) {
                if (t1.index > t2.index) {
                    return 1;
                }
                if (t1.index < t2.index) {
                    return -1;
                }
                return 0;
            });
            if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
                var newActiveIndex = findTabIndex(tab.index);
                ctrl.select(newActiveIndex);
            }
        };
        ctrl.removeTab = function removeTab(tab) {
            var index;
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].tab === tab) {
                    index = i;
                    break;
                }
            }
            if (ctrl.tabs[index].index === ctrl.active) {
                var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
                    index - 1 : index + 1 % ctrl.tabs.length;
                ctrl.select(newActiveTabIndex);
            }
            ctrl.tabs.splice(index, 1);
        };
        $scope.$watch('tabset.active', function (val) {
            if (angular.isDefined(val) && val !== oldIndex) {
                ctrl.select(findTabIndex(val));
            }
        });
        var destroyed;
        $scope.$on('$destroy', function () {
            destroyed = true;
        });
        function findTabIndex(index) {
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].index === index) {
                    return i;
                }
            }
        }
    }])
    .directive('uibTabset', function () {
    return {
        transclude: true,
        replace: true,
        scope: {},
        bindToController: {
            active: '=?',
            type: '@'
        },
        controller: 'UibTabsetController',
        controllerAs: 'tabset',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/tabs/tabset.html';
        },
        link: function (scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ?
                scope.$parent.$eval(attrs.vertical) : false;
            scope.justified = angular.isDefined(attrs.justified) ?
                scope.$parent.$eval(attrs.justified) : false;
        }
    };
})
    .directive('uibTab', ['$parse', function ($parse) {
        return {
            require: '^uibTabset',
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/tabs/tab.html';
            },
            transclude: true,
            scope: {
                heading: '@',
                index: '=?',
                classes: '@?',
                onSelect: '&select',
                onDeselect: '&deselect'
            },
            controller: function () {
            },
            controllerAs: 'tab',
            link: function (scope, elm, attrs, tabsetCtrl, transclude) {
                scope.disabled = false;
                if (attrs.disable) {
                    scope.$parent.$watch($parse(attrs.disable), function (value) {
                        scope.disabled = !!value;
                    });
                }
                if (angular.isUndefined(attrs.index)) {
                    if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
                        scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) { return t.index; })) + 1;
                    }
                    else {
                        scope.index = 0;
                    }
                }
                if (angular.isUndefined(attrs.classes)) {
                    scope.classes = '';
                }
                scope.select = function (evt) {
                    if (!scope.disabled) {
                        var index;
                        for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                            if (tabsetCtrl.tabs[i].tab === scope) {
                                index = i;
                                break;
                            }
                        }
                        tabsetCtrl.select(index, evt);
                    }
                };
                tabsetCtrl.addTab(scope);
                scope.$on('$destroy', function () {
                    tabsetCtrl.removeTab(scope);
                });
                scope.$transcludeFn = transclude;
            }
        };
    }])
    .directive('uibTabHeadingTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTab',
        link: function (scope, elm) {
            scope.$watch('headingElement', function updateHeadingElement(heading) {
                if (heading) {
                    elm.html('');
                    elm.append(heading);
                }
            });
        }
    };
})
    .directive('uibTabContentTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTabset',
        link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    if (isTabHeading(node)) {
                        tab.headingElement = node;
                    }
                    else {
                        elm.append(node);
                    }
                });
            });
        }
    };
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('uib-tab-heading') ||
            node.hasAttribute('data-uib-tab-heading') ||
            node.hasAttribute('x-uib-tab-heading') ||
            node.tagName.toLowerCase() === 'uib-tab-heading' ||
            node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
            node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
            node.tagName.toLowerCase() === 'uib:tab-heading');
    }
});
angular.module('ui.bootstrap.timepicker', [])
    .constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: 'uib/template/timepicker/timepicker.html'
})
    .controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
        var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
        var selected = new Date(), watchers = [], ngModelCtrl = { $setViewValue: angular.noop }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
        $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
        $element.removeAttr('tabindex');
        this.init = function (ngModelCtrl_, inputs) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;
            ngModelCtrl.$formatters.unshift(function (modelValue) {
                return modelValue ? new Date(modelValue) : null;
            });
            var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2);
            hoursModelCtrl = hoursInputEl.controller('ngModel');
            minutesModelCtrl = minutesInputEl.controller('ngModel');
            secondsModelCtrl = secondsInputEl.controller('ngModel');
            var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
            if (mousewheel) {
                this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }
            var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
            if (arrowkeys) {
                this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }
            $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
            this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        };
        var hourStep = timepickerConfig.hourStep;
        if ($attrs.hourStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
                hourStep = +value;
            }));
        }
        var minuteStep = timepickerConfig.minuteStep;
        if ($attrs.minuteStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
                minuteStep = +value;
            }));
        }
        var min;
        watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
            var dt = new Date(value);
            min = isNaN(dt) ? undefined : dt;
        }));
        var max;
        watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
            var dt = new Date(value);
            max = isNaN(dt) ? undefined : dt;
        }));
        var disabled = false;
        if ($attrs.ngDisabled) {
            watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
                disabled = value;
            }));
        }
        $scope.noIncrementHours = function () {
            var incrementedSelected = addMinutes(selected, hourStep * 60);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementHours = function () {
            var decrementedSelected = addMinutes(selected, -hourStep * 60);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noIncrementMinutes = function () {
            var incrementedSelected = addMinutes(selected, minuteStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementMinutes = function () {
            var decrementedSelected = addMinutes(selected, -minuteStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noIncrementSeconds = function () {
            var incrementedSelected = addSeconds(selected, secondStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementSeconds = function () {
            var decrementedSelected = addSeconds(selected, -secondStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noToggleMeridian = function () {
            if (selected.getHours() < 12) {
                return disabled || addMinutes(selected, 12 * 60) > max;
            }
            return disabled || addMinutes(selected, -12 * 60) < min;
        };
        var secondStep = timepickerConfig.secondStep;
        if ($attrs.secondStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
                secondStep = +value;
            }));
        }
        $scope.showSeconds = timepickerConfig.showSeconds;
        if ($attrs.showSeconds) {
            watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
                $scope.showSeconds = !!value;
            }));
        }
        $scope.showMeridian = timepickerConfig.showMeridian;
        if ($attrs.showMeridian) {
            watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
                $scope.showMeridian = !!value;
                if (ngModelCtrl.$error.time) {
                    var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                    if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                        selected.setHours(hours);
                        refresh();
                    }
                }
                else {
                    updateTemplate();
                }
            }));
        }
        function getHoursFromTemplate() {
            var hours = +$scope.hours;
            var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
                hours >= 0 && hours < 24;
            if (!valid || $scope.hours === '') {
                return undefined;
            }
            if ($scope.showMeridian) {
                if (hours === 12) {
                    hours = 0;
                }
                if ($scope.meridian === meridians[1]) {
                    hours = hours + 12;
                }
            }
            return hours;
        }
        function getMinutesFromTemplate() {
            var minutes = +$scope.minutes;
            var valid = minutes >= 0 && minutes < 60;
            if (!valid || $scope.minutes === '') {
                return undefined;
            }
            return minutes;
        }
        function getSecondsFromTemplate() {
            var seconds = +$scope.seconds;
            return seconds >= 0 && seconds < 60 ? seconds : undefined;
        }
        function pad(value, noPad) {
            if (value === null) {
                return '';
            }
            return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
                '0' + value : value.toString();
        }
        this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            var isScrollingUp = function (e) {
                if (e.originalEvent) {
                    e = e.originalEvent;
                }
                var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
                return e.detail || delta > 0;
            };
            hoursInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
                }
                e.preventDefault();
            });
            minutesInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
                }
                e.preventDefault();
            });
            secondsInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
                }
                e.preventDefault();
            });
        };
        this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            hoursInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementHours();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementHours();
                        $scope.$apply();
                    }
                }
            });
            minutesInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementMinutes();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementMinutes();
                        $scope.$apply();
                    }
                }
            });
            secondsInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementSeconds();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementSeconds();
                        $scope.$apply();
                    }
                }
            });
        };
        this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            if ($scope.readonlyInput) {
                $scope.updateHours = angular.noop;
                $scope.updateMinutes = angular.noop;
                $scope.updateSeconds = angular.noop;
                return;
            }
            var invalidate = function (invalidHours, invalidMinutes, invalidSeconds) {
                ngModelCtrl.$setViewValue(null);
                ngModelCtrl.$setValidity('time', false);
                if (angular.isDefined(invalidHours)) {
                    $scope.invalidHours = invalidHours;
                    if (hoursModelCtrl) {
                        hoursModelCtrl.$setValidity('hours', false);
                    }
                }
                if (angular.isDefined(invalidMinutes)) {
                    $scope.invalidMinutes = invalidMinutes;
                    if (minutesModelCtrl) {
                        minutesModelCtrl.$setValidity('minutes', false);
                    }
                }
                if (angular.isDefined(invalidSeconds)) {
                    $scope.invalidSeconds = invalidSeconds;
                    if (secondsModelCtrl) {
                        secondsModelCtrl.$setValidity('seconds', false);
                    }
                }
            };
            $scope.updateHours = function () {
                var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(true);
                    }
                    else {
                        refresh('h');
                    }
                }
                else {
                    invalidate(true);
                }
            };
            hoursInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if ($scope.hours === null || $scope.hours === '') {
                    invalidate(true);
                }
                else if (!$scope.invalidHours && $scope.hours < 10) {
                    $scope.$apply(function () {
                        $scope.hours = pad($scope.hours, !padHours);
                    });
                }
            });
            $scope.updateMinutes = function () {
                var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(undefined, true);
                    }
                    else {
                        refresh('m');
                    }
                }
                else {
                    invalidate(undefined, true);
                }
            };
            minutesInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if ($scope.minutes === null) {
                    invalidate(undefined, true);
                }
                else if (!$scope.invalidMinutes && $scope.minutes < 10) {
                    $scope.$apply(function () {
                        $scope.minutes = pad($scope.minutes);
                    });
                }
            });
            $scope.updateSeconds = function () {
                var seconds = getSecondsFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(seconds)) {
                    selected.setSeconds(seconds);
                    refresh('s');
                }
                else {
                    invalidate(undefined, undefined, true);
                }
            };
            secondsInputEl.on('blur', function (e) {
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if (!$scope.invalidSeconds && $scope.seconds < 10) {
                    $scope.$apply(function () {
                        $scope.seconds = pad($scope.seconds);
                    });
                }
            });
        };
        this.render = function () {
            var date = ngModelCtrl.$viewValue;
            if (isNaN(date)) {
                ngModelCtrl.$setValidity('time', false);
                $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
            }
            else {
                if (date) {
                    selected = date;
                }
                if (selected < min || selected > max) {
                    ngModelCtrl.$setValidity('time', false);
                    $scope.invalidHours = true;
                    $scope.invalidMinutes = true;
                }
                else {
                    makeValid();
                }
                updateTemplate();
            }
        };
        function refresh(keyboardChange) {
            makeValid();
            ngModelCtrl.$setViewValue(new Date(selected));
            updateTemplate(keyboardChange);
        }
        function makeValid() {
            if (hoursModelCtrl) {
                hoursModelCtrl.$setValidity('hours', true);
            }
            if (minutesModelCtrl) {
                minutesModelCtrl.$setValidity('minutes', true);
            }
            if (secondsModelCtrl) {
                secondsModelCtrl.$setValidity('seconds', true);
            }
            ngModelCtrl.$setValidity('time', true);
            $scope.invalidHours = false;
            $scope.invalidMinutes = false;
            $scope.invalidSeconds = false;
        }
        function updateTemplate(keyboardChange) {
            if (!ngModelCtrl.$modelValue) {
                $scope.hours = null;
                $scope.minutes = null;
                $scope.seconds = null;
                $scope.meridian = meridians[0];
            }
            else {
                var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
                if ($scope.showMeridian) {
                    hours = hours === 0 || hours === 12 ? 12 : hours % 12;
                }
                $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
                if (keyboardChange !== 'm') {
                    $scope.minutes = pad(minutes);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
                if (keyboardChange !== 's') {
                    $scope.seconds = pad(seconds);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
            }
        }
        function addSecondsToSelected(seconds) {
            selected = addSeconds(selected, seconds);
            refresh();
        }
        function addMinutes(selected, minutes) {
            return addSeconds(selected, minutes * 60);
        }
        function addSeconds(date, seconds) {
            var dt = new Date(date.getTime() + seconds * 1000);
            var newDate = new Date(date);
            newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
            return newDate;
        }
        function modelIsEmpty() {
            return ($scope.hours === null || $scope.hours === '') &&
                ($scope.minutes === null || $scope.minutes === '') &&
                (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
        }
        $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
            $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
        $scope.incrementHours = function () {
            if (!$scope.noIncrementHours()) {
                addSecondsToSelected(hourStep * 60 * 60);
            }
        };
        $scope.decrementHours = function () {
            if (!$scope.noDecrementHours()) {
                addSecondsToSelected(-hourStep * 60 * 60);
            }
        };
        $scope.incrementMinutes = function () {
            if (!$scope.noIncrementMinutes()) {
                addSecondsToSelected(minuteStep * 60);
            }
        };
        $scope.decrementMinutes = function () {
            if (!$scope.noDecrementMinutes()) {
                addSecondsToSelected(-minuteStep * 60);
            }
        };
        $scope.incrementSeconds = function () {
            if (!$scope.noIncrementSeconds()) {
                addSecondsToSelected(secondStep);
            }
        };
        $scope.decrementSeconds = function () {
            if (!$scope.noDecrementSeconds()) {
                addSecondsToSelected(-secondStep);
            }
        };
        $scope.toggleMeridian = function () {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            if (!$scope.noToggleMeridian()) {
                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
                }
                else {
                    $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
                }
            }
        };
        $scope.blur = function () {
            ngModelCtrl.$setTouched();
        };
        $scope.$on('$destroy', function () {
            while (watchers.length) {
                watchers.shift()();
            }
        });
    }])
    .directive('uibTimepicker', ['uibTimepickerConfig', function (uibTimepickerConfig) {
        return {
            require: ['uibTimepicker', '?^ngModel'],
            restrict: 'A',
            controller: 'UibTimepickerController',
            controllerAs: 'timepicker',
            scope: {},
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || uibTimepickerConfig.templateUrl;
            },
            link: function (scope, element, attrs, ctrls) {
                var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    timepickerCtrl.init(ngModelCtrl, element.find('input'));
                }
            }
        };
    }]);
angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])
    .factory('uibTypeaheadParser', ['$parse', function ($parse) {
        var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
        return {
            parse: function (input) {
                var match = input.match(TYPEAHEAD_REGEXP);
                if (!match) {
                    throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
                        ' but got "' + input + '".');
                }
                return {
                    itemName: match[3],
                    source: $parse(match[4]),
                    viewMapper: $parse(match[2] || match[1]),
                    modelMapper: $parse(match[1])
                };
            }
        };
    }])
    .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
        var HOT_KEYS = [9, 13, 27, 38, 40];
        var eventDebounceTime = 200;
        var modelCtrl, ngModelOptions;
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength && minLength !== 0) {
            minLength = 1;
        }
        originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
            minLength = !newVal && newVal !== 0 ? 1 : newVal;
        });
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
        originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
            isEditable = newVal !== false;
        });
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
        var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
            var evt = vals.$event;
            return evt.which === 13 || evt.which === 9;
        };
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
        var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
        var appendTo = attrs.typeaheadAppendTo ?
            originalScope.$eval(attrs.typeaheadAppendTo) : null;
        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
        var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
        var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
        var $setModelValue = function (scope, newValue) {
            if (angular.isFunction(parsedModel(originalScope)) &&
                ngModelOptions.getOption('getterSetter')) {
                return invokeModelSetter(scope, { $$$p: newValue });
            }
            return parsedModel.assign(scope, newValue);
        };
        var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
        var hasFocus;
        var selected;
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on('$destroy', function () {
            scope.$destroy();
        });
        scope.$on('$destroy', offDestroy);
        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        element.attr({
            'aria-autocomplete': 'list',
            'aria-expanded': false,
            'aria-owns': popupId
        });
        var inputsContainer, hintInputElem;
        if (showHint) {
            inputsContainer = angular.element('<div></div>');
            inputsContainer.css('position', 'relative');
            element.after(inputsContainer);
            hintInputElem = element.clone();
            hintInputElem.attr('placeholder', '');
            hintInputElem.attr('tabindex', '-1');
            hintInputElem.val('');
            hintInputElem.css({
                'position': 'absolute',
                'top': '0px',
                'left': '0px',
                'border-color': 'transparent',
                'box-shadow': 'none',
                'opacity': 1,
                'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
                'color': '#999'
            });
            element.css({
                'position': 'relative',
                'vertical-align': 'top',
                'background-color': 'transparent'
            });
            if (hintInputElem.attr('id')) {
                hintInputElem.removeAttr('id');
            }
            inputsContainer.append(hintInputElem);
            hintInputElem.after(element);
        }
        var popUpEl = angular.element('<div uib-typeahead-popup></div>');
        popUpEl.attr({
            id: popupId,
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx, evt)',
            'move-in-progress': 'moveInProgress',
            query: 'query',
            position: 'position',
            'assign-is-open': 'assignIsOpen(isOpen)',
            debounce: 'debounceUpdate'
        });
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }
        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
            popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
        }
        var resetHint = function () {
            if (showHint) {
                hintInputElem.val('');
            }
        };
        var resetMatches = function () {
            scope.matches = [];
            scope.activeIdx = -1;
            element.attr('aria-expanded', false);
            resetHint();
        };
        var getMatchId = function (index) {
            return popupId + '-option-' + index;
        };
        scope.$watch('activeIdx', function (index) {
            if (index < 0) {
                element.removeAttr('aria-activedescendant');
            }
            else {
                element.attr('aria-activedescendant', getMatchId(index));
            }
        });
        var inputIsExactMatch = function (inputValue, index) {
            if (scope.matches.length > index && inputValue) {
                return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
            }
            return false;
        };
        var getMatchesAsync = function (inputValue, evt) {
            var locals = { $viewValue: inputValue };
            isLoadingSetter(originalScope, true);
            isNoResultsSetter(originalScope, false);
            $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                if (onCurrentRequest && hasFocus) {
                    if (matches && matches.length > 0) {
                        scope.activeIdx = focusFirst ? 0 : -1;
                        isNoResultsSetter(originalScope, false);
                        scope.matches.length = 0;
                        for (var i = 0; i < matches.length; i++) {
                            locals[parserResult.itemName] = matches[i];
                            scope.matches.push({
                                id: getMatchId(i),
                                label: parserResult.viewMapper(scope, locals),
                                model: matches[i]
                            });
                        }
                        scope.query = inputValue;
                        recalculatePosition();
                        element.attr('aria-expanded', true);
                        if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(0, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            }
                            else {
                                scope.select(0, evt);
                            }
                        }
                        if (showHint) {
                            var firstLabel = scope.matches[0].label;
                            if (angular.isString(inputValue) &&
                                inputValue.length > 0 &&
                                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                            }
                            else {
                                hintInputElem.val('');
                            }
                        }
                    }
                    else {
                        resetMatches();
                        isNoResultsSetter(originalScope, true);
                    }
                }
                if (onCurrentRequest) {
                    isLoadingSetter(originalScope, false);
                }
            }, function () {
                resetMatches();
                isLoadingSetter(originalScope, false);
                isNoResultsSetter(originalScope, true);
            });
        };
        if (appendToBody) {
            angular.element($window).on('resize', fireRecalculating);
            $document.find('body').on('scroll', fireRecalculating);
        }
        var debouncedRecalculate = $$debounce(function () {
            if (scope.matches.length) {
                recalculatePosition();
            }
            scope.moveInProgress = false;
        }, eventDebounceTime);
        scope.moveInProgress = false;
        function fireRecalculating() {
            if (!scope.moveInProgress) {
                scope.moveInProgress = true;
                scope.$digest();
            }
            debouncedRecalculate();
        }
        function recalculatePosition() {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top += element.prop('offsetHeight');
        }
        scope.query = undefined;
        var timeoutPromise;
        var scheduleSearchWithTimeout = function (inputValue) {
            timeoutPromise = $timeout(function () {
                getMatchesAsync(inputValue);
            }, waitTime);
        };
        var cancelPreviousTimeout = function () {
            if (timeoutPromise) {
                $timeout.cancel(timeoutPromise);
            }
        };
        resetMatches();
        scope.assignIsOpen = function (isOpen) {
            isOpenSetter(originalScope, isOpen);
        };
        scope.select = function (activeIdx, evt) {
            var locals = {};
            var model, item;
            selected = true;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
            onSelectCallback(originalScope, {
                $item: item,
                $model: model,
                $label: parserResult.viewMapper(originalScope, locals),
                $event: evt
            });
            resetMatches();
            if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                $timeout(function () { element[0].focus(); }, 0, false);
            }
        };
        element.on('keydown', function (evt) {
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                return;
            }
            var shouldSelect = isSelectEvent(originalScope, { $event: evt });
            if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
                resetMatches();
                scope.$digest();
                return;
            }
            evt.preventDefault();
            var target;
            switch (evt.which) {
                case 27:
                    evt.stopPropagation();
                    resetMatches();
                    originalScope.$digest();
                    break;
                case 38:
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                case 40:
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                default:
                    if (shouldSelect) {
                        scope.$apply(function () {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(scope.activeIdx, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            }
                            else {
                                scope.select(scope.activeIdx, evt);
                            }
                        });
                    }
            }
        });
        element.on('focus', function (evt) {
            hasFocus = true;
            if (minLength === 0 && !modelCtrl.$viewValue) {
                $timeout(function () {
                    getMatchesAsync(modelCtrl.$viewValue, evt);
                }, 0);
            }
        });
        element.on('blur', function (evt) {
            if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                selected = true;
                scope.$apply(function () {
                    if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
                        $$debounce(function () {
                            scope.select(scope.activeIdx, evt);
                        }, scope.debounceUpdate.blur);
                    }
                    else {
                        scope.select(scope.activeIdx, evt);
                    }
                });
            }
            if (!isEditable && modelCtrl.$error.editable) {
                modelCtrl.$setViewValue();
                scope.$apply(function () {
                    modelCtrl.$setValidity('editable', true);
                    modelCtrl.$setValidity('parse', true);
                });
                element.val('');
            }
            hasFocus = false;
            selected = false;
        });
        var dismissClickHandler = function (evt) {
            if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                resetMatches();
                if (!$rootScope.$$phase) {
                    originalScope.$digest();
                }
            }
        };
        $document.on('click', dismissClickHandler);
        originalScope.$on('$destroy', function () {
            $document.off('click', dismissClickHandler);
            if (appendToBody || appendTo) {
                $popup.remove();
            }
            if (appendToBody) {
                angular.element($window).off('resize', fireRecalculating);
                $document.find('body').off('scroll', fireRecalculating);
            }
            popUpEl.remove();
            if (showHint) {
                inputsContainer.remove();
            }
        });
        var $popup = $compile(popUpEl)(scope);
        if (appendToBody) {
            $document.find('body').append($popup);
        }
        else if (appendTo) {
            angular.element(appendTo).eq(0).append($popup);
        }
        else {
            element.after($popup);
        }
        this.init = function (_modelCtrl) {
            modelCtrl = _modelCtrl;
            ngModelOptions = extractOptions(modelCtrl);
            scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);
            modelCtrl.$parsers.unshift(function (inputValue) {
                hasFocus = true;
                if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                    if (waitTime > 0) {
                        cancelPreviousTimeout();
                        scheduleSearchWithTimeout(inputValue);
                    }
                    else {
                        getMatchesAsync(inputValue);
                    }
                }
                else {
                    isLoadingSetter(originalScope, false);
                    cancelPreviousTimeout();
                    resetMatches();
                }
                if (isEditable) {
                    return inputValue;
                }
                if (!inputValue) {
                    modelCtrl.$setValidity('editable', true);
                    return null;
                }
                modelCtrl.$setValidity('editable', false);
                return undefined;
            });
            modelCtrl.$formatters.push(function (modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};
                if (!isEditable) {
                    modelCtrl.$setValidity('editable', true);
                }
                if (inputFormatter) {
                    locals.$model = modelValue;
                    return inputFormatter(originalScope, locals);
                }
                locals[parserResult.itemName] = modelValue;
                candidateViewValue = parserResult.viewMapper(originalScope, locals);
                locals[parserResult.itemName] = undefined;
                emptyViewValue = parserResult.viewMapper(originalScope, locals);
                return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            });
        };
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = ngModelCtrl.$options || {};
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                ngModelOptions = ngModelCtrl.$options;
            }
            return ngModelOptions;
        }
    }])
    .directive('uibTypeahead', function () {
    return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', 'uibTypeahead'],
        link: function (originalScope, element, attrs, ctrls) {
            ctrls[1].init(ctrls[0]);
        }
    };
})
    .directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
        return {
            scope: {
                matches: '=',
                query: '=',
                active: '=',
                position: '&',
                moveInProgress: '=',
                select: '&',
                assignIsOpen: '&',
                debounce: '&'
            },
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
            },
            link: function (scope, element, attrs) {
                scope.templateUrl = attrs.templateUrl;
                scope.isOpen = function () {
                    var isDropdownOpen = scope.matches.length > 0;
                    scope.assignIsOpen({ isOpen: isDropdownOpen });
                    return isDropdownOpen;
                };
                scope.isActive = function (matchIdx) {
                    return scope.active === matchIdx;
                };
                scope.selectActive = function (matchIdx) {
                    scope.active = matchIdx;
                };
                scope.selectMatch = function (activeIdx, evt) {
                    var debounce = scope.debounce();
                    if (angular.isNumber(debounce) || angular.isObject(debounce)) {
                        $$debounce(function () {
                            scope.select({ activeIdx: activeIdx, evt: evt });
                        }, angular.isNumber(debounce) ? debounce : debounce['default']);
                    }
                    else {
                        scope.select({ activeIdx: activeIdx, evt: evt });
                    }
                };
            }
        };
    }])
    .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
        return {
            scope: {
                index: '=',
                match: '=',
                query: '='
            },
            link: function (scope, element, attrs) {
                var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
                $templateRequest(tplUrl).then(function (tplContent) {
                    var tplEl = angular.element(tplContent.trim());
                    element.replaceWith(tplEl);
                    $compile(tplEl)(scope);
                });
            }
        };
    }])
    .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
        var isSanitizePresent;
        isSanitizePresent = $injector.has('$sanitize');
        function escapeRegexp(queryToEscape) {
            return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }
        function containsHtml(matchItem) {
            return /<.*>/g.test(matchItem);
        }
        return function (matchItem, query) {
            if (!isSanitizePresent && containsHtml(matchItem)) {
                $log.warn('Unsafe use of typeahead please use ngSanitize');
            }
            matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
            if (!isSanitizePresent) {
                matchItem = $sce.trustAsHtml(matchItem);
            }
            return matchItem;
        };
    }]);
angular.module('ui.bootstrap.carousel').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])
    .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function ($animate, $q, $parse, $injector) {
        var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
        return {
            link: function (scope, element, attrs) {
                var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed), horizontal = false, css = {}, cssTo = {};
                init();
                function init() {
                    horizontal = !!('horizontal' in attrs);
                    if (horizontal) {
                        css = {
                            width: ''
                        };
                        cssTo = { width: '0' };
                    }
                    else {
                        css = {
                            height: ''
                        };
                        cssTo = { height: '0' };
                    }
                    if (!scope.$eval(attrs.uibCollapse)) {
                        element.addClass('in')
                            .addClass('collapse')
                            .attr('aria-expanded', true)
                            .attr('aria-hidden', false)
                            .css(css);
                    }
                }
                function getScrollFromElement(element) {
                    if (horizontal) {
                        return { width: element.scrollWidth + 'px' };
                    }
                    return { height: element.scrollHeight + 'px' };
                }
                function expand() {
                    if (element.hasClass('collapse') && element.hasClass('in')) {
                        return;
                    }
                    $q.resolve(expandingExpr(scope))
                        .then(function () {
                        element.removeClass('collapse')
                            .addClass('collapsing')
                            .attr('aria-expanded', true)
                            .attr('aria-hidden', false);
                        if ($animateCss) {
                            $animateCss(element, {
                                addClass: 'in',
                                easing: 'ease',
                                css: {
                                    overflow: 'hidden'
                                },
                                to: getScrollFromElement(element[0])
                            }).start()['finally'](expandDone);
                        }
                        else {
                            $animate.addClass(element, 'in', {
                                css: {
                                    overflow: 'hidden'
                                },
                                to: getScrollFromElement(element[0])
                            }).then(expandDone);
                        }
                    }, angular.noop);
                }
                function expandDone() {
                    element.removeClass('collapsing')
                        .addClass('collapse')
                        .css(css);
                    expandedExpr(scope);
                }
                function collapse() {
                    if (!element.hasClass('collapse') && !element.hasClass('in')) {
                        return collapseDone();
                    }
                    $q.resolve(collapsingExpr(scope))
                        .then(function () {
                        element
                            .css(getScrollFromElement(element[0]))
                            .removeClass('collapse')
                            .addClass('collapsing')
                            .attr('aria-expanded', false)
                            .attr('aria-hidden', true);
                        if ($animateCss) {
                            $animateCss(element, {
                                removeClass: 'in',
                                to: cssTo
                            }).start()['finally'](collapseDone);
                        }
                        else {
                            $animate.removeClass(element, 'in', {
                                to: cssTo
                            }).then(collapseDone);
                        }
                    }, angular.noop);
                }
                function collapseDone() {
                    element.css(cssTo);
                    element.removeClass('collapsing')
                        .addClass('collapse');
                    collapsedExpr(scope);
                }
                scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
                    if (shouldCollapse) {
                        collapse();
                    }
                    else {
                        expand();
                    }
                });
            }
        };
    }]);
angular.module('ui.bootstrap.tabindex', [])
    .directive('uibTabindexToggle', function () {
    return {
        restrict: 'A',
        link: function (scope, elem, attrs) {
            attrs.$observe('disabled', function (disabled) {
                attrs.$set('tabindex', disabled ? -1 : null);
            });
        }
    };
});
angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])
    .constant('uibAccordionConfig', {
    closeOthers: true
})
    .controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
        this.groups = [];
        this.closeOthers = function (openGroup) {
            var closeOthers = angular.isDefined($attrs.closeOthers) ?
                $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
            if (closeOthers) {
                angular.forEach(this.groups, function (group) {
                    if (group !== openGroup) {
                        group.isOpen = false;
                    }
                });
            }
        };
        this.addGroup = function (groupScope) {
            var that = this;
            this.groups.push(groupScope);
            groupScope.$on('$destroy', function (event) {
                that.removeGroup(groupScope);
            });
        };
        this.removeGroup = function (group) {
            var index = this.groups.indexOf(group);
            if (index !== -1) {
                this.groups.splice(index, 1);
            }
        };
    }])
    .directive('uibAccordion', function () {
    return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
    };
})
    .directive('uibAccordionGroup', function () {
    return {
        require: '^uibAccordion',
        transclude: true,
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
            heading: '@',
            panelClass: '@?',
            isOpen: '=?',
            isDisabled: '=?'
        },
        controller: function () {
            this.setHeading = function (element) {
                this.heading = element;
            };
        },
        link: function (scope, element, attrs, accordionCtrl) {
            element.addClass('panel');
            accordionCtrl.addGroup(scope);
            scope.openClass = attrs.openClass || 'panel-open';
            scope.panelClass = attrs.panelClass || 'panel-default';
            scope.$watch('isOpen', function (value) {
                element.toggleClass(scope.openClass, !!value);
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
            });
            scope.toggleOpen = function ($event) {
                if (!scope.isDisabled) {
                    if (!$event || $event.which === 32) {
                        scope.isOpen = !scope.isOpen;
                    }
                }
            };
            var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
            scope.headingId = id + '-tab';
            scope.panelId = id + '-panel';
        }
    };
})
    .directive('uibAccordionHeading', function () {
    return {
        transclude: true,
        template: '',
        replace: true,
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
})
    .directive('uibAccordionTransclude', function () {
    return {
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, controller) {
            scope.$watch(function () { return controller[attrs.uibAccordionTransclude]; }, function (heading) {
                if (heading) {
                    var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                    elem.html('');
                    elem.append(heading);
                }
            });
        }
    };
    function getHeaderSelectors() {
        return 'uib-accordion-header,' +
            'data-uib-accordion-header,' +
            'x-uib-accordion-header,' +
            'uib\\:accordion-header,' +
            '[uib-accordion-header],' +
            '[data-uib-accordion-header],' +
            '[x-uib-accordion-header]';
    }
});
angular.module('ui.bootstrap.alert', [])
    .controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function ($scope, $element, $attrs, $interpolate, $timeout) {
        $scope.closeable = !!$attrs.close;
        $element.addClass('alert');
        $attrs.$set('role', 'alert');
        if ($scope.closeable) {
            $element.addClass('alert-dismissible');
        }
        var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
            $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
        if (dismissOnTimeout) {
            $timeout(function () {
                $scope.close();
            }, parseInt(dismissOnTimeout, 10));
        }
    }])
    .directive('uibAlert', function () {
    return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        scope: {
            close: '&'
        }
    };
});
angular.module('ui.bootstrap.buttons', [])
    .constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
})
    .controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
        this.activeClass = buttonConfig.activeClass || 'active';
        this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }])
    .directive('uibBtnRadio', ['$parse', function ($parse) {
        return {
            require: ['uibBtnRadio', 'ngModel'],
            controller: 'UibButtonsController',
            controllerAs: 'buttons',
            link: function (scope, element, attrs, ctrls) {
                var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                var uncheckableExpr = $parse(attrs.uibUncheckable);
                element.find('input').css({ display: 'none' });
                ngModelCtrl.$render = function () {
                    element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
                };
                element.on(buttonsCtrl.toggleEvent, function () {
                    if (attrs.disabled) {
                        return;
                    }
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    if (!isActive || angular.isDefined(attrs.uncheckable)) {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                            ngModelCtrl.$render();
                        });
                    }
                });
                if (attrs.uibUncheckable) {
                    scope.$watch(uncheckableExpr, function (uncheckable) {
                        attrs.$set('uncheckable', uncheckable ? '' : undefined);
                    });
                }
            }
        };
    }])
    .directive('uibBtnCheckbox', function () {
    return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find('input').css({ display: 'none' });
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            };
            element.on(buttonsCtrl.toggleEvent, function () {
                if (attrs.disabled) {
                    return;
                }
                scope.$apply(function () {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
        }
    };
});
angular.module('ui.bootstrap.carousel', [])
    .controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
        var self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = 'uib-slideDirection', currentIndex = $scope.active, currentInterval, isPlaying;
        var destroyed = false;
        $element.addClass('carousel');
        self.addSlide = function (slide, element) {
            slides.push({
                slide: slide,
                element: element
            });
            slides.sort(function (a, b) {
                return +a.slide.index - +b.slide.index;
            });
            if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
                if ($scope.$currentTransition) {
                    $scope.$currentTransition = null;
                }
                currentIndex = slide.index;
                $scope.active = slide.index;
                setActive(currentIndex);
                self.select(slides[findSlideIndex(slide)]);
                if (slides.length === 1) {
                    $scope.play();
                }
            }
        };
        self.getCurrentIndex = function () {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide.index === currentIndex) {
                    return i;
                }
            }
        };
        self.next = $scope.next = function () {
            var newIndex = (self.getCurrentIndex() + 1) % slides.length;
            if (newIndex === 0 && $scope.noWrap()) {
                $scope.pause();
                return;
            }
            return self.select(slides[newIndex], 'next');
        };
        self.prev = $scope.prev = function () {
            var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
            if ($scope.noWrap() && newIndex === slides.length - 1) {
                $scope.pause();
                return;
            }
            return self.select(slides[newIndex], 'prev');
        };
        self.removeSlide = function (slide) {
            var index = findSlideIndex(slide);
            slides.splice(index, 1);
            if (slides.length > 0 && currentIndex === index) {
                if (index >= slides.length) {
                    currentIndex = slides.length - 1;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[slides.length - 1]);
                }
                else {
                    currentIndex = index;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[index]);
                }
            }
            else if (currentIndex > index) {
                currentIndex--;
                $scope.active = currentIndex;
            }
            if (slides.length === 0) {
                currentIndex = null;
                $scope.active = null;
            }
        };
        self.select = $scope.select = function (nextSlide, direction) {
            var nextIndex = findSlideIndex(nextSlide.slide);
            if (direction === undefined) {
                direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
            }
            if (nextSlide.slide.index !== currentIndex &&
                !$scope.$currentTransition) {
                goNext(nextSlide.slide, nextIndex, direction);
            }
        };
        $scope.indexOfSlide = function (slide) {
            return +slide.slide.index;
        };
        $scope.isActive = function (slide) {
            return $scope.active === slide.slide.index;
        };
        $scope.isPrevDisabled = function () {
            return $scope.active === 0 && $scope.noWrap();
        };
        $scope.isNextDisabled = function () {
            return $scope.active === slides.length - 1 && $scope.noWrap();
        };
        $scope.pause = function () {
            if (!$scope.noPause) {
                isPlaying = false;
                resetTimer();
            }
        };
        $scope.play = function () {
            if (!isPlaying) {
                isPlaying = true;
                restartTimer();
            }
        };
        $element.on('mouseenter', $scope.pause);
        $element.on('mouseleave', $scope.play);
        $scope.$on('$destroy', function () {
            destroyed = true;
            resetTimer();
        });
        $scope.$watch('noTransition', function (noTransition) {
            $animate.enabled($element, !noTransition);
        });
        $scope.$watch('interval', restartTimer);
        $scope.$watchCollection('slides', resetTransition);
        $scope.$watch('active', function (index) {
            if (angular.isNumber(index) && currentIndex !== index) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i].slide.index === index) {
                        index = i;
                        break;
                    }
                }
                var slide = slides[index];
                if (slide) {
                    setActive(index);
                    self.select(slides[index]);
                    currentIndex = index;
                }
            }
        });
        function getSlideByIndex(index) {
            for (var i = 0, l = slides.length; i < l; ++i) {
                if (slides[i].index === index) {
                    return slides[i];
                }
            }
        }
        function setActive(index) {
            for (var i = 0; i < slides.length; i++) {
                slides[i].slide.active = i === index;
            }
        }
        function goNext(slide, index, direction) {
            if (destroyed) {
                return;
            }
            angular.extend(slide, { direction: direction });
            angular.extend(slides[currentIndex].slide || {}, { direction: direction });
            if ($animate.enabled($element) && !$scope.$currentTransition &&
                slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();
                if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
                    slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
                }
                $scope.$currentTransition = true;
                $animate.on('addClass', slides[index].element, function (element, phase) {
                    if (phase === 'close') {
                        $scope.$currentTransition = null;
                        $animate.off('addClass', element);
                    }
                });
            }
            $scope.active = slide.index;
            currentIndex = slide.index;
            setActive(index);
            restartTimer();
        }
        function findSlideIndex(slide) {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide === slide) {
                    return i;
                }
            }
        }
        function resetTimer() {
            if (currentInterval) {
                $interval.cancel(currentInterval);
                currentInterval = null;
            }
        }
        function resetTransition(slides) {
            if (!slides.length) {
                $scope.$currentTransition = null;
            }
        }
        function restartTimer() {
            resetTimer();
            var interval = +$scope.interval;
            if (!isNaN(interval) && interval > 0) {
                currentInterval = $interval(timerFn, interval);
            }
        }
        function timerFn() {
            var interval = +$scope.interval;
            if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
                $scope.next();
            }
            else {
                $scope.pause();
            }
        }
    }])
    .directive('uibCarousel', function () {
    return {
        transclude: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        restrict: 'A',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
            active: '=',
            interval: '=',
            noTransition: '=',
            noPause: '=',
            noWrap: '&'
        }
    };
})
    .directive('uibSlide', ['$animate', function ($animate) {
        return {
            require: '^uibCarousel',
            restrict: 'A',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/slide.html';
            },
            scope: {
                actual: '=?',
                index: '=?'
            },
            link: function (scope, element, attrs, carouselCtrl) {
                element.addClass('item');
                carouselCtrl.addSlide(scope, element);
                scope.$on('$destroy', function () {
                    carouselCtrl.removeSlide(scope);
                });
                scope.$watch('active', function (active) {
                    $animate[active ? 'addClass' : 'removeClass'](element, 'active');
                });
            }
        };
    }])
    .animation('.item', ['$animateCss',
    function ($animateCss) {
        var SLIDE_DIRECTION = 'uib-slideDirection';
        function removeClass(element, className, callback) {
            element.removeClass(className);
            if (callback) {
                callback();
            }
        }
        return {
            beforeAddClass: function (element, className, done) {
                if (className === 'active') {
                    var stopped = false;
                    var direction = element.data(SLIDE_DIRECTION);
                    var directionClass = direction === 'next' ? 'left' : 'right';
                    var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
                    element.addClass(direction);
                    $animateCss(element, { addClass: directionClass })
                        .start()
                        .done(removeClassFn);
                    return function () {
                        stopped = true;
                    };
                }
                done();
            },
            beforeRemoveClass: function (element, className, done) {
                if (className === 'active') {
                    var stopped = false;
                    var direction = element.data(SLIDE_DIRECTION);
                    var directionClass = direction === 'next' ? 'left' : 'right';
                    var removeClassFn = removeClass.bind(this, element, directionClass, done);
                    $animateCss(element, { addClass: directionClass })
                        .start()
                        .done(removeClassFn);
                    return function () {
                        stopped = true;
                    };
                }
                done();
            }
        };
    }]);
angular.module('ui.bootstrap.dateparser', [])
    .service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function ($log, $locale, dateFilter, orderByFilter, filterFilter) {
        var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var localeId;
        var formatCodeToRegex;
        this.init = function () {
            localeId = $locale.id;
            this.parsers = {};
            this.formatters = {};
            formatCodeToRegex = [
                {
                    key: 'yyyy',
                    regex: '\\d{4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yyyy');
                    }
                },
                {
                    key: 'yy',
                    regex: '\\d{2}',
                    apply: function (value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yy');
                    }
                },
                {
                    key: 'y',
                    regex: '\\d{1,4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'y');
                    }
                },
                {
                    key: 'M!',
                    regex: '0?[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) {
                        var value = date.getMonth();
                        if (/^[0-9]$/.test(value)) {
                            return dateFilter(date, 'MM');
                        }
                        return dateFilter(date, 'M');
                    }
                },
                {
                    key: 'MMMM',
                    regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMMM'); }
                },
                {
                    key: 'MMM',
                    regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMM'); }
                },
                {
                    key: 'MM',
                    regex: '0[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'MM'); }
                },
                {
                    key: 'M',
                    regex: '[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'M'); }
                },
                {
                    key: 'd!',
                    regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) {
                        var value = date.getDate();
                        if (/^[1-9]$/.test(value)) {
                            return dateFilter(date, 'dd');
                        }
                        return dateFilter(date, 'd');
                    }
                },
                {
                    key: 'dd',
                    regex: '[0-2][0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'dd'); }
                },
                {
                    key: 'd',
                    regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'd'); }
                },
                {
                    key: 'EEEE',
                    regex: $locale.DATETIME_FORMATS.DAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEEE'); }
                },
                {
                    key: 'EEE',
                    regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEE'); }
                },
                {
                    key: 'HH',
                    regex: '(?:0|1)[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'HH'); }
                },
                {
                    key: 'hh',
                    regex: '0[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'hh'); }
                },
                {
                    key: 'H',
                    regex: '1?[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'H'); }
                },
                {
                    key: 'h',
                    regex: '[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'h'); }
                },
                {
                    key: 'mm',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'mm'); }
                },
                {
                    key: 'm',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'm'); }
                },
                {
                    key: 'sss',
                    regex: '[0-9][0-9][0-9]',
                    apply: function (value) { this.milliseconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'sss'); }
                },
                {
                    key: 'ss',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'ss'); }
                },
                {
                    key: 's',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 's'); }
                },
                {
                    key: 'a',
                    regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
                    apply: function (value) {
                        if (this.hours === 12) {
                            this.hours = 0;
                        }
                        if (value === 'PM') {
                            this.hours += 12;
                        }
                    },
                    formatter: function (date) { return dateFilter(date, 'a'); }
                },
                {
                    key: 'Z',
                    regex: '[+-]\\d{4}',
                    apply: function (value) {
                        var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                        this.hours += toInt(sign + hours);
                        this.minutes += toInt(sign + minutes);
                    },
                    formatter: function (date) {
                        return dateFilter(date, 'Z');
                    }
                },
                {
                    key: 'ww',
                    regex: '[0-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'ww'); }
                },
                {
                    key: 'w',
                    regex: '[0-9]|[1-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'w'); }
                },
                {
                    key: 'GGGG',
                    regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
                    formatter: function (date) { return dateFilter(date, 'GGGG'); }
                },
                {
                    key: 'GGG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GGG'); }
                },
                {
                    key: 'GG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GG'); }
                },
                {
                    key: 'G',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'G'); }
                }
            ];
            if (angular.version.major >= 1 && angular.version.minor > 4) {
                formatCodeToRegex.push({
                    key: 'LLLL',
                    regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'LLLL'); }
                });
            }
        };
        this.init();
        function getFormatCodeToRegex(key) {
            return filterFilter(formatCodeToRegex, { key: key }, true)[0];
        }
        this.getParser = function (key) {
            var f = getFormatCodeToRegex(key);
            return f && f.apply || null;
        };
        this.overrideParser = function (key, parser) {
            var f = getFormatCodeToRegex(key);
            if (f && angular.isFunction(parser)) {
                this.parsers = {};
                f.apply = parser;
            }
        }.bind(this);
        function createParser(format) {
            var map = [], regex = format.split('');
            var quoteIndex = format.indexOf('\'');
            if (quoteIndex > -1) {
                var inLiteral = false;
                format = format.split('');
                for (var i = quoteIndex; i < format.length; i++) {
                    if (inLiteral) {
                        if (format[i] === '\'') {
                            if (i + 1 < format.length && format[i + 1] === '\'') {
                                format[i + 1] = '$';
                                regex[i + 1] = '';
                            }
                            else {
                                regex[i] = '';
                                inLiteral = false;
                            }
                        }
                        format[i] = '$';
                    }
                    else {
                        if (format[i] === '\'') {
                            format[i] = '$';
                            regex[i] = '';
                            inLiteral = true;
                        }
                    }
                }
                format = format.join('');
            }
            angular.forEach(formatCodeToRegex, function (data) {
                var index = format.indexOf(data.key);
                if (index > -1) {
                    format = format.split('');
                    regex[index] = '(' + data.regex + ')';
                    format[index] = '$';
                    for (var i = index + 1, n = index + data.key.length; i < n; i++) {
                        regex[i] = '';
                        format[i] = '$';
                    }
                    format = format.join('');
                    map.push({
                        index: index,
                        key: data.key,
                        apply: data.apply,
                        matcher: data.regex
                    });
                }
            });
            return {
                regex: new RegExp('^' + regex.join('') + '$'),
                map: orderByFilter(map, 'index')
            };
        }
        function createFormatter(format) {
            var formatters = [];
            var i = 0;
            var formatter, literalIdx;
            while (i < format.length) {
                if (angular.isNumber(literalIdx)) {
                    if (format.charAt(i) === '\'') {
                        if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
                            formatters.push(constructLiteralFormatter(format, literalIdx, i));
                            literalIdx = null;
                        }
                    }
                    else if (i === format.length) {
                        while (literalIdx < format.length) {
                            formatter = constructFormatterFromIdx(format, literalIdx);
                            formatters.push(formatter);
                            literalIdx = formatter.endIdx;
                        }
                    }
                    i++;
                    continue;
                }
                if (format.charAt(i) === '\'') {
                    literalIdx = i;
                    i++;
                    continue;
                }
                formatter = constructFormatterFromIdx(format, i);
                formatters.push(formatter.parser);
                i = formatter.endIdx;
            }
            return formatters;
        }
        function constructLiteralFormatter(format, literalIdx, endIdx) {
            return function () {
                return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
            };
        }
        function constructFormatterFromIdx(format, i) {
            var currentPosStr = format.substr(i);
            for (var j = 0; j < formatCodeToRegex.length; j++) {
                if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
                    var data = formatCodeToRegex[j];
                    return {
                        endIdx: i + data.key.length,
                        parser: data.formatter
                    };
                }
            }
            return {
                endIdx: i + 1,
                parser: function () {
                    return currentPosStr.charAt(0);
                }
            };
        }
        this.filter = function (date, format) {
            if (!angular.isDate(date) || isNaN(date) || !format) {
                return '';
            }
            format = $locale.DATETIME_FORMATS[format] || format;
            if ($locale.id !== localeId) {
                this.init();
            }
            if (!this.formatters[format]) {
                this.formatters[format] = createFormatter(format);
            }
            var formatters = this.formatters[format];
            return formatters.reduce(function (str, formatter) {
                return str + formatter(date);
            }, '');
        };
        this.parse = function (input, format, baseDate) {
            if (!angular.isString(input) || !format) {
                return input;
            }
            format = $locale.DATETIME_FORMATS[format] || format;
            format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
            if ($locale.id !== localeId) {
                this.init();
            }
            if (!this.parsers[format]) {
                this.parsers[format] = createParser(format, 'apply');
            }
            var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = false;
            if (results && results.length) {
                var fields, dt;
                if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                    fields = {
                        year: baseDate.getFullYear(),
                        month: baseDate.getMonth(),
                        date: baseDate.getDate(),
                        hours: baseDate.getHours(),
                        minutes: baseDate.getMinutes(),
                        seconds: baseDate.getSeconds(),
                        milliseconds: baseDate.getMilliseconds()
                    };
                }
                else {
                    if (baseDate) {
                        $log.warn('dateparser:', 'baseDate is not a valid date');
                    }
                    fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
                }
                for (var i = 1, n = results.length; i < n; i++) {
                    var mapper = map[i - 1];
                    if (mapper.matcher === 'Z') {
                        tzOffset = true;
                    }
                    if (mapper.apply) {
                        mapper.apply.call(fields, results[i]);
                    }
                }
                var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
                    Date.prototype.setFullYear;
                var timesetter = tzOffset ? Date.prototype.setUTCHours :
                    Date.prototype.setHours;
                if (isValid(fields.year, fields.month, fields.date)) {
                    if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
                        dt = new Date(baseDate);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
                    }
                    else {
                        dt = new Date(0);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
                    }
                }
                return dt;
            }
        };
        function isValid(year, month, date) {
            if (date < 1) {
                return false;
            }
            if (month === 1 && date > 28) {
                return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
            }
            if (month === 3 || month === 5 || month === 8 || month === 10) {
                return date < 31;
            }
            return true;
        }
        function toInt(str) {
            return parseInt(str, 10);
        }
        this.toTimezone = toTimezone;
        this.fromTimezone = fromTimezone;
        this.timezoneToOffset = timezoneToOffset;
        this.addDateMinutes = addDateMinutes;
        this.convertTimezoneToLocal = convertTimezoneToLocal;
        function toTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
        }
        function fromTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
        }
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(/:/g, '');
            var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
    }]);
angular.module('ui.bootstrap.isClass', [])
    .directive('uibIsClass', [
    '$animate',
    function ($animate) {
        var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
        var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
        var dataPerTracked = {};
        return {
            restrict: 'A',
            compile: function (tElement, tAttrs) {
                var linkedScopes = [];
                var instances = [];
                var expToData = {};
                var lastActivated = null;
                var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
                var onExp = onExpMatches[2];
                var expsStr = onExpMatches[1];
                var exps = expsStr.split(',');
                return linkFn;
                function linkFn(scope, element, attrs) {
                    linkedScopes.push(scope);
                    instances.push({
                        scope: scope,
                        element: element
                    });
                    exps.forEach(function (exp, k) {
                        addForExp(exp, scope);
                    });
                    scope.$on('$destroy', removeScope);
                }
                function addForExp(exp, scope) {
                    var matches = exp.match(IS_REGEXP);
                    var clazz = scope.$eval(matches[1]);
                    var compareWithExp = matches[2];
                    var data = expToData[exp];
                    if (!data) {
                        var watchFn = function (compareWithVal) {
                            var newActivated = null;
                            instances.some(function (instance) {
                                var thisVal = instance.scope.$eval(onExp);
                                if (thisVal === compareWithVal) {
                                    newActivated = instance;
                                    return true;
                                }
                            });
                            if (data.lastActivated !== newActivated) {
                                if (data.lastActivated) {
                                    $animate.removeClass(data.lastActivated.element, clazz);
                                }
                                if (newActivated) {
                                    $animate.addClass(newActivated.element, clazz);
                                }
                                data.lastActivated = newActivated;
                            }
                        };
                        expToData[exp] = data = {
                            lastActivated: null,
                            scope: scope,
                            watchFn: watchFn,
                            compareWithExp: compareWithExp,
                            watcher: scope.$watch(compareWithExp, watchFn)
                        };
                    }
                    data.watchFn(scope.$eval(compareWithExp));
                }
                function removeScope(e) {
                    var removedScope = e.targetScope;
                    var index = linkedScopes.indexOf(removedScope);
                    linkedScopes.splice(index, 1);
                    instances.splice(index, 1);
                    if (linkedScopes.length) {
                        var newWatchScope = linkedScopes[0];
                        angular.forEach(expToData, function (data) {
                            if (data.scope === removedScope) {
                                data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                                data.scope = newWatchScope;
                            }
                        });
                    }
                    else {
                        expToData = {};
                    }
                }
            }
        };
    }
]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])
    .value('$datepickerSuppressError', false)
    .value('$datepickerLiteralWarning', true)
    .constant('uibDatepickerConfig', {
    datepickerMode: 'day',
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    maxDate: null,
    maxMode: 'year',
    minDate: null,
    minMode: 'day',
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4
})
    .controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
    function ($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
        var self = this, ngModelCtrl = { $setViewValue: angular.noop }, ngModelOptions = {}, watchListeners = [];
        $element.addClass('uib-datepicker');
        $attrs.$set('role', 'application');
        if (!$scope.datepickerOptions) {
            $scope.datepickerOptions = {};
        }
        this.modes = ['day', 'month', 'year'];
        [
            'customClass',
            'dateDisabled',
            'datepickerMode',
            'formatDay',
            'formatDayHeader',
            'formatDayTitle',
            'formatMonth',
            'formatMonthTitle',
            'formatYear',
            'maxDate',
            'maxMode',
            'minDate',
            'minMode',
            'monthColumns',
            'showWeeks',
            'shortcutPropagation',
            'startingDay',
            'yearColumns',
            'yearRows'
        ].forEach(function (key) {
            switch (key) {
                case 'customClass':
                case 'dateDisabled':
                    $scope[key] = $scope.datepickerOptions[key] || angular.noop;
                    break;
                case 'datepickerMode':
                    $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
                        $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
                    break;
                case 'formatDay':
                case 'formatDayHeader':
                case 'formatDayTitle':
                case 'formatMonth':
                case 'formatMonthTitle':
                case 'formatYear':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                        $interpolate($scope.datepickerOptions[key])($scope.$parent) :
                        datepickerConfig[key];
                    break;
                case 'monthColumns':
                case 'showWeeks':
                case 'shortcutPropagation':
                case 'yearColumns':
                case 'yearRows':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                        $scope.datepickerOptions[key] : datepickerConfig[key];
                    break;
                case 'startingDay':
                    if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                        self.startingDay = $scope.datepickerOptions.startingDay;
                    }
                    else if (angular.isNumber(datepickerConfig.startingDay)) {
                        self.startingDay = datepickerConfig.startingDay;
                    }
                    else {
                        self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
                    }
                    break;
                case 'maxDate':
                case 'minDate':
                    $scope.$watch('datepickerOptions.' + key, function (value) {
                        if (value) {
                            if (angular.isDate(value)) {
                                self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
                            }
                            else {
                                if ($datepickerLiteralWarning) {
                                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                                }
                                self[key] = new Date(dateFilter(value, 'medium'));
                            }
                        }
                        else {
                            self[key] = datepickerConfig[key] ?
                                dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :
                                null;
                        }
                        self.refreshView();
                    });
                    break;
                case 'maxMode':
                case 'minMode':
                    if ($scope.datepickerOptions[key]) {
                        $scope.$watch(function () { return $scope.datepickerOptions[key]; }, function (value) {
                            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
                            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
                                key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                                $scope.datepickerMode = self[key];
                                $scope.datepickerOptions.datepickerMode = self[key];
                            }
                        });
                    }
                    else {
                        self[key] = $scope[key] = datepickerConfig[key] || null;
                    }
                    break;
            }
        });
        $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
        $scope.disabled = angular.isDefined($attrs.disabled) || false;
        if (angular.isDefined($attrs.ngDisabled)) {
            watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
                $scope.disabled = disabled;
                self.refreshView();
            }));
        }
        $scope.isActive = function (dateObject) {
            if (self.compare(dateObject.date, self.activeDate) === 0) {
                $scope.activeDateId = dateObject.uid;
                return true;
            }
            return false;
        };
        this.init = function (ngModelCtrl_) {
            ngModelCtrl = ngModelCtrl_;
            ngModelOptions = extractOptions(ngModelCtrl);
            if ($scope.datepickerOptions.initDate) {
                self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
                $scope.$watch('datepickerOptions.initDate', function (initDate) {
                    if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                        self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
                        self.refreshView();
                    }
                });
            }
            else {
                self.activeDate = new Date();
            }
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
            this.activeDate = !isNaN(date) ?
                dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :
                dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
            ngModelCtrl.$render = function () {
                self.render();
            };
        };
        this.render = function () {
            if (ngModelCtrl.$viewValue) {
                var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
                if (isValid) {
                    this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                }
                else if (!$datepickerSuppressError) {
                    $log.error('Datepicker directive: "ng-model" value must be a Date object');
                }
            }
            this.refreshView();
        };
        this.refreshView = function () {
            if (this.element) {
                $scope.selectedDt = null;
                this._refreshView();
                if ($scope.activeDt) {
                    $scope.activeDateId = $scope.activeDt.uid;
                }
                var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                ngModelCtrl.$setValidity('dateDisabled', !date ||
                    this.element && !this.isDisabled(date));
            }
        };
        this.createDateObject = function (date, format) {
            var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
            var today = new Date();
            today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
            var time = this.compare(date, today);
            var dt = {
                date: date,
                label: dateParser.filter(date, format),
                selected: model && this.compare(date, model) === 0,
                disabled: this.isDisabled(date),
                past: time < 0,
                current: time === 0,
                future: time > 0,
                customClass: this.customClass(date) || null
            };
            if (model && this.compare(date, model) === 0) {
                $scope.selectedDt = dt;
            }
            if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
                $scope.activeDt = dt;
            }
            return dt;
        };
        this.isDisabled = function (date) {
            return $scope.disabled ||
                this.minDate && this.compare(date, this.minDate) < 0 ||
                this.maxDate && this.compare(date, this.maxDate) > 0 ||
                $scope.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
        };
        this.customClass = function (date) {
            return $scope.customClass({ date: date, mode: $scope.datepickerMode });
        };
        this.split = function (arr, size) {
            var arrays = [];
            while (arr.length > 0) {
                arrays.push(arr.splice(0, size));
            }
            return arrays;
        };
        $scope.select = function (date) {
            if ($scope.datepickerMode === self.minMode) {
                var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
                dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
                ngModelCtrl.$setViewValue(dt);
                ngModelCtrl.$render();
            }
            else {
                self.activeDate = date;
                setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
                $scope.$emit('uib:datepicker.mode');
            }
            $scope.$broadcast('uib:datepicker.focus');
        };
        $scope.move = function (direction) {
            var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
            self.activeDate.setFullYear(year, month, 1);
            self.refreshView();
        };
        $scope.toggleMode = function (direction) {
            direction = direction || 1;
            if ($scope.datepickerMode === self.maxMode && direction === 1 ||
                $scope.datepickerMode === self.minMode && direction === -1) {
                return;
            }
            setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
            $scope.$emit('uib:datepicker.mode');
        };
        $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
        var focusElement = function () {
            self.element[0].focus();
        };
        $scope.$on('uib:datepicker.focus', focusElement);
        $scope.keydown = function (evt) {
            var key = $scope.keys[evt.which];
            if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
                return;
            }
            evt.preventDefault();
            if (!self.shortcutPropagation) {
                evt.stopPropagation();
            }
            if (key === 'enter' || key === 'space') {
                if (self.isDisabled(self.activeDate)) {
                    return;
                }
                $scope.select(self.activeDate);
            }
            else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
                $scope.toggleMode(key === 'up' ? 1 : -1);
            }
            else {
                self.handleKeyDown(key, evt);
                self.refreshView();
            }
        };
        $element.on('keydown', function (evt) {
            $scope.$apply(function () {
                $scope.keydown(evt);
            });
        });
        $scope.$on('$destroy', function () {
            while (watchListeners.length) {
                watchListeners.shift()();
            }
        });
        function setMode(mode) {
            $scope.datepickerMode = mode;
            $scope.datepickerOptions.datepickerMode = mode;
        }
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = ngModelCtrl.$options ||
                    $scope.datepickerOptions.ngModelOptions ||
                    datepickerConfig.ngModelOptions ||
                    {};
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                var timezone = ngModelCtrl.$options.getOption('timezone') ||
                    ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||
                    (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);
                ngModelOptions = ngModelCtrl.$options
                    .createChild(datepickerConfig.ngModelOptions)
                    .createChild($scope.datepickerOptions.ngModelOptions)
                    .createChild(ngModelCtrl.$options)
                    .createChild({ timezone: timezone });
            }
            return ngModelOptions;
        }
    }])
    .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        this.step = { months: 1 };
        this.element = $element;
        function getDaysInMonth(year, month) {
            return month === 1 && year % 4 === 0 &&
                (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
        }
        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            scope.showWeeks = ctrl.showWeeks;
            ctrl.refreshView();
        };
        this.getDates = function (startDate, n) {
            var dates = new Array(n), current = new Date(startDate), i = 0, date;
            while (i < n) {
                date = new Date(current);
                dates[i++] = date;
                current.setDate(current.getDate() + 1);
            }
            return dates;
        };
        this._refreshView = function () {
            var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
            firstDayOfMonth.setFullYear(year, month, 1);
            var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ?
                7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
            if (numDisplayedFromPreviousMonth > 0) {
                firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
            }
            var days = this.getDates(firstDate, 42);
            for (var i = 0; i < 42; i++) {
                days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
                    secondary: days[i].getMonth() !== month,
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.labels = new Array(7);
            for (var j = 0; j < 7; j++) {
                scope.labels[j] = {
                    abbr: dateFilter(days[j].date, this.formatDayHeader),
                    full: dateFilter(days[j].date, 'EEEE')
                };
            }
            scope.title = dateFilter(this.activeDate, this.formatDayTitle);
            scope.rows = this.split(days, 7);
            if (scope.showWeeks) {
                scope.weekNumbers = [];
                var thursdayIndex = (4 + 7 - this.startingDay) % 7, numWeeks = scope.rows.length;
                for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                    scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
                }
            }
        };
        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };
        function getISO8601WeekNumber(date) {
            var checkDate = new Date(date);
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            var time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        }
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getDate();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - 7;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + 7;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
                this.activeDate.setMonth(month, 1);
                date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
            }
            else if (key === 'home') {
                date = 1;
            }
            else if (key === 'end') {
                date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
            }
            this.activeDate.setDate(date);
        };
    }])
    .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        this.step = { years: 1 };
        this.element = $element;
        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            ctrl.refreshView();
        };
        this._refreshView = function () {
            var months = new Array(12), year = this.activeDate.getFullYear(), date;
            for (var i = 0; i < 12; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(year, i, 1);
                months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
            scope.rows = this.split(months, this.monthColumns);
            scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
        };
        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getMonth();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - this.monthColumns;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + this.monthColumns;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
                this.activeDate.setFullYear(year);
            }
            else if (key === 'home') {
                date = 0;
            }
            else if (key === 'end') {
                date = 11;
            }
            this.activeDate.setMonth(date);
        };
    }])
    .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var columns, range;
        this.element = $element;
        function getStartingYear(year) {
            return parseInt((year - 1) / range, 10) * range + 1;
        }
        this.yearpickerInit = function () {
            columns = this.yearColumns;
            range = this.yearRows * columns;
            this.step = { years: range };
        };
        this._refreshView = function () {
            var years = new Array(range), date;
            for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(start + i, 0, 1);
                years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
                    uid: scope.uniqueId + '-' + i
                });
            }
            scope.title = [years[0].label, years[range - 1].label].join(' - ');
            scope.rows = this.split(years, columns);
            scope.columns = columns;
        };
        this.compare = function (date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
        };
        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getFullYear();
            if (key === 'left') {
                date = date - 1;
            }
            else if (key === 'up') {
                date = date - columns;
            }
            else if (key === 'right') {
                date = date + 1;
            }
            else if (key === 'down') {
                date = date + columns;
            }
            else if (key === 'pageup' || key === 'pagedown') {
                date += (key === 'pageup' ? -1 : 1) * range;
            }
            else if (key === 'home') {
                date = getStartingYear(this.activeDate.getFullYear());
            }
            else if (key === 'end') {
                date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
            }
            this.activeDate.setFullYear(date);
        };
    }])
    .directive('uibDatepicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
        },
        scope: {
            datepickerOptions: '=?'
        },
        require: ['uibDatepicker', '^ngModel'],
        restrict: 'A',
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
})
    .directive('uibDaypicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        restrict: 'A',
        controller: 'UibDaypickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
})
    .directive('uibMonthpicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        restrict: 'A',
        controller: 'UibMonthpickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
})
    .directive('uibYearpicker', function () {
    return {
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        restrict: 'A',
        controller: 'UibYearpickerController',
        link: function (scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]);
            ctrl.yearpickerInit();
            ctrl.refreshView();
        }
    };
});
angular.module('ui.bootstrap.position', [])
    .factory('$uibPosition', ['$document', '$window', function ($document, $window) {
        var SCROLLBAR_WIDTH;
        var BODY_SCROLLBAR_WIDTH;
        var OVERFLOW_REGEX = {
            normal: /(auto|scroll)/,
            hidden: /(auto|scroll|hidden)/
        };
        var PLACEMENT_REGEX = {
            auto: /\s?auto?\s?/i,
            primary: /^(top|bottom|left|right)$/,
            secondary: /^(top|bottom|left|right|center)$/,
            vertical: /^(top|bottom)$/
        };
        var BODY_REGEX = /(HTML|BODY)/;
        return {
            getRawNode: function (elem) {
                return elem.nodeName ? elem : elem[0] || elem;
            },
            parseStyle: function (value) {
                value = parseFloat(value);
                return isFinite(value) ? value : 0;
            },
            offsetParent: function (elem) {
                elem = this.getRawNode(elem);
                var offsetParent = elem.offsetParent || $document[0].documentElement;
                function isStaticPositioned(el) {
                    return ($window.getComputedStyle(el).position || 'static') === 'static';
                }
                while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || $document[0].documentElement;
            },
            scrollbarWidth: function (isBody) {
                if (isBody) {
                    if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                        var bodyElem = $document.find('body');
                        bodyElem.addClass('uib-position-body-scrollbar-measure');
                        BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
                        BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
                        bodyElem.removeClass('uib-position-body-scrollbar-measure');
                    }
                    return BODY_SCROLLBAR_WIDTH;
                }
                if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                    var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                    $document.find('body').append(scrollElem);
                    SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
                    SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
                    scrollElem.remove();
                }
                return SCROLLBAR_WIDTH;
            },
            scrollbarPadding: function (elem) {
                elem = this.getRawNode(elem);
                var elemStyle = $window.getComputedStyle(elem);
                var paddingRight = this.parseStyle(elemStyle.paddingRight);
                var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
                var scrollParent = this.scrollParent(elem, false, true);
                var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));
                return {
                    scrollbarWidth: scrollbarWidth,
                    widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                    right: paddingRight + scrollbarWidth,
                    originalRight: paddingRight,
                    heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                    bottom: paddingBottom + scrollbarWidth,
                    originalBottom: paddingBottom
                };
            },
            isScrollable: function (elem, includeHidden) {
                elem = this.getRawNode(elem);
                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var elemStyle = $window.getComputedStyle(elem);
                return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
            },
            scrollParent: function (elem, includeHidden, includeSelf) {
                elem = this.getRawNode(elem);
                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var documentEl = $document[0].documentElement;
                var elemStyle = $window.getComputedStyle(elem);
                if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
                    return elem;
                }
                var excludeStatic = elemStyle.position === 'absolute';
                var scrollParent = elem.parentElement || documentEl;
                if (scrollParent === documentEl || elemStyle.position === 'fixed') {
                    return documentEl;
                }
                while (scrollParent.parentElement && scrollParent !== documentEl) {
                    var spStyle = $window.getComputedStyle(scrollParent);
                    if (excludeStatic && spStyle.position !== 'static') {
                        excludeStatic = false;
                    }
                    if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
                        break;
                    }
                    scrollParent = scrollParent.parentElement;
                }
                return scrollParent;
            },
            position: function (elem, includeMagins) {
                elem = this.getRawNode(elem);
                var elemOffset = this.offset(elem);
                if (includeMagins) {
                    var elemStyle = $window.getComputedStyle(elem);
                    elemOffset.top -= this.parseStyle(elemStyle.marginTop);
                    elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
                }
                var parent = this.offsetParent(elem);
                var parentOffset = { top: 0, left: 0 };
                if (parent !== $document[0].documentElement) {
                    parentOffset = this.offset(parent);
                    parentOffset.top += parent.clientTop - parent.scrollTop;
                    parentOffset.left += parent.clientLeft - parent.scrollLeft;
                }
                return {
                    width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                    top: Math.round(elemOffset.top - parentOffset.top),
                    left: Math.round(elemOffset.left - parentOffset.left)
                };
            },
            offset: function (elem) {
                elem = this.getRawNode(elem);
                var elemBCR = elem.getBoundingClientRect();
                return {
                    width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                    top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                    left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
                };
            },
            viewportOffset: function (elem, useDocument, includePadding) {
                elem = this.getRawNode(elem);
                includePadding = includePadding !== false ? true : false;
                var elemBCR = elem.getBoundingClientRect();
                var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };
                var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
                var offsetParentBCR = offsetParent.getBoundingClientRect();
                offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
                offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
                if (offsetParent === $document[0].documentElement) {
                    offsetBCR.top += $window.pageYOffset;
                    offsetBCR.left += $window.pageXOffset;
                }
                offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
                offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
                if (includePadding) {
                    var offsetParentStyle = $window.getComputedStyle(offsetParent);
                    offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
                    offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
                    offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
                    offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
                }
                return {
                    top: Math.round(elemBCR.top - offsetBCR.top),
                    bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                    left: Math.round(elemBCR.left - offsetBCR.left),
                    right: Math.round(offsetBCR.right - elemBCR.right)
                };
            },
            parsePlacement: function (placement) {
                var autoPlace = PLACEMENT_REGEX.auto.test(placement);
                if (autoPlace) {
                    placement = placement.replace(PLACEMENT_REGEX.auto, '');
                }
                placement = placement.split('-');
                placement[0] = placement[0] || 'top';
                if (!PLACEMENT_REGEX.primary.test(placement[0])) {
                    placement[0] = 'top';
                }
                placement[1] = placement[1] || 'center';
                if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
                    placement[1] = 'center';
                }
                if (autoPlace) {
                    placement[2] = true;
                }
                else {
                    placement[2] = false;
                }
                return placement;
            },
            positionElements: function (hostElem, targetElem, placement, appendToBody) {
                hostElem = this.getRawNode(hostElem);
                targetElem = this.getRawNode(targetElem);
                var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
                var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
                placement = this.parsePlacement(placement);
                var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
                var targetElemPos = { top: 0, left: 0, placement: '' };
                if (placement[2]) {
                    var viewportOffset = this.viewportOffset(hostElem, appendToBody);
                    var targetElemStyle = $window.getComputedStyle(targetElem);
                    var adjustedSize = {
                        width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                        height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                    };
                    placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                        placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                            placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                                placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                                    placement[0];
                    placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                        placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                            placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                                placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                                    placement[1];
                    if (placement[1] === 'center') {
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                            if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                                placement[1] = 'left';
                            }
                            else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                                placement[1] = 'right';
                            }
                        }
                        else {
                            var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                            if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                                placement[1] = 'top';
                            }
                            else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                                placement[1] = 'bottom';
                            }
                        }
                    }
                }
                switch (placement[0]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top - targetHeight;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left - targetWidth;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width;
                        break;
                }
                switch (placement[1]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                        break;
                    case 'center':
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
                        }
                        else {
                            targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
                        }
                        break;
                }
                targetElemPos.top = Math.round(targetElemPos.top);
                targetElemPos.left = Math.round(targetElemPos.left);
                targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
                return targetElemPos;
            },
            adjustTop: function (placementClasses, containerPosition, initialHeight, currentHeight) {
                if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
                    return {
                        top: containerPosition.top - currentHeight + 'px'
                    };
                }
            },
            positionArrow: function (elem, placement) {
                elem = this.getRawNode(elem);
                var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
                if (!innerElem) {
                    return;
                }
                var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
                var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
                if (!arrowElem) {
                    return;
                }
                var arrowCss = {
                    top: '',
                    bottom: '',
                    left: '',
                    right: ''
                };
                placement = this.parsePlacement(placement);
                if (placement[1] === 'center') {
                    angular.element(arrowElem).css(arrowCss);
                    return;
                }
                var borderProp = 'border-' + placement[0] + '-width';
                var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
                var borderRadiusProp = 'border-';
                if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    borderRadiusProp += placement[0] + '-' + placement[1];
                }
                else {
                    borderRadiusProp += placement[1] + '-' + placement[0];
                }
                borderRadiusProp += '-radius';
                var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                switch (placement[0]) {
                    case 'top':
                        arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'bottom':
                        arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'left':
                        arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'right':
                        arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
                        break;
                }
                arrowCss[placement[1]] = borderRadius;
                angular.element(arrowElem).css(arrowCss);
            }
        };
    }]);
angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])
    .value('$datepickerPopupLiteralWarning', true)
    .constant('uibDatepickerPopupConfig', {
    altInputFormats: [],
    appendToBody: false,
    clearText: 'Clear',
    closeOnDateSelection: true,
    closeText: 'Done',
    currentText: 'Today',
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
    datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
    html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
    },
    onOpenFocus: true,
    showButtonBar: true,
    placement: 'auto bottom-left'
})
    .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
    function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
        var cache = {}, isHtml5DateInput = false;
        var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];
        this.init = function (_ngModel_) {
            ngModel = _ngModel_;
            ngModelOptions = extractOptions(ngModel);
            closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
                $scope.$parent.$eval($attrs.closeOnDateSelection) :
                datepickerPopupConfig.closeOnDateSelection;
            appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
                $scope.$parent.$eval($attrs.datepickerAppendToBody) :
                datepickerPopupConfig.appendToBody;
            onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
                $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
            datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
                $attrs.datepickerPopupTemplateUrl :
                datepickerPopupConfig.datepickerPopupTemplateUrl;
            datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
                $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
            altInputFormats = angular.isDefined($attrs.altInputFormats) ?
                $scope.$parent.$eval($attrs.altInputFormats) :
                datepickerPopupConfig.altInputFormats;
            $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
                $scope.$parent.$eval($attrs.showButtonBar) :
                datepickerPopupConfig.showButtonBar;
            if (datepickerPopupConfig.html5Types[$attrs.type]) {
                dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
                isHtml5DateInput = true;
            }
            else {
                dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
                $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
                    var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                    if (newDateFormat !== dateFormat) {
                        dateFormat = newDateFormat;
                        ngModel.$modelValue = null;
                        if (!dateFormat) {
                            throw new Error('uibDatepickerPopup must have a date format specified.');
                        }
                    }
                });
            }
            if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
            }
            if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
                throw new Error('HTML5 date input types do not support custom formats.');
            }
            popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
            popupEl.attr({
                'ng-model': 'date',
                'ng-change': 'dateSelection(date)',
                'template-url': datepickerPopupTemplateUrl
            });
            datepickerEl = angular.element(popupEl.children()[0]);
            datepickerEl.attr('template-url', datepickerTemplateUrl);
            if (!$scope.datepickerOptions) {
                $scope.datepickerOptions = {};
            }
            if (isHtml5DateInput) {
                if ($attrs.type === 'month') {
                    $scope.datepickerOptions.datepickerMode = 'month';
                    $scope.datepickerOptions.minMode = 'month';
                }
            }
            datepickerEl.attr('datepicker-options', 'datepickerOptions');
            if (!isHtml5DateInput) {
                ngModel.$$parserName = 'date';
                ngModel.$validators.date = validator;
                ngModel.$parsers.unshift(parseDate);
                ngModel.$formatters.push(function (value) {
                    if (ngModel.$isEmpty(value)) {
                        $scope.date = value;
                        return value;
                    }
                    if (angular.isNumber(value)) {
                        value = new Date(value);
                    }
                    $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
                    return dateParser.filter($scope.date, dateFormat);
                });
            }
            else {
                ngModel.$formatters.push(function (value) {
                    $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
                    return value;
                });
            }
            ngModel.$viewChangeListeners.push(function () {
                $scope.date = parseDateString(ngModel.$viewValue);
            });
            $element.on('keydown', inputKeydownBind);
            $popup = $compile(popupEl)($scope);
            popupEl.remove();
            if (appendToBody) {
                $document.find('body').append($popup);
            }
            else {
                $element.after($popup);
            }
            $scope.$on('$destroy', function () {
                if ($scope.isOpen === true) {
                    if (!$rootScope.$$phase) {
                        $scope.$apply(function () {
                            $scope.isOpen = false;
                        });
                    }
                }
                $popup.remove();
                $element.off('keydown', inputKeydownBind);
                $document.off('click', documentClickBind);
                if (scrollParentEl) {
                    scrollParentEl.off('scroll', positionPopup);
                }
                angular.element($window).off('resize', positionPopup);
                while (watchListeners.length) {
                    watchListeners.shift()();
                }
            });
        };
        $scope.getText = function (key) {
            return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
        };
        $scope.isDisabled = function (date) {
            if (date === 'today') {
                date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
            }
            var dates = {};
            angular.forEach(['minDate', 'maxDate'], function (key) {
                if (!$scope.datepickerOptions[key]) {
                    dates[key] = null;
                }
                else if (angular.isDate($scope.datepickerOptions[key])) {
                    dates[key] = new Date($scope.datepickerOptions[key]);
                }
                else {
                    if ($datepickerPopupLiteralWarning) {
                        $log.warn('Literal date support has been deprecated, please switch to date object usage');
                    }
                    dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
                }
            });
            return $scope.datepickerOptions &&
                dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
                dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
        };
        $scope.compare = function (date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        };
        $scope.dateSelection = function (dt) {
            $scope.date = dt;
            var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
            $element.val(date);
            ngModel.$setViewValue(date);
            if (closeOnDateSelection) {
                $scope.isOpen = false;
                $element[0].focus();
            }
        };
        $scope.keydown = function (evt) {
            if (evt.which === 27) {
                evt.stopPropagation();
                $scope.isOpen = false;
                $element[0].focus();
            }
        };
        $scope.select = function (date, evt) {
            evt.stopPropagation();
            if (date === 'today') {
                var today = new Date();
                if (angular.isDate($scope.date)) {
                    date = new Date($scope.date);
                    date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
                }
                else {
                    date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
                    date.setHours(0, 0, 0, 0);
                }
            }
            $scope.dateSelection(date);
        };
        $scope.close = function (evt) {
            evt.stopPropagation();
            $scope.isOpen = false;
            $element[0].focus();
        };
        $scope.disabled = angular.isDefined($attrs.disabled) || false;
        if ($attrs.ngDisabled) {
            watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
                $scope.disabled = disabled;
            }));
        }
        $scope.$watch('isOpen', function (value) {
            if (value) {
                if (!$scope.disabled) {
                    $timeout(function () {
                        positionPopup();
                        if (onOpenFocus) {
                            $scope.$broadcast('uib:datepicker.focus');
                        }
                        $document.on('click', documentClickBind);
                        var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                        if (appendToBody || $position.parsePlacement(placement)[2]) {
                            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                            if (scrollParentEl) {
                                scrollParentEl.on('scroll', positionPopup);
                            }
                        }
                        else {
                            scrollParentEl = null;
                        }
                        angular.element($window).on('resize', positionPopup);
                    }, 0, false);
                }
                else {
                    $scope.isOpen = false;
                }
            }
            else {
                $document.off('click', documentClickBind);
                if (scrollParentEl) {
                    scrollParentEl.off('scroll', positionPopup);
                }
                angular.element($window).off('resize', positionPopup);
            }
        });
        function cameltoDash(string) {
            return string.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
        }
        function parseDateString(viewValue) {
            var date = dateParser.parse(viewValue, dateFormat, $scope.date);
            if (isNaN(date)) {
                for (var i = 0; i < altInputFormats.length; i++) {
                    date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
                    if (!isNaN(date)) {
                        return date;
                    }
                }
            }
            return date;
        }
        function parseDate(viewValue) {
            if (angular.isNumber(viewValue)) {
                viewValue = new Date(viewValue);
            }
            if (!viewValue) {
                return null;
            }
            if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                return viewValue;
            }
            if (angular.isString(viewValue)) {
                var date = parseDateString(viewValue);
                if (!isNaN(date)) {
                    return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
                }
            }
            return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
        }
        function validator(modelValue, viewValue) {
            var value = modelValue || viewValue;
            if (!$attrs.ngRequired && !value) {
                return true;
            }
            if (angular.isNumber(value)) {
                value = new Date(value);
            }
            if (!value) {
                return true;
            }
            if (angular.isDate(value) && !isNaN(value)) {
                return true;
            }
            if (angular.isString(value)) {
                return !isNaN(parseDateString(value));
            }
            return false;
        }
        function documentClickBind(event) {
            if (!$scope.isOpen && $scope.disabled) {
                return;
            }
            var popup = $popup[0];
            var dpContainsTarget = $element[0].contains(event.target);
            var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
            if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
                $scope.$apply(function () {
                    $scope.isOpen = false;
                });
            }
        }
        function inputKeydownBind(evt) {
            if (evt.which === 27 && $scope.isOpen) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.$apply(function () {
                    $scope.isOpen = false;
                });
                $element[0].focus();
            }
            else if (evt.which === 40 && !$scope.isOpen) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.$apply(function () {
                    $scope.isOpen = true;
                });
            }
        }
        function positionPopup() {
            if ($scope.isOpen) {
                var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
                var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                var position = $position.positionElements($element, dpElement, placement, appendToBody);
                dpElement.css({ top: position.top + 'px', left: position.left + 'px' });
                if (dpElement.hasClass('uib-position-measure')) {
                    dpElement.removeClass('uib-position-measure');
                }
            }
        }
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = angular.isObject(ngModelCtrl.$options) ?
                    ngModelCtrl.$options :
                    {
                        timezone: null
                    };
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                ngModelOptions = ngModelCtrl.$options;
            }
            return ngModelOptions;
        }
        $scope.$on('uib:datepicker.mode', function () {
            $timeout(positionPopup, 0, false);
        });
    }])
    .directive('uibDatepickerPopup', function () {
    return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
            datepickerOptions: '=?',
            isOpen: '=?',
            currentText: '@',
            clearText: '@',
            closeText: '@'
        },
        link: function (scope, element, attrs, ctrls) {
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
})
    .directive('uibDatepickerPopupWrap', function () {
    return {
        restrict: 'A',
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
        }
    };
});
angular.module('ui.bootstrap.debounce', [])
    .factory('$$debounce', ['$timeout', function ($timeout) {
        return function (callback, debounceTime) {
            var timeoutPromise;
            return function () {
                var self = this;
                var args = Array.prototype.slice.call(arguments);
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }
                timeoutPromise = $timeout(function () {
                    callback.apply(self, args);
                }, debounceTime);
            };
        };
    }]);
angular.module('ui.bootstrap.multiMap', [])
    .factory('$$multiMap', function () {
    return {
        createNew: function () {
            var map = {};
            return {
                entries: function () {
                    return Object.keys(map).map(function (key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function (key) {
                    return map[key];
                },
                hasKey: function (key) {
                    return !!map[key];
                },
                keys: function () {
                    return Object.keys(map);
                },
                put: function (key, value) {
                    if (!map[key]) {
                        map[key] = [];
                    }
                    map[key].push(value);
                },
                remove: function (key, value) {
                    var values = map[key];
                    if (!values) {
                        return;
                    }
                    var idx = values.indexOf(value);
                    if (idx !== -1) {
                        values.splice(idx, 1);
                    }
                    if (!values.length) {
                        delete map[key];
                    }
                }
            };
        }
    };
});
angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])
    .constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
})
    .service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function ($document, $rootScope, $$multiMap) {
        var openScope = null;
        var openedContainers = $$multiMap.createNew();
        this.isOnlyOpen = function (dropdownScope, appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openDropdown = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }
                    return toClose;
                }, {});
                if (openDropdown) {
                    return openedDropdowns.length === 1;
                }
            }
            return false;
        };
        this.open = function (dropdownScope, element, appendTo) {
            if (!openScope) {
                $document.on('click', closeDropdown);
            }
            if (openScope && openScope !== dropdownScope) {
                openScope.isOpen = false;
            }
            openScope = dropdownScope;
            if (!appendTo) {
                return;
            }
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openedScopes = openedDropdowns.map(function (dropdown) {
                    return dropdown.scope;
                });
                if (openedScopes.indexOf(dropdownScope) === -1) {
                    openedContainers.put(appendTo, {
                        scope: dropdownScope
                    });
                }
            }
            else {
                openedContainers.put(appendTo, {
                    scope: dropdownScope
                });
            }
        };
        this.close = function (dropdownScope, element, appendTo) {
            if (openScope === dropdownScope) {
                $document.off('click', closeDropdown);
                $document.off('keydown', this.keybindFilter);
                openScope = null;
            }
            if (!appendTo) {
                return;
            }
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var dropdownToClose = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }
                    return toClose;
                }, {});
                if (dropdownToClose) {
                    openedContainers.remove(appendTo, dropdownToClose);
                }
            }
        };
        var closeDropdown = function (evt) {
            if (!openScope || !openScope.isOpen) {
                return;
            }
            if (evt && openScope.getAutoClose() === 'disabled') {
                return;
            }
            if (evt && evt.which === 3) {
                return;
            }
            var toggleElement = openScope.getToggleElement();
            if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
                return;
            }
            var dropdownElement = openScope.getDropdownElement();
            if (evt && openScope.getAutoClose() === 'outsideClick' &&
                dropdownElement && dropdownElement[0].contains(evt.target)) {
                return;
            }
            openScope.focusToggleElement();
            openScope.isOpen = false;
            if (!$rootScope.$$phase) {
                openScope.$apply();
            }
        };
        this.keybindFilter = function (evt) {
            if (!openScope) {
                return;
            }
            var dropdownElement = openScope.getDropdownElement();
            var toggleElement = openScope.getToggleElement();
            var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
            var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            if (evt.which === 27) {
                evt.stopPropagation();
                openScope.focusToggleElement();
                closeDropdown();
            }
            else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
                evt.preventDefault();
                evt.stopPropagation();
                openScope.focusDropdownEntry(evt.which);
            }
        };
    }])
    .controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
        var self = this, scope = $scope.$new(), templateScope, appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, getIsOpen, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, keynavEnabled = false, selectedOption = null, body = $document.find('body');
        $element.addClass('dropdown');
        this.init = function () {
            if ($attrs.isOpen) {
                getIsOpen = $parse($attrs.isOpen);
                setIsOpen = getIsOpen.assign;
                $scope.$watch(getIsOpen, function (value) {
                    scope.isOpen = !!value;
                });
            }
            keynavEnabled = angular.isDefined($attrs.keyboardNav);
        };
        this.toggle = function (open) {
            scope.isOpen = arguments.length ? !!open : !scope.isOpen;
            if (angular.isFunction(setIsOpen)) {
                setIsOpen(scope, scope.isOpen);
            }
            return scope.isOpen;
        };
        this.isOpen = function () {
            return scope.isOpen;
        };
        scope.getToggleElement = function () {
            return self.toggleElement;
        };
        scope.getAutoClose = function () {
            return $attrs.autoClose || 'always';
        };
        scope.getElement = function () {
            return $element;
        };
        scope.isKeynavEnabled = function () {
            return keynavEnabled;
        };
        scope.focusDropdownEntry = function (keyCode) {
            var elems = self.dropdownMenu ?
                angular.element(self.dropdownMenu).find('a') :
                $element.find('ul').eq(0).find('a');
            switch (keyCode) {
                case 40: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = 0;
                    }
                    else {
                        self.selectedOption = self.selectedOption === elems.length - 1 ?
                            self.selectedOption :
                            self.selectedOption + 1;
                    }
                    break;
                }
                case 38: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = elems.length - 1;
                    }
                    else {
                        self.selectedOption = self.selectedOption === 0 ?
                            0 : self.selectedOption - 1;
                    }
                    break;
                }
            }
            elems[self.selectedOption].focus();
        };
        scope.getDropdownElement = function () {
            return self.dropdownMenu;
        };
        scope.focusToggleElement = function () {
            if (self.toggleElement) {
                self.toggleElement[0].focus();
            }
        };
        function removeDropdownMenu() {
            $element.append(self.dropdownMenu);
        }
        scope.$watch('isOpen', function (isOpen, wasOpen) {
            var appendTo = null, appendToBody = false;
            if (angular.isDefined($attrs.dropdownAppendTo)) {
                var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
                if (appendToEl) {
                    appendTo = angular.element(appendToEl);
                }
            }
            if (angular.isDefined($attrs.dropdownAppendToBody)) {
                var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
                if (appendToBodyValue !== false) {
                    appendToBody = true;
                }
            }
            if (appendToBody && !appendTo) {
                appendTo = body;
            }
            if (appendTo && self.dropdownMenu) {
                if (isOpen) {
                    appendTo.append(self.dropdownMenu);
                    $element.on('$destroy', removeDropdownMenu);
                }
                else {
                    $element.off('$destroy', removeDropdownMenu);
                    removeDropdownMenu();
                }
            }
            if (appendTo && self.dropdownMenu) {
                var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true), css, rightalign, scrollbarPadding, scrollbarWidth = 0;
                css = {
                    top: pos.top + 'px',
                    display: isOpen ? 'block' : 'none'
                };
                rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
                if (!rightalign) {
                    css.left = pos.left + 'px';
                    css.right = 'auto';
                }
                else {
                    css.left = 'auto';
                    scrollbarPadding = $position.scrollbarPadding(appendTo);
                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        scrollbarWidth = scrollbarPadding.scrollbarWidth;
                    }
                    css.right = window.innerWidth - scrollbarWidth -
                        (pos.left + $element.prop('offsetWidth')) + 'px';
                }
                if (!appendToBody) {
                    var appendOffset = $position.offset(appendTo);
                    css.top = pos.top - appendOffset.top + 'px';
                    if (!rightalign) {
                        css.left = pos.left - appendOffset.left + 'px';
                    }
                    else {
                        css.right = window.innerWidth -
                            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
                    }
                }
                self.dropdownMenu.css(css);
            }
            var openContainer = appendTo ? appendTo : $element;
            var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
            var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
            var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);
            if (hasOpenClass === !isOpen) {
                var toggleClass;
                if (appendTo) {
                    toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
                }
                else {
                    toggleClass = isOpen ? 'addClass' : 'removeClass';
                }
                $animate[toggleClass](openContainer, dropdownOpenClass).then(function () {
                    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                        toggleInvoker($scope, { open: !!isOpen });
                    }
                });
            }
            if (isOpen) {
                if (self.dropdownMenuTemplateUrl) {
                    $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
                        templateScope = scope.$new();
                        $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                            var newEl = dropdownElement;
                            self.dropdownMenu.replaceWith(newEl);
                            self.dropdownMenu = newEl;
                            $document.on('keydown', uibDropdownService.keybindFilter);
                        });
                    });
                }
                else {
                    $document.on('keydown', uibDropdownService.keybindFilter);
                }
                scope.focusToggleElement();
                uibDropdownService.open(scope, $element, appendTo);
            }
            else {
                uibDropdownService.close(scope, $element, appendTo);
                if (self.dropdownMenuTemplateUrl) {
                    if (templateScope) {
                        templateScope.$destroy();
                    }
                    var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                    self.dropdownMenu.replaceWith(newEl);
                    self.dropdownMenu = newEl;
                }
                self.selectedOption = null;
            }
            if (angular.isFunction(setIsOpen)) {
                setIsOpen($scope, isOpen);
            }
        });
    }])
    .directive('uibDropdown', function () {
    return {
        controller: 'UibDropdownController',
        link: function (scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
})
    .directive('uibDropdownMenu', function () {
    return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
                return;
            }
            element.addClass('dropdown-menu');
            var tplUrl = attrs.templateUrl;
            if (tplUrl) {
                dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
            }
            if (!dropdownCtrl.dropdownMenu) {
                dropdownCtrl.dropdownMenu = element;
            }
        }
    };
})
    .directive('uibDropdownToggle', function () {
    return {
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return;
            }
            element.addClass('dropdown-toggle');
            dropdownCtrl.toggleElement = element;
            var toggleDropdown = function (event) {
                event.preventDefault();
                if (!element.hasClass('disabled') && !attrs.disabled) {
                    scope.$apply(function () {
                        dropdownCtrl.toggle();
                    });
                }
            };
            element.on('click', toggleDropdown);
            element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
            scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                element.attr('aria-expanded', !!isOpen);
            });
            scope.$on('$destroy', function () {
                element.off('click', toggleDropdown);
            });
        }
    };
});
angular.module('ui.bootstrap.stackedMap', [])
    .factory('$$stackedMap', function () {
    return {
        createNew: function () {
            var stack = [];
            return {
                add: function (key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function (key) {
                    for (var i = 0; i < stack.length; i++) {
                        if (key === stack[i].key) {
                            return stack[i];
                        }
                    }
                },
                keys: function () {
                    var keys = [];
                    for (var i = 0; i < stack.length; i++) {
                        keys.push(stack[i].key);
                    }
                    return keys;
                },
                top: function () {
                    return stack[stack.length - 1];
                },
                remove: function (key) {
                    var idx = -1;
                    for (var i = 0; i < stack.length; i++) {
                        if (key === stack[i].key) {
                            idx = i;
                            break;
                        }
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function () {
                    return stack.pop();
                },
                length: function () {
                    return stack.length;
                }
            };
        }
    };
});
angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
    .provider('$uibResolve', function () {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function (resolver) {
        this.resolver = resolver;
    };
    this.$get = ['$injector', '$q', function ($injector, $q) {
            var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
            return {
                resolve: function (invocables, locals, parent, self) {
                    if (resolver) {
                        return resolver.resolve(invocables, locals, parent, self);
                    }
                    var promises = [];
                    angular.forEach(invocables, function (value) {
                        if (angular.isFunction(value) || angular.isArray(value)) {
                            promises.push($q.resolve($injector.invoke(value)));
                        }
                        else if (angular.isString(value)) {
                            promises.push($q.resolve($injector.get(value)));
                        }
                        else {
                            promises.push($q.resolve(value));
                        }
                    });
                    return $q.all(promises).then(function (resolves) {
                        var resolveObj = {};
                        var resolveIter = 0;
                        angular.forEach(invocables, function (value, key) {
                            resolveObj[key] = resolves[resolveIter++];
                        });
                        return resolveObj;
                    });
                }
            };
        }];
})
    .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
    function ($animate, $injector, $modalStack) {
        return {
            restrict: 'A',
            compile: function (tElement, tAttrs) {
                tElement.addClass(tAttrs.backdropClass);
                return linkFn;
            }
        };
        function linkFn(scope, element, attrs) {
            if (attrs.modalInClass) {
                $animate.addClass(element, attrs.modalInClass);
                scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                    var done = setIsAsync();
                    if (scope.modalOptions.animation) {
                        $animate.removeClass(element, attrs.modalInClass).then(done);
                    }
                    else {
                        done();
                    }
                });
            }
        }
    }])
    .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
    function ($modalStack, $q, $animateCss, $document) {
        return {
            scope: {
                index: '@'
            },
            restrict: 'A',
            transclude: true,
            templateUrl: function (tElement, tAttrs) {
                return tAttrs.templateUrl || 'uib/template/modal/window.html';
            },
            link: function (scope, element, attrs) {
                element.addClass(attrs.windowTopClass || '');
                scope.size = attrs.size;
                scope.close = function (evt) {
                    var modal = $modalStack.getTop();
                    if (modal && modal.value.backdrop &&
                        modal.value.backdrop !== 'static' &&
                        evt.target === evt.currentTarget) {
                        evt.preventDefault();
                        evt.stopPropagation();
                        $modalStack.dismiss(modal.key, 'backdrop click');
                    }
                };
                element.on('click', scope.close);
                scope.$isRendered = true;
                var modalRenderDeferObj = $q.defer();
                scope.$$postDigest(function () {
                    modalRenderDeferObj.resolve();
                });
                modalRenderDeferObj.promise.then(function () {
                    var animationPromise = null;
                    if (attrs.modalInClass) {
                        animationPromise = $animateCss(element, {
                            addClass: attrs.modalInClass
                        }).start();
                        scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                            var done = setIsAsync();
                            $animateCss(element, {
                                removeClass: attrs.modalInClass
                            }).start().then(done);
                        });
                    }
                    $q.when(animationPromise).then(function () {
                        var modal = $modalStack.getTop();
                        if (modal) {
                            $modalStack.modalRendered(modal.key);
                        }
                        if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                            var inputWithAutofocus = element[0].querySelector('[autofocus]');
                            if (inputWithAutofocus) {
                                inputWithAutofocus.focus();
                            }
                            else {
                                element[0].focus();
                            }
                        }
                    });
                });
            }
        };
    }])
    .directive('uibModalAnimationClass', function () {
    return {
        compile: function (tElement, tAttrs) {
            if (tAttrs.modalAnimation) {
                tElement.addClass(tAttrs.uibModalAnimationClass);
            }
        }
    };
})
    .directive('uibModalTransclude', ['$animate', function ($animate) {
        return {
            link: function (scope, element, attrs, controller, transclude) {
                transclude(scope.$parent, function (clone) {
                    element.empty();
                    $animate.enter(clone, element);
                });
            }
        };
    }])
    .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
        var OPENED_MODAL_CLASS = 'modal-open';
        var backdropDomEl, backdropScope;
        var openedWindows = $$stackedMap.createNew();
        var openedClasses = $$multiMap.createNew();
        var $modalStack = {
            NOW_CLOSING_EVENT: 'modal.stack.now-closing'
        };
        var topModalIndex = 0;
        var previousTopOpenedModal = null;
        var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';
        var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
            'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
            'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
        var scrollbarPadding;
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name) {
            var separator = '-';
            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }
        function isVisible(element) {
            return !!(element.offsetWidth ||
                element.offsetHeight ||
                element.getClientRects().length);
        }
        function backdropIndex() {
            var topBackdropIndex = -1;
            var opened = openedWindows.keys();
            for (var i = 0; i < opened.length; i++) {
                if (openedWindows.get(opened[i]).value.backdrop) {
                    topBackdropIndex = i;
                }
            }
            if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
                topBackdropIndex = topModalIndex;
            }
            return topBackdropIndex;
        }
        $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
            if (backdropScope) {
                backdropScope.index = newBackdropIndex;
            }
        });
        function removeModalWindow(modalInstance, elementToReceiveFocus) {
            var modalWindow = openedWindows.get(modalInstance).value;
            var appendToElement = modalWindow.appendTo;
            openedWindows.remove(modalInstance);
            previousTopOpenedModal = openedWindows.top();
            if (previousTopOpenedModal) {
                topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
            }
            removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
                var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
                openedClasses.remove(modalBodyClass, modalInstance);
                var areAnyOpen = openedClasses.hasKey(modalBodyClass);
                appendToElement.toggleClass(modalBodyClass, areAnyOpen);
                if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                    if (scrollbarPadding.originalRight) {
                        appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
                    }
                    else {
                        appendToElement.css({ paddingRight: '' });
                    }
                    scrollbarPadding = null;
                }
                toggleTopWindowClass(true);
            }, modalWindow.closedDeferred);
            checkRemoveBackdrop();
            if (elementToReceiveFocus && elementToReceiveFocus.focus) {
                elementToReceiveFocus.focus();
            }
            else if (appendToElement.focus) {
                appendToElement.focus();
            }
        }
        function toggleTopWindowClass(toggleSwitch) {
            var modalWindow;
            if (openedWindows.length() > 0) {
                modalWindow = openedWindows.top().value;
                modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
            }
        }
        function checkRemoveBackdrop() {
            if (backdropDomEl && backdropIndex() === -1) {
                var backdropScopeRef = backdropScope;
                removeAfterAnimate(backdropDomEl, backdropScope, function () {
                    backdropScopeRef = null;
                });
                backdropDomEl = undefined;
                backdropScope = undefined;
            }
        }
        function removeAfterAnimate(domEl, scope, done, closedDeferred) {
            var asyncDeferred;
            var asyncPromise = null;
            var setIsAsync = function () {
                if (!asyncDeferred) {
                    asyncDeferred = $q.defer();
                    asyncPromise = asyncDeferred.promise;
                }
                return function asyncDone() {
                    asyncDeferred.resolve();
                };
            };
            scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
            return $q.when(asyncPromise).then(afterAnimating);
            function afterAnimating() {
                if (afterAnimating.done) {
                    return;
                }
                afterAnimating.done = true;
                $animate.leave(domEl).then(function () {
                    if (done) {
                        done();
                    }
                    domEl.remove();
                    if (closedDeferred) {
                        closedDeferred.resolve();
                    }
                });
                scope.$destroy();
            }
        }
        $document.on('keydown', keydownListener);
        $rootScope.$on('$destroy', function () {
            $document.off('keydown', keydownListener);
        });
        function keydownListener(evt) {
            if (evt.isDefaultPrevented()) {
                return evt;
            }
            var modal = openedWindows.top();
            if (modal) {
                switch (evt.which) {
                    case 27: {
                        if (modal.value.keyboard) {
                            evt.preventDefault();
                            $rootScope.$apply(function () {
                                $modalStack.dismiss(modal.key, 'escape key press');
                            });
                        }
                        break;
                    }
                    case 9: {
                        var list = $modalStack.loadFocusElementList(modal);
                        var focusChanged = false;
                        if (evt.shiftKey) {
                            if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                                focusChanged = $modalStack.focusLastFocusableElement(list);
                            }
                        }
                        else {
                            if ($modalStack.isFocusInLastItem(evt, list)) {
                                focusChanged = $modalStack.focusFirstFocusableElement(list);
                            }
                        }
                        if (focusChanged) {
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        break;
                    }
                }
            }
        }
        $modalStack.open = function (modalInstance, modal) {
            var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
            toggleTopWindowClass(false);
            previousTopOpenedModal = openedWindows.top();
            openedWindows.add(modalInstance, {
                deferred: modal.deferred,
                renderDeferred: modal.renderDeferred,
                closedDeferred: modal.closedDeferred,
                modalScope: modal.scope,
                backdrop: modal.backdrop,
                keyboard: modal.keyboard,
                openedClass: modal.openedClass,
                windowTopClass: modal.windowTopClass,
                animation: modal.animation,
                appendTo: modal.appendTo
            });
            openedClasses.put(modalBodyClass, modalInstance);
            var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
            if (currBackdropIndex >= 0 && !backdropDomEl) {
                backdropScope = $rootScope.$new(true);
                backdropScope.modalOptions = modal;
                backdropScope.index = currBackdropIndex;
                backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
                backdropDomEl.attr({
                    'class': 'modal-backdrop',
                    'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
                    'uib-modal-animation-class': 'fade',
                    'modal-in-class': 'in'
                });
                if (modal.backdropClass) {
                    backdropDomEl.addClass(modal.backdropClass);
                }
                if (modal.animation) {
                    backdropDomEl.attr('modal-animation', 'true');
                }
                $compile(backdropDomEl)(backdropScope);
                $animate.enter(backdropDomEl, appendToElement);
                if ($uibPosition.isScrollable(appendToElement)) {
                    scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
                    }
                }
            }
            var content;
            if (modal.component) {
                content = document.createElement(snake_case(modal.component.name));
                content = angular.element(content);
                content.attr({
                    resolve: '$resolve',
                    'modal-instance': '$uibModalInstance',
                    close: '$close($value)',
                    dismiss: '$dismiss($value)'
                });
            }
            else {
                content = modal.content;
            }
            topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
            var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
            angularDomEl.attr({
                'class': 'modal',
                'template-url': modal.windowTemplateUrl,
                'window-top-class': modal.windowTopClass,
                'role': 'dialog',
                'aria-labelledby': modal.ariaLabelledBy,
                'aria-describedby': modal.ariaDescribedBy,
                'size': modal.size,
                'index': topModalIndex,
                'animate': 'animate',
                'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
                'tabindex': -1,
                'uib-modal-animation-class': 'fade',
                'modal-in-class': 'in'
            }).append(content);
            if (modal.windowClass) {
                angularDomEl.addClass(modal.windowClass);
            }
            if (modal.animation) {
                angularDomEl.attr('modal-animation', 'true');
            }
            appendToElement.addClass(modalBodyClass);
            if (modal.scope) {
                modal.scope.$$topModalIndex = topModalIndex;
            }
            $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
            openedWindows.top().value.modalDomEl = angularDomEl;
            openedWindows.top().value.modalOpener = modalOpener;
            applyAriaHidden(angularDomEl);
            function applyAriaHidden(el) {
                if (!el || el[0].tagName === 'BODY') {
                    return;
                }
                getSiblings(el).forEach(function (sibling) {
                    var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true', ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);
                    if (!ariaHiddenCount) {
                        ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
                    }
                    sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
                    sibling.setAttribute('aria-hidden', 'true');
                });
                return applyAriaHidden(el.parent());
                function getSiblings(el) {
                    var children = el.parent() ? el.parent().children() : [];
                    return Array.prototype.filter.call(children, function (child) {
                        return child !== el[0];
                    });
                }
            }
        };
        function broadcastClosing(modalWindow, resultOrReason, closing) {
            return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
        }
        function unhideBackgroundElements() {
            Array.prototype.forEach.call(document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'), function (hiddenEl) {
                var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10), newHiddenCount = ariaHiddenCount - 1;
                hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);
                if (!newHiddenCount) {
                    hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
                    hiddenEl.removeAttribute('aria-hidden');
                }
            });
        }
        $modalStack.close = function (modalInstance, result) {
            var modalWindow = openedWindows.get(modalInstance);
            unhideBackgroundElements();
            if (modalWindow && broadcastClosing(modalWindow, result, true)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.resolve(result);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };
        $modalStack.dismiss = function (modalInstance, reason) {
            var modalWindow = openedWindows.get(modalInstance);
            unhideBackgroundElements();
            if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.reject(reason);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };
        $modalStack.dismissAll = function (reason) {
            var topModal = this.getTop();
            while (topModal && this.dismiss(topModal.key, reason)) {
                topModal = this.getTop();
            }
        };
        $modalStack.getTop = function () {
            return openedWindows.top();
        };
        $modalStack.modalRendered = function (modalInstance) {
            var modalWindow = openedWindows.get(modalInstance);
            if (modalWindow) {
                modalWindow.value.renderDeferred.resolve();
            }
        };
        $modalStack.focusFirstFocusableElement = function (list) {
            if (list.length > 0) {
                list[0].focus();
                return true;
            }
            return false;
        };
        $modalStack.focusLastFocusableElement = function (list) {
            if (list.length > 0) {
                list[list.length - 1].focus();
                return true;
            }
            return false;
        };
        $modalStack.isModalFocused = function (evt, modalWindow) {
            if (evt && modalWindow) {
                var modalDomEl = modalWindow.value.modalDomEl;
                if (modalDomEl && modalDomEl.length) {
                    return (evt.target || evt.srcElement) === modalDomEl[0];
                }
            }
            return false;
        };
        $modalStack.isFocusInFirstItem = function (evt, list) {
            if (list.length > 0) {
                return (evt.target || evt.srcElement) === list[0];
            }
            return false;
        };
        $modalStack.isFocusInLastItem = function (evt, list) {
            if (list.length > 0) {
                return (evt.target || evt.srcElement) === list[list.length - 1];
            }
            return false;
        };
        $modalStack.loadFocusElementList = function (modalWindow) {
            if (modalWindow) {
                var modalDomE1 = modalWindow.value.modalDomEl;
                if (modalDomE1 && modalDomE1.length) {
                    var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                    return elements ?
                        Array.prototype.filter.call(elements, function (element) {
                            return isVisible(element);
                        }) : elements;
                }
            }
        };
        return $modalStack;
    }])
    .provider('$uibModal', function () {
    var $modalProvider = {
        options: {
            animation: true,
            backdrop: true,
            keyboard: true
        },
        $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
            function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
                var $modal = {};
                function getTemplatePromise(options) {
                    return options.template ? $q.when(options.template) :
                        $templateRequest(angular.isFunction(options.templateUrl) ?
                            options.templateUrl() : options.templateUrl);
                }
                var promiseChain = null;
                $modal.getPromiseChain = function () {
                    return promiseChain;
                };
                $modal.open = function (modalOptions) {
                    var modalResultDeferred = $q.defer();
                    var modalOpenedDeferred = $q.defer();
                    var modalClosedDeferred = $q.defer();
                    var modalRenderDeferred = $q.defer();
                    var modalInstance = {
                        result: modalResultDeferred.promise,
                        opened: modalOpenedDeferred.promise,
                        closed: modalClosedDeferred.promise,
                        rendered: modalRenderDeferred.promise,
                        close: function (result) {
                            return $modalStack.close(modalInstance, result);
                        },
                        dismiss: function (reason) {
                            return $modalStack.dismiss(modalInstance, reason);
                        }
                    };
                    modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                    modalOptions.resolve = modalOptions.resolve || {};
                    modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
                    if (!modalOptions.appendTo.length) {
                        throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
                    }
                    if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
                        throw new Error('One of component or template or templateUrl options is required.');
                    }
                    var templateAndResolvePromise;
                    if (modalOptions.component) {
                        templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
                    }
                    else {
                        templateAndResolvePromise =
                            $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
                    }
                    function resolveWithTemplate() {
                        return templateAndResolvePromise;
                    }
                    var samePromise;
                    samePromise = promiseChain = $q.all([promiseChain])
                        .then(resolveWithTemplate, resolveWithTemplate)
                        .then(function resolveSuccess(tplAndVars) {
                        var providedScope = modalOptions.scope || $rootScope;
                        var modalScope = providedScope.$new();
                        modalScope.$close = modalInstance.close;
                        modalScope.$dismiss = modalInstance.dismiss;
                        modalScope.$on('$destroy', function () {
                            if (!modalScope.$$uibDestructionScheduled) {
                                modalScope.$dismiss('$uibUnscheduledDestruction');
                            }
                        });
                        var modal = {
                            scope: modalScope,
                            deferred: modalResultDeferred,
                            renderDeferred: modalRenderDeferred,
                            closedDeferred: modalClosedDeferred,
                            animation: modalOptions.animation,
                            backdrop: modalOptions.backdrop,
                            keyboard: modalOptions.keyboard,
                            backdropClass: modalOptions.backdropClass,
                            windowTopClass: modalOptions.windowTopClass,
                            windowClass: modalOptions.windowClass,
                            windowTemplateUrl: modalOptions.windowTemplateUrl,
                            ariaLabelledBy: modalOptions.ariaLabelledBy,
                            ariaDescribedBy: modalOptions.ariaDescribedBy,
                            size: modalOptions.size,
                            openedClass: modalOptions.openedClass,
                            appendTo: modalOptions.appendTo
                        };
                        var component = {};
                        var ctrlInstance, ctrlInstantiate, ctrlLocals = {};
                        if (modalOptions.component) {
                            constructLocals(component, false, true, false);
                            component.name = modalOptions.component;
                            modal.component = component;
                        }
                        else if (modalOptions.controller) {
                            constructLocals(ctrlLocals, true, false, true);
                            ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                            if (modalOptions.controllerAs && modalOptions.bindToController) {
                                ctrlInstance = ctrlInstantiate.instance;
                                ctrlInstance.$close = modalScope.$close;
                                ctrlInstance.$dismiss = modalScope.$dismiss;
                                angular.extend(ctrlInstance, {
                                    $resolve: ctrlLocals.$scope.$resolve
                                }, providedScope);
                            }
                            ctrlInstance = ctrlInstantiate();
                            if (angular.isFunction(ctrlInstance.$onInit)) {
                                ctrlInstance.$onInit();
                            }
                        }
                        if (!modalOptions.component) {
                            modal.content = tplAndVars[0];
                        }
                        $modalStack.open(modalInstance, modal);
                        modalOpenedDeferred.resolve(true);
                        function constructLocals(obj, template, instanceOnScope, injectable) {
                            obj.$scope = modalScope;
                            obj.$scope.$resolve = {};
                            if (instanceOnScope) {
                                obj.$scope.$uibModalInstance = modalInstance;
                            }
                            else {
                                obj.$uibModalInstance = modalInstance;
                            }
                            var resolves = template ? tplAndVars[1] : tplAndVars;
                            angular.forEach(resolves, function (value, key) {
                                if (injectable) {
                                    obj[key] = value;
                                }
                                obj.$scope.$resolve[key] = value;
                            });
                        }
                    }, function resolveError(reason) {
                        modalOpenedDeferred.reject(reason);
                        modalResultDeferred.reject(reason);
                    })['finally'](function () {
                        if (promiseChain === samePromise) {
                            promiseChain = null;
                        }
                    });
                    return modalInstance;
                };
                return $modal;
            }
        ]
    };
    return $modalProvider;
});
angular.module('ui.bootstrap.paging', [])
    .factory('uibPaging', ['$parse', function ($parse) {
        return {
            create: function (ctrl, $scope, $attrs) {
                ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
                ctrl.ngModelCtrl = { $setViewValue: angular.noop };
                ctrl._watchers = [];
                ctrl.init = function (ngModelCtrl, config) {
                    ctrl.ngModelCtrl = ngModelCtrl;
                    ctrl.config = config;
                    ngModelCtrl.$render = function () {
                        ctrl.render();
                    };
                    if ($attrs.itemsPerPage) {
                        ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                            ctrl.itemsPerPage = parseInt(value, 10);
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }));
                    }
                    else {
                        ctrl.itemsPerPage = config.itemsPerPage;
                    }
                    $scope.$watch('totalItems', function (newTotal, oldTotal) {
                        if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }
                    });
                };
                ctrl.calculateTotalPages = function () {
                    var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                    return Math.max(totalPages || 0, 1);
                };
                ctrl.render = function () {
                    $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
                };
                $scope.selectPage = function (page, evt) {
                    if (evt) {
                        evt.preventDefault();
                    }
                    var clickAllowed = !$scope.ngDisabled || !evt;
                    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
                        if (evt && evt.target) {
                            evt.target.blur();
                        }
                        ctrl.ngModelCtrl.$setViewValue(page);
                        ctrl.ngModelCtrl.$render();
                    }
                };
                $scope.getText = function (key) {
                    return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
                };
                $scope.noPrevious = function () {
                    return $scope.page === 1;
                };
                $scope.noNext = function () {
                    return $scope.page === $scope.totalPages;
                };
                ctrl.updatePage = function () {
                    ctrl.setNumPages($scope.$parent, $scope.totalPages);
                    if ($scope.page > $scope.totalPages) {
                        $scope.selectPage($scope.totalPages);
                    }
                    else {
                        ctrl.ngModelCtrl.$render();
                    }
                };
                $scope.$on('$destroy', function () {
                    while (ctrl._watchers.length) {
                        ctrl._watchers.shift()();
                    }
                });
            }
        };
    }]);
angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
    .controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
        $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
        uibPaging.create(this, $scope, $attrs);
    }])
    .constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: '« Previous',
    nextText: 'Next »',
    align: true
})
    .directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
        return {
            scope: {
                totalItems: '=',
                previousText: '@',
                nextText: '@',
                ngDisabled: '='
            },
            require: ['uibPager', '?ngModel'],
            restrict: 'A',
            controller: 'UibPagerController',
            controllerAs: 'pager',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pager/pager.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pager');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) {
                    return;
                }
                paginationCtrl.init(ngModelCtrl, uibPagerConfig);
            }
        };
    }]);
angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
    .controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
        var ctrl = this;
        var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) { return $scope.$parent.$eval($attrs.pageLabel, { $page: idx }); } : angular.identity;
        $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
        $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
        $attrs.$set('role', 'menu');
        uibPaging.create(this, $scope, $attrs);
        if ($attrs.maxSize) {
            ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
                maxSize = parseInt(value, 10);
                ctrl.render();
            }));
        }
        function makePage(number, text, isActive) {
            return {
                number: number,
                text: text,
                active: isActive
            };
        }
        function getPages(currentPage, totalPages) {
            var pages = [];
            var startPage = 1, endPage = totalPages;
            var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
            if (isMaxSized) {
                if (rotate) {
                    startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                    endPage = startPage + maxSize - 1;
                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = endPage - maxSize + 1;
                    }
                }
                else {
                    startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
                    endPage = Math.min(startPage + maxSize - 1, totalPages);
                }
            }
            for (var number = startPage; number <= endPage; number++) {
                var page = makePage(number, pageLabel(number), number === currentPage);
                pages.push(page);
            }
            if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
                if (startPage > 1) {
                    if (!boundaryLinkNumbers || startPage > 3) {
                        var previousPageSet = makePage(startPage - 1, '...', false);
                        pages.unshift(previousPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (startPage === 3) {
                            var secondPageLink = makePage(2, '2', false);
                            pages.unshift(secondPageLink);
                        }
                        var firstPageLink = makePage(1, '1', false);
                        pages.unshift(firstPageLink);
                    }
                }
                if (endPage < totalPages) {
                    if (!boundaryLinkNumbers || endPage < totalPages - 2) {
                        var nextPageSet = makePage(endPage + 1, '...', false);
                        pages.push(nextPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (endPage === totalPages - 2) {
                            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                            pages.push(secondToLastPageLink);
                        }
                        var lastPageLink = makePage(totalPages, totalPages, false);
                        pages.push(lastPageLink);
                    }
                }
            }
            return pages;
        }
        var originalRender = this.render;
        this.render = function () {
            originalRender();
            if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
                $scope.pages = getPages($scope.page, $scope.totalPages);
            }
        };
    }])
    .constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
})
    .directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
        return {
            scope: {
                totalItems: '=',
                firstText: '@',
                previousText: '@',
                nextText: '@',
                lastText: '@',
                ngDisabled: '='
            },
            require: ['uibPagination', '?ngModel'],
            restrict: 'A',
            controller: 'UibPaginationController',
            controllerAs: 'pagination',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pagination/pagination.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pagination');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) {
                    return;
                }
                paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
            }
        };
    }]);
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])
    .provider('$uibTooltip', function () {
    var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
    };
    var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
    };
    var globalOptions = {};
    this.options = function (value) {
        angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function (letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
            var openedTooltips = $$stackedMap.createNew();
            $document.on('keyup', keypressListener);
            $rootScope.$on('$destroy', function () {
                $document.off('keyup', keypressListener);
            });
            function keypressListener(e) {
                if (e.which === 27) {
                    var last = openedTooltips.top();
                    if (last) {
                        last.value.close();
                        last = null;
                    }
                }
            }
            return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
                options = angular.extend({}, defaultOptions, globalOptions, options);
                function getTriggers(trigger) {
                    var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
                    var hide = show.map(function (trigger) {
                        return triggerMap[trigger] || trigger;
                    });
                    return {
                        show: show,
                        hide: hide
                    };
                }
                var directiveName = snake_case(ttType);
                var startSym = $interpolate.startSymbol();
                var endSym = $interpolate.endSymbol();
                var template = '<div ' + directiveName + '-popup ' +
                    'uib-title="' + startSym + 'title' + endSym + '" ' +
                    (options.useContentExp ?
                        'content-exp="contentExp()" ' :
                        'content="' + startSym + 'content' + endSym + '" ') +
                    'origin-scope="origScope" ' +
                    'class="uib-position-measure ' + prefix + '" ' +
                    'tooltip-animation-class="fade"' +
                    'uib-tooltip-classes ' +
                    'ng-class="{ in: isOpen }" ' +
                    '>' +
                    '</div>';
                return {
                    compile: function (tElem, tAttrs) {
                        var tooltipLinker = $compile(template);
                        return function link(scope, element, attrs, tooltipCtrl) {
                            var tooltip;
                            var tooltipLinkedScope;
                            var transitionTimeout;
                            var showTimeout;
                            var hideTimeout;
                            var positionTimeout;
                            var adjustmentTimeout;
                            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                            var triggers = getTriggers(undefined);
                            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                            var ttScope = scope.$new(true);
                            var repositionScheduled = false;
                            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                            var observers = [];
                            var lastPlacement;
                            var positionTooltip = function () {
                                if (!tooltip || !tooltip.html()) {
                                    return;
                                }
                                if (!positionTimeout) {
                                    positionTimeout = $timeout(function () {
                                        var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                        var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                        var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                        tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                                        var placementClasses = ttPosition.placement.split('-');
                                        if (!tooltip.hasClass(placementClasses[0])) {
                                            tooltip.removeClass(lastPlacement.split('-')[0]);
                                            tooltip.addClass(placementClasses[0]);
                                        }
                                        if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                                            tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                                            tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                                        }
                                        adjustmentTimeout = $timeout(function () {
                                            var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                            var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                            if (adjustment) {
                                                tooltip.css(adjustment);
                                            }
                                            adjustmentTimeout = null;
                                        }, 0, false);
                                        if (tooltip.hasClass('uib-position-measure')) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                            tooltip.removeClass('uib-position-measure');
                                        }
                                        else if (lastPlacement !== ttPosition.placement) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                        }
                                        lastPlacement = ttPosition.placement;
                                        positionTimeout = null;
                                    }, 0, false);
                                }
                            };
                            ttScope.origScope = scope;
                            ttScope.isOpen = false;
                            function toggleTooltipBind() {
                                if (!ttScope.isOpen) {
                                    showTooltipBind();
                                }
                                else {
                                    hideTooltipBind();
                                }
                            }
                            function showTooltipBind() {
                                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                                    return;
                                }
                                cancelHide();
                                prepareTooltip();
                                if (ttScope.popupDelay) {
                                    if (!showTimeout) {
                                        showTimeout = $timeout(show, ttScope.popupDelay, false);
                                    }
                                }
                                else {
                                    show();
                                }
                            }
                            function hideTooltipBind() {
                                cancelShow();
                                if (ttScope.popupCloseDelay) {
                                    if (!hideTimeout) {
                                        hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                                    }
                                }
                                else {
                                    hide();
                                }
                            }
                            function show() {
                                cancelShow();
                                cancelHide();
                                if (!ttScope.content) {
                                    return angular.noop;
                                }
                                createTooltip();
                                ttScope.$evalAsync(function () {
                                    ttScope.isOpen = true;
                                    assignIsOpen(true);
                                    positionTooltip();
                                });
                            }
                            function cancelShow() {
                                if (showTimeout) {
                                    $timeout.cancel(showTimeout);
                                    showTimeout = null;
                                }
                                if (positionTimeout) {
                                    $timeout.cancel(positionTimeout);
                                    positionTimeout = null;
                                }
                            }
                            function hide() {
                                if (!ttScope) {
                                    return;
                                }
                                ttScope.$evalAsync(function () {
                                    if (ttScope) {
                                        ttScope.isOpen = false;
                                        assignIsOpen(false);
                                        if (ttScope.animation) {
                                            if (!transitionTimeout) {
                                                transitionTimeout = $timeout(removeTooltip, 150, false);
                                            }
                                        }
                                        else {
                                            removeTooltip();
                                        }
                                    }
                                });
                            }
                            function cancelHide() {
                                if (hideTimeout) {
                                    $timeout.cancel(hideTimeout);
                                    hideTimeout = null;
                                }
                                if (transitionTimeout) {
                                    $timeout.cancel(transitionTimeout);
                                    transitionTimeout = null;
                                }
                            }
                            function createTooltip() {
                                if (tooltip) {
                                    return;
                                }
                                tooltipLinkedScope = ttScope.$new();
                                tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                                    if (appendToBody) {
                                        $document.find('body').append(tooltip);
                                    }
                                    else {
                                        element.after(tooltip);
                                    }
                                });
                                openedTooltips.add(ttScope, {
                                    close: hide
                                });
                                prepObservers();
                            }
                            function removeTooltip() {
                                cancelShow();
                                cancelHide();
                                unregisterObservers();
                                if (tooltip) {
                                    tooltip.remove();
                                    tooltip = null;
                                    if (adjustmentTimeout) {
                                        $timeout.cancel(adjustmentTimeout);
                                    }
                                }
                                openedTooltips.remove(ttScope);
                                if (tooltipLinkedScope) {
                                    tooltipLinkedScope.$destroy();
                                    tooltipLinkedScope = null;
                                }
                            }
                            function prepareTooltip() {
                                ttScope.title = attrs[prefix + 'Title'];
                                if (contentParse) {
                                    ttScope.content = contentParse(scope);
                                }
                                else {
                                    ttScope.content = attrs[ttType];
                                }
                                ttScope.popupClass = attrs[prefix + 'Class'];
                                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                                var placement = $position.parsePlacement(ttScope.placement);
                                lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                            }
                            function assignIsOpen(isOpen) {
                                if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                                    isOpenParse.assign(scope, isOpen);
                                }
                            }
                            ttScope.contentExp = function () {
                                return ttScope.content;
                            };
                            attrs.$observe('disabled', function (val) {
                                if (val) {
                                    cancelShow();
                                }
                                if (val && ttScope.isOpen) {
                                    hide();
                                }
                            });
                            if (isOpenParse) {
                                scope.$watch(isOpenParse, function (val) {
                                    if (ttScope && !val === ttScope.isOpen) {
                                        toggleTooltipBind();
                                    }
                                });
                            }
                            function prepObservers() {
                                observers.length = 0;
                                if (contentParse) {
                                    observers.push(scope.$watch(contentParse, function (val) {
                                        ttScope.content = val;
                                        if (!val && ttScope.isOpen) {
                                            hide();
                                        }
                                    }));
                                    observers.push(tooltipLinkedScope.$watch(function () {
                                        if (!repositionScheduled) {
                                            repositionScheduled = true;
                                            tooltipLinkedScope.$$postDigest(function () {
                                                repositionScheduled = false;
                                                if (ttScope && ttScope.isOpen) {
                                                    positionTooltip();
                                                }
                                            });
                                        }
                                    }));
                                }
                                else {
                                    observers.push(attrs.$observe(ttType, function (val) {
                                        ttScope.content = val;
                                        if (!val && ttScope.isOpen) {
                                            hide();
                                        }
                                        else {
                                            positionTooltip();
                                        }
                                    }));
                                }
                                observers.push(attrs.$observe(prefix + 'Title', function (val) {
                                    ttScope.title = val;
                                    if (ttScope.isOpen) {
                                        positionTooltip();
                                    }
                                }));
                                observers.push(attrs.$observe(prefix + 'Placement', function (val) {
                                    ttScope.placement = val ? val : options.placement;
                                    if (ttScope.isOpen) {
                                        positionTooltip();
                                    }
                                }));
                            }
                            function unregisterObservers() {
                                if (observers.length) {
                                    angular.forEach(observers, function (observer) {
                                        observer();
                                    });
                                    observers.length = 0;
                                }
                            }
                            function bodyHideTooltipBind(e) {
                                if (!ttScope || !ttScope.isOpen || !tooltip) {
                                    return;
                                }
                                if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                                    hideTooltipBind();
                                }
                            }
                            function hideOnEscapeKey(e) {
                                if (e.which === 27) {
                                    hideTooltipBind();
                                }
                            }
                            var unregisterTriggers = function () {
                                triggers.show.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        element.off('click', toggleTooltipBind);
                                    }
                                    else {
                                        element.off(trigger, showTooltipBind);
                                        element.off(trigger, toggleTooltipBind);
                                    }
                                    element.off('keypress', hideOnEscapeKey);
                                });
                                triggers.hide.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        $document.off('click', bodyHideTooltipBind);
                                    }
                                    else {
                                        element.off(trigger, hideTooltipBind);
                                    }
                                });
                            };
                            function prepTriggers() {
                                var showTriggers = [], hideTriggers = [];
                                var val = scope.$eval(attrs[prefix + 'Trigger']);
                                unregisterTriggers();
                                if (angular.isObject(val)) {
                                    Object.keys(val).forEach(function (key) {
                                        showTriggers.push(key);
                                        hideTriggers.push(val[key]);
                                    });
                                    triggers = {
                                        show: showTriggers,
                                        hide: hideTriggers
                                    };
                                }
                                else {
                                    triggers = getTriggers(val);
                                }
                                if (triggers.show !== 'none') {
                                    triggers.show.forEach(function (trigger, idx) {
                                        if (trigger === 'outsideClick') {
                                            element.on('click', toggleTooltipBind);
                                            $document.on('click', bodyHideTooltipBind);
                                        }
                                        else if (trigger === triggers.hide[idx]) {
                                            element.on(trigger, toggleTooltipBind);
                                        }
                                        else if (trigger) {
                                            element.on(trigger, showTooltipBind);
                                            element.on(triggers.hide[idx], hideTooltipBind);
                                        }
                                        element.on('keypress', hideOnEscapeKey);
                                    });
                                }
                            }
                            prepTriggers();
                            var animation = scope.$eval(attrs[prefix + 'Animation']);
                            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                            var appendToBodyVal;
                            var appendKey = prefix + 'AppendToBody';
                            if (appendKey in attrs && attrs[appendKey] === undefined) {
                                appendToBodyVal = true;
                            }
                            else {
                                appendToBodyVal = scope.$eval(attrs[appendKey]);
                            }
                            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                            scope.$on('$destroy', function onDestroyTooltip() {
                                unregisterTriggers();
                                removeTooltip();
                                ttScope = null;
                            });
                        };
                    }
                };
            };
        }];
})
    .directive('uibTooltipTemplateTransclude', [
    '$animate', '$sce', '$compile', '$templateRequest',
    function ($animate, $sce, $compile, $templateRequest) {
        return {
            link: function (scope, elem, attrs) {
                var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
                var changeCounter = 0, currentScope, previousElement, currentElement;
                var cleanupLastIncludeContent = function () {
                    if (previousElement) {
                        previousElement.remove();
                        previousElement = null;
                    }
                    if (currentScope) {
                        currentScope.$destroy();
                        currentScope = null;
                    }
                    if (currentElement) {
                        $animate.leave(currentElement).then(function () {
                            previousElement = null;
                        });
                        previousElement = currentElement;
                        currentElement = null;
                    }
                };
                scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
                    var thisChangeId = ++changeCounter;
                    if (src) {
                        $templateRequest(src, true).then(function (response) {
                            if (thisChangeId !== changeCounter) {
                                return;
                            }
                            var newScope = origScope.$new();
                            var template = response;
                            var clone = $compile(template)(newScope, function (clone) {
                                cleanupLastIncludeContent();
                                $animate.enter(clone, elem);
                            });
                            currentScope = newScope;
                            currentElement = clone;
                            currentScope.$emit('$includeContentLoaded', src);
                        }, function () {
                            if (thisChangeId === changeCounter) {
                                cleanupLastIncludeContent();
                                scope.$emit('$includeContentError', src);
                            }
                        });
                        scope.$emit('$includeContentRequested', src);
                    }
                    else {
                        cleanupLastIncludeContent();
                    }
                });
                scope.$on('$destroy', cleanupLastIncludeContent);
            }
        };
    }
])
    .directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                if (scope.placement) {
                    var position = $uibPosition.parsePlacement(scope.placement);
                    element.addClass(position[0]);
                }
                if (scope.popupClass) {
                    element.addClass(scope.popupClass);
                }
                if (scope.animation) {
                    element.addClass(attrs.tooltipAnimationClass);
                }
            }
        };
    }])
    .directive('uibTooltipPopup', function () {
    return {
        restrict: 'A',
        scope: { content: '@' },
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
})
    .directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }])
    .directive('uibTooltipTemplatePopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
})
    .directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }])
    .directive('uibTooltipHtmlPopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
})
    .directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }]);
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
    .directive('uibPopoverTemplatePopup', function () {
    return {
        restrict: 'A',
        scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/popover/popover-template.html'
    };
})
    .directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
            useContentExp: true
        });
    }])
    .directive('uibPopoverHtmlPopup', function () {
    return {
        restrict: 'A',
        scope: { contentExp: '&', uibTitle: '@' },
        templateUrl: 'uib/template/popover/popover-html.html'
    };
})
    .directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
            useContentExp: true
        });
    }])
    .directive('uibPopoverPopup', function () {
    return {
        restrict: 'A',
        scope: { uibTitle: '@', content: '@' },
        templateUrl: 'uib/template/popover/popover.html'
    };
})
    .directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopover', 'popover', 'click');
    }]);
angular.module('ui.bootstrap.progressbar', [])
    .constant('uibProgressConfig', {
    animate: true,
    max: 100
})
    .controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
        var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
        this.bars = [];
        $scope.max = getMaxOrDefault();
        this.addBar = function (bar, element, attrs) {
            if (!animate) {
                element.css({ 'transition': 'none' });
            }
            this.bars.push(bar);
            bar.max = getMaxOrDefault();
            bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
            bar.$watch('value', function (value) {
                bar.recalculatePercentage();
            });
            bar.recalculatePercentage = function () {
                var totalPercentage = self.bars.reduce(function (total, bar) {
                    bar.percent = +(100 * bar.value / bar.max).toFixed(2);
                    return total + bar.percent;
                }, 0);
                if (totalPercentage > 100) {
                    bar.percent -= totalPercentage - 100;
                }
            };
            bar.$on('$destroy', function () {
                element = null;
                self.removeBar(bar);
            });
        };
        this.removeBar = function (bar) {
            this.bars.splice(this.bars.indexOf(bar), 1);
            this.bars.forEach(function (bar) {
                bar.recalculatePercentage();
            });
        };
        $scope.$watch('maxParam', function (maxParam) {
            self.bars.forEach(function (bar) {
                bar.max = getMaxOrDefault();
                bar.recalculatePercentage();
            });
        });
        function getMaxOrDefault() {
            return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
        }
    }])
    .directive('uibProgress', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {
            maxParam: '=?max'
        },
        templateUrl: 'uib/template/progressbar/progress.html'
    };
})
    .directive('uibBar', function () {
    return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
})
    .directive('uibProgressbar', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
            value: '=',
            maxParam: '=?max',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
        }
    };
});
angular.module('ui.bootstrap.rating', [])
    .constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: true,
    titles: ['one', 'two', 'three', 'four', 'five']
})
    .controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
        var ngModelCtrl = { $setViewValue: angular.noop }, self = this;
        this.init = function (ngModelCtrl_) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;
            ngModelCtrl.$formatters.push(function (value) {
                if (angular.isNumber(value) && value << 0 !== value) {
                    value = Math.round(value);
                }
                return value;
            });
            this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
            this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
            this.enableReset = angular.isDefined($attrs.enableReset) ?
                $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
            var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
            this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
                tmpTitles : ratingConfig.titles;
            var ratingStates = angular.isDefined($attrs.ratingStates) ?
                $scope.$parent.$eval($attrs.ratingStates) :
                new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
            $scope.range = this.buildTemplateObjects(ratingStates);
        };
        this.buildTemplateObjects = function (states) {
            for (var i = 0, n = states.length; i < n; i++) {
                states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
            }
            return states;
        };
        this.getTitle = function (index) {
            if (index >= this.titles.length) {
                return index + 1;
            }
            return this.titles[index];
        };
        $scope.rate = function (value) {
            if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
                var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
                ngModelCtrl.$setViewValue(newViewValue);
                ngModelCtrl.$render();
            }
        };
        $scope.enter = function (value) {
            if (!$scope.readonly) {
                $scope.value = value;
            }
            $scope.onHover({ value: value });
        };
        $scope.reset = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.onLeave();
        };
        $scope.onKeydown = function (evt) {
            if (/(37|38|39|40)/.test(evt.which)) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
            }
        };
        this.render = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.title = self.getTitle($scope.value - 1);
        };
    }])
    .directive('uibRating', function () {
    return {
        require: ['uibRating', 'ngModel'],
        restrict: 'A',
        scope: {
            readonly: '=?readOnly',
            onHover: '&',
            onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        link: function (scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
});
angular.module('ui.bootstrap.tabs', [])
    .controller('UibTabsetController', ['$scope', function ($scope) {
        var ctrl = this, oldIndex;
        ctrl.tabs = [];
        ctrl.select = function (index, evt) {
            if (!destroyed) {
                var previousIndex = findTabIndex(oldIndex);
                var previousSelected = ctrl.tabs[previousIndex];
                if (previousSelected) {
                    previousSelected.tab.onDeselect({
                        $event: evt,
                        $selectedIndex: index
                    });
                    if (evt && evt.isDefaultPrevented()) {
                        return;
                    }
                    previousSelected.tab.active = false;
                }
                var selected = ctrl.tabs[index];
                if (selected) {
                    selected.tab.onSelect({
                        $event: evt
                    });
                    selected.tab.active = true;
                    ctrl.active = selected.index;
                    oldIndex = selected.index;
                }
                else if (!selected && angular.isDefined(oldIndex)) {
                    ctrl.active = null;
                    oldIndex = null;
                }
            }
        };
        ctrl.addTab = function addTab(tab) {
            ctrl.tabs.push({
                tab: tab,
                index: tab.index
            });
            ctrl.tabs.sort(function (t1, t2) {
                if (t1.index > t2.index) {
                    return 1;
                }
                if (t1.index < t2.index) {
                    return -1;
                }
                return 0;
            });
            if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
                var newActiveIndex = findTabIndex(tab.index);
                ctrl.select(newActiveIndex);
            }
        };
        ctrl.removeTab = function removeTab(tab) {
            var index;
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].tab === tab) {
                    index = i;
                    break;
                }
            }
            if (ctrl.tabs[index].index === ctrl.active) {
                var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
                    index - 1 : index + 1 % ctrl.tabs.length;
                ctrl.select(newActiveTabIndex);
            }
            ctrl.tabs.splice(index, 1);
        };
        $scope.$watch('tabset.active', function (val) {
            if (angular.isDefined(val) && val !== oldIndex) {
                ctrl.select(findTabIndex(val));
            }
        });
        var destroyed;
        $scope.$on('$destroy', function () {
            destroyed = true;
        });
        function findTabIndex(index) {
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].index === index) {
                    return i;
                }
            }
        }
    }])
    .directive('uibTabset', function () {
    return {
        transclude: true,
        replace: true,
        scope: {},
        bindToController: {
            active: '=?',
            type: '@'
        },
        controller: 'UibTabsetController',
        controllerAs: 'tabset',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/tabs/tabset.html';
        },
        link: function (scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ?
                scope.$parent.$eval(attrs.vertical) : false;
            scope.justified = angular.isDefined(attrs.justified) ?
                scope.$parent.$eval(attrs.justified) : false;
        }
    };
})
    .directive('uibTab', ['$parse', function ($parse) {
        return {
            require: '^uibTabset',
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/tabs/tab.html';
            },
            transclude: true,
            scope: {
                heading: '@',
                index: '=?',
                classes: '@?',
                onSelect: '&select',
                onDeselect: '&deselect'
            },
            controller: function () {
            },
            controllerAs: 'tab',
            link: function (scope, elm, attrs, tabsetCtrl, transclude) {
                scope.disabled = false;
                if (attrs.disable) {
                    scope.$parent.$watch($parse(attrs.disable), function (value) {
                        scope.disabled = !!value;
                    });
                }
                if (angular.isUndefined(attrs.index)) {
                    if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
                        scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) { return t.index; })) + 1;
                    }
                    else {
                        scope.index = 0;
                    }
                }
                if (angular.isUndefined(attrs.classes)) {
                    scope.classes = '';
                }
                scope.select = function (evt) {
                    if (!scope.disabled) {
                        var index;
                        for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                            if (tabsetCtrl.tabs[i].tab === scope) {
                                index = i;
                                break;
                            }
                        }
                        tabsetCtrl.select(index, evt);
                    }
                };
                tabsetCtrl.addTab(scope);
                scope.$on('$destroy', function () {
                    tabsetCtrl.removeTab(scope);
                });
                scope.$transcludeFn = transclude;
            }
        };
    }])
    .directive('uibTabHeadingTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTab',
        link: function (scope, elm) {
            scope.$watch('headingElement', function updateHeadingElement(heading) {
                if (heading) {
                    elm.html('');
                    elm.append(heading);
                }
            });
        }
    };
})
    .directive('uibTabContentTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTabset',
        link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    if (isTabHeading(node)) {
                        tab.headingElement = node;
                    }
                    else {
                        elm.append(node);
                    }
                });
            });
        }
    };
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('uib-tab-heading') ||
            node.hasAttribute('data-uib-tab-heading') ||
            node.hasAttribute('x-uib-tab-heading') ||
            node.tagName.toLowerCase() === 'uib-tab-heading' ||
            node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
            node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
            node.tagName.toLowerCase() === 'uib:tab-heading');
    }
});
angular.module('ui.bootstrap.timepicker', [])
    .constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: 'uib/template/timepicker/timepicker.html'
})
    .controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
        var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
        var selected = new Date(), watchers = [], ngModelCtrl = { $setViewValue: angular.noop }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
        $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
        $element.removeAttr('tabindex');
        this.init = function (ngModelCtrl_, inputs) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;
            ngModelCtrl.$formatters.unshift(function (modelValue) {
                return modelValue ? new Date(modelValue) : null;
            });
            var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2);
            hoursModelCtrl = hoursInputEl.controller('ngModel');
            minutesModelCtrl = minutesInputEl.controller('ngModel');
            secondsModelCtrl = secondsInputEl.controller('ngModel');
            var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
            if (mousewheel) {
                this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }
            var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
            if (arrowkeys) {
                this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }
            $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
            this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        };
        var hourStep = timepickerConfig.hourStep;
        if ($attrs.hourStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
                hourStep = +value;
            }));
        }
        var minuteStep = timepickerConfig.minuteStep;
        if ($attrs.minuteStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
                minuteStep = +value;
            }));
        }
        var min;
        watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
            var dt = new Date(value);
            min = isNaN(dt) ? undefined : dt;
        }));
        var max;
        watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
            var dt = new Date(value);
            max = isNaN(dt) ? undefined : dt;
        }));
        var disabled = false;
        if ($attrs.ngDisabled) {
            watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
                disabled = value;
            }));
        }
        $scope.noIncrementHours = function () {
            var incrementedSelected = addMinutes(selected, hourStep * 60);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementHours = function () {
            var decrementedSelected = addMinutes(selected, -hourStep * 60);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noIncrementMinutes = function () {
            var incrementedSelected = addMinutes(selected, minuteStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementMinutes = function () {
            var decrementedSelected = addMinutes(selected, -minuteStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noIncrementSeconds = function () {
            var incrementedSelected = addSeconds(selected, secondStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };
        $scope.noDecrementSeconds = function () {
            var decrementedSelected = addSeconds(selected, -secondStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };
        $scope.noToggleMeridian = function () {
            if (selected.getHours() < 12) {
                return disabled || addMinutes(selected, 12 * 60) > max;
            }
            return disabled || addMinutes(selected, -12 * 60) < min;
        };
        var secondStep = timepickerConfig.secondStep;
        if ($attrs.secondStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
                secondStep = +value;
            }));
        }
        $scope.showSeconds = timepickerConfig.showSeconds;
        if ($attrs.showSeconds) {
            watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
                $scope.showSeconds = !!value;
            }));
        }
        $scope.showMeridian = timepickerConfig.showMeridian;
        if ($attrs.showMeridian) {
            watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
                $scope.showMeridian = !!value;
                if (ngModelCtrl.$error.time) {
                    var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                    if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                        selected.setHours(hours);
                        refresh();
                    }
                }
                else {
                    updateTemplate();
                }
            }));
        }
        function getHoursFromTemplate() {
            var hours = +$scope.hours;
            var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
                hours >= 0 && hours < 24;
            if (!valid || $scope.hours === '') {
                return undefined;
            }
            if ($scope.showMeridian) {
                if (hours === 12) {
                    hours = 0;
                }
                if ($scope.meridian === meridians[1]) {
                    hours = hours + 12;
                }
            }
            return hours;
        }
        function getMinutesFromTemplate() {
            var minutes = +$scope.minutes;
            var valid = minutes >= 0 && minutes < 60;
            if (!valid || $scope.minutes === '') {
                return undefined;
            }
            return minutes;
        }
        function getSecondsFromTemplate() {
            var seconds = +$scope.seconds;
            return seconds >= 0 && seconds < 60 ? seconds : undefined;
        }
        function pad(value, noPad) {
            if (value === null) {
                return '';
            }
            return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
                '0' + value : value.toString();
        }
        this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            var isScrollingUp = function (e) {
                if (e.originalEvent) {
                    e = e.originalEvent;
                }
                var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
                return e.detail || delta > 0;
            };
            hoursInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
                }
                e.preventDefault();
            });
            minutesInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
                }
                e.preventDefault();
            });
            secondsInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
                }
                e.preventDefault();
            });
        };
        this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            hoursInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementHours();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementHours();
                        $scope.$apply();
                    }
                }
            });
            minutesInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementMinutes();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementMinutes();
                        $scope.$apply();
                    }
                }
            });
            secondsInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) {
                        e.preventDefault();
                        $scope.incrementSeconds();
                        $scope.$apply();
                    }
                    else if (e.which === 40) {
                        e.preventDefault();
                        $scope.decrementSeconds();
                        $scope.$apply();
                    }
                }
            });
        };
        this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            if ($scope.readonlyInput) {
                $scope.updateHours = angular.noop;
                $scope.updateMinutes = angular.noop;
                $scope.updateSeconds = angular.noop;
                return;
            }
            var invalidate = function (invalidHours, invalidMinutes, invalidSeconds) {
                ngModelCtrl.$setViewValue(null);
                ngModelCtrl.$setValidity('time', false);
                if (angular.isDefined(invalidHours)) {
                    $scope.invalidHours = invalidHours;
                    if (hoursModelCtrl) {
                        hoursModelCtrl.$setValidity('hours', false);
                    }
                }
                if (angular.isDefined(invalidMinutes)) {
                    $scope.invalidMinutes = invalidMinutes;
                    if (minutesModelCtrl) {
                        minutesModelCtrl.$setValidity('minutes', false);
                    }
                }
                if (angular.isDefined(invalidSeconds)) {
                    $scope.invalidSeconds = invalidSeconds;
                    if (secondsModelCtrl) {
                        secondsModelCtrl.$setValidity('seconds', false);
                    }
                }
            };
            $scope.updateHours = function () {
                var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(true);
                    }
                    else {
                        refresh('h');
                    }
                }
                else {
                    invalidate(true);
                }
            };
            hoursInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if ($scope.hours === null || $scope.hours === '') {
                    invalidate(true);
                }
                else if (!$scope.invalidHours && $scope.hours < 10) {
                    $scope.$apply(function () {
                        $scope.hours = pad($scope.hours, !padHours);
                    });
                }
            });
            $scope.updateMinutes = function () {
                var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(undefined, true);
                    }
                    else {
                        refresh('m');
                    }
                }
                else {
                    invalidate(undefined, true);
                }
            };
            minutesInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if ($scope.minutes === null) {
                    invalidate(undefined, true);
                }
                else if (!$scope.invalidMinutes && $scope.minutes < 10) {
                    $scope.$apply(function () {
                        $scope.minutes = pad($scope.minutes);
                    });
                }
            });
            $scope.updateSeconds = function () {
                var seconds = getSecondsFromTemplate();
                ngModelCtrl.$setDirty();
                if (angular.isDefined(seconds)) {
                    selected.setSeconds(seconds);
                    refresh('s');
                }
                else {
                    invalidate(undefined, undefined, true);
                }
            };
            secondsInputEl.on('blur', function (e) {
                if (modelIsEmpty()) {
                    makeValid();
                }
                else if (!$scope.invalidSeconds && $scope.seconds < 10) {
                    $scope.$apply(function () {
                        $scope.seconds = pad($scope.seconds);
                    });
                }
            });
        };
        this.render = function () {
            var date = ngModelCtrl.$viewValue;
            if (isNaN(date)) {
                ngModelCtrl.$setValidity('time', false);
                $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
            }
            else {
                if (date) {
                    selected = date;
                }
                if (selected < min || selected > max) {
                    ngModelCtrl.$setValidity('time', false);
                    $scope.invalidHours = true;
                    $scope.invalidMinutes = true;
                }
                else {
                    makeValid();
                }
                updateTemplate();
            }
        };
        function refresh(keyboardChange) {
            makeValid();
            ngModelCtrl.$setViewValue(new Date(selected));
            updateTemplate(keyboardChange);
        }
        function makeValid() {
            if (hoursModelCtrl) {
                hoursModelCtrl.$setValidity('hours', true);
            }
            if (minutesModelCtrl) {
                minutesModelCtrl.$setValidity('minutes', true);
            }
            if (secondsModelCtrl) {
                secondsModelCtrl.$setValidity('seconds', true);
            }
            ngModelCtrl.$setValidity('time', true);
            $scope.invalidHours = false;
            $scope.invalidMinutes = false;
            $scope.invalidSeconds = false;
        }
        function updateTemplate(keyboardChange) {
            if (!ngModelCtrl.$modelValue) {
                $scope.hours = null;
                $scope.minutes = null;
                $scope.seconds = null;
                $scope.meridian = meridians[0];
            }
            else {
                var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
                if ($scope.showMeridian) {
                    hours = hours === 0 || hours === 12 ? 12 : hours % 12;
                }
                $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
                if (keyboardChange !== 'm') {
                    $scope.minutes = pad(minutes);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
                if (keyboardChange !== 's') {
                    $scope.seconds = pad(seconds);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
            }
        }
        function addSecondsToSelected(seconds) {
            selected = addSeconds(selected, seconds);
            refresh();
        }
        function addMinutes(selected, minutes) {
            return addSeconds(selected, minutes * 60);
        }
        function addSeconds(date, seconds) {
            var dt = new Date(date.getTime() + seconds * 1000);
            var newDate = new Date(date);
            newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
            return newDate;
        }
        function modelIsEmpty() {
            return ($scope.hours === null || $scope.hours === '') &&
                ($scope.minutes === null || $scope.minutes === '') &&
                (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
        }
        $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
            $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
        $scope.incrementHours = function () {
            if (!$scope.noIncrementHours()) {
                addSecondsToSelected(hourStep * 60 * 60);
            }
        };
        $scope.decrementHours = function () {
            if (!$scope.noDecrementHours()) {
                addSecondsToSelected(-hourStep * 60 * 60);
            }
        };
        $scope.incrementMinutes = function () {
            if (!$scope.noIncrementMinutes()) {
                addSecondsToSelected(minuteStep * 60);
            }
        };
        $scope.decrementMinutes = function () {
            if (!$scope.noDecrementMinutes()) {
                addSecondsToSelected(-minuteStep * 60);
            }
        };
        $scope.incrementSeconds = function () {
            if (!$scope.noIncrementSeconds()) {
                addSecondsToSelected(secondStep);
            }
        };
        $scope.decrementSeconds = function () {
            if (!$scope.noDecrementSeconds()) {
                addSecondsToSelected(-secondStep);
            }
        };
        $scope.toggleMeridian = function () {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            if (!$scope.noToggleMeridian()) {
                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
                }
                else {
                    $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
                }
            }
        };
        $scope.blur = function () {
            ngModelCtrl.$setTouched();
        };
        $scope.$on('$destroy', function () {
            while (watchers.length) {
                watchers.shift()();
            }
        });
    }])
    .directive('uibTimepicker', ['uibTimepickerConfig', function (uibTimepickerConfig) {
        return {
            require: ['uibTimepicker', '?^ngModel'],
            restrict: 'A',
            controller: 'UibTimepickerController',
            controllerAs: 'timepicker',
            scope: {},
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || uibTimepickerConfig.templateUrl;
            },
            link: function (scope, element, attrs, ctrls) {
                var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    timepickerCtrl.init(ngModelCtrl, element.find('input'));
                }
            }
        };
    }]);
angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])
    .factory('uibTypeaheadParser', ['$parse', function ($parse) {
        var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
        return {
            parse: function (input) {
                var match = input.match(TYPEAHEAD_REGEXP);
                if (!match) {
                    throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
                        ' but got "' + input + '".');
                }
                return {
                    itemName: match[3],
                    source: $parse(match[4]),
                    viewMapper: $parse(match[2] || match[1]),
                    modelMapper: $parse(match[1])
                };
            }
        };
    }])
    .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
        var HOT_KEYS = [9, 13, 27, 38, 40];
        var eventDebounceTime = 200;
        var modelCtrl, ngModelOptions;
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength && minLength !== 0) {
            minLength = 1;
        }
        originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
            minLength = !newVal && newVal !== 0 ? 1 : newVal;
        });
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
        originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
            isEditable = newVal !== false;
        });
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
        var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
            var evt = vals.$event;
            return evt.which === 13 || evt.which === 9;
        };
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
        var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
        var appendTo = attrs.typeaheadAppendTo ?
            originalScope.$eval(attrs.typeaheadAppendTo) : null;
        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
        var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
        var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
        var $setModelValue = function (scope, newValue) {
            if (angular.isFunction(parsedModel(originalScope)) &&
                ngModelOptions.getOption('getterSetter')) {
                return invokeModelSetter(scope, { $$$p: newValue });
            }
            return parsedModel.assign(scope, newValue);
        };
        var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
        var hasFocus;
        var selected;
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on('$destroy', function () {
            scope.$destroy();
        });
        scope.$on('$destroy', offDestroy);
        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        element.attr({
            'aria-autocomplete': 'list',
            'aria-expanded': false,
            'aria-owns': popupId
        });
        var inputsContainer, hintInputElem;
        if (showHint) {
            inputsContainer = angular.element('<div></div>');
            inputsContainer.css('position', 'relative');
            element.after(inputsContainer);
            hintInputElem = element.clone();
            hintInputElem.attr('placeholder', '');
            hintInputElem.attr('tabindex', '-1');
            hintInputElem.val('');
            hintInputElem.css({
                'position': 'absolute',
                'top': '0px',
                'left': '0px',
                'border-color': 'transparent',
                'box-shadow': 'none',
                'opacity': 1,
                'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
                'color': '#999'
            });
            element.css({
                'position': 'relative',
                'vertical-align': 'top',
                'background-color': 'transparent'
            });
            if (hintInputElem.attr('id')) {
                hintInputElem.removeAttr('id');
            }
            inputsContainer.append(hintInputElem);
            hintInputElem.after(element);
        }
        var popUpEl = angular.element('<div uib-typeahead-popup></div>');
        popUpEl.attr({
            id: popupId,
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx, evt)',
            'move-in-progress': 'moveInProgress',
            query: 'query',
            position: 'position',
            'assign-is-open': 'assignIsOpen(isOpen)',
            debounce: 'debounceUpdate'
        });
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }
        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
            popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
        }
        var resetHint = function () {
            if (showHint) {
                hintInputElem.val('');
            }
        };
        var resetMatches = function () {
            scope.matches = [];
            scope.activeIdx = -1;
            element.attr('aria-expanded', false);
            resetHint();
        };
        var getMatchId = function (index) {
            return popupId + '-option-' + index;
        };
        scope.$watch('activeIdx', function (index) {
            if (index < 0) {
                element.removeAttr('aria-activedescendant');
            }
            else {
                element.attr('aria-activedescendant', getMatchId(index));
            }
        });
        var inputIsExactMatch = function (inputValue, index) {
            if (scope.matches.length > index && inputValue) {
                return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
            }
            return false;
        };
        var getMatchesAsync = function (inputValue, evt) {
            var locals = { $viewValue: inputValue };
            isLoadingSetter(originalScope, true);
            isNoResultsSetter(originalScope, false);
            $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                if (onCurrentRequest && hasFocus) {
                    if (matches && matches.length > 0) {
                        scope.activeIdx = focusFirst ? 0 : -1;
                        isNoResultsSetter(originalScope, false);
                        scope.matches.length = 0;
                        for (var i = 0; i < matches.length; i++) {
                            locals[parserResult.itemName] = matches[i];
                            scope.matches.push({
                                id: getMatchId(i),
                                label: parserResult.viewMapper(scope, locals),
                                model: matches[i]
                            });
                        }
                        scope.query = inputValue;
                        recalculatePosition();
                        element.attr('aria-expanded', true);
                        if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(0, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            }
                            else {
                                scope.select(0, evt);
                            }
                        }
                        if (showHint) {
                            var firstLabel = scope.matches[0].label;
                            if (angular.isString(inputValue) &&
                                inputValue.length > 0 &&
                                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                            }
                            else {
                                hintInputElem.val('');
                            }
                        }
                    }
                    else {
                        resetMatches();
                        isNoResultsSetter(originalScope, true);
                    }
                }
                if (onCurrentRequest) {
                    isLoadingSetter(originalScope, false);
                }
            }, function () {
                resetMatches();
                isLoadingSetter(originalScope, false);
                isNoResultsSetter(originalScope, true);
            });
        };
        if (appendToBody) {
            angular.element($window).on('resize', fireRecalculating);
            $document.find('body').on('scroll', fireRecalculating);
        }
        var debouncedRecalculate = $$debounce(function () {
            if (scope.matches.length) {
                recalculatePosition();
            }
            scope.moveInProgress = false;
        }, eventDebounceTime);
        scope.moveInProgress = false;
        function fireRecalculating() {
            if (!scope.moveInProgress) {
                scope.moveInProgress = true;
                scope.$digest();
            }
            debouncedRecalculate();
        }
        function recalculatePosition() {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top += element.prop('offsetHeight');
        }
        scope.query = undefined;
        var timeoutPromise;
        var scheduleSearchWithTimeout = function (inputValue) {
            timeoutPromise = $timeout(function () {
                getMatchesAsync(inputValue);
            }, waitTime);
        };
        var cancelPreviousTimeout = function () {
            if (timeoutPromise) {
                $timeout.cancel(timeoutPromise);
            }
        };
        resetMatches();
        scope.assignIsOpen = function (isOpen) {
            isOpenSetter(originalScope, isOpen);
        };
        scope.select = function (activeIdx, evt) {
            var locals = {};
            var model, item;
            selected = true;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
            onSelectCallback(originalScope, {
                $item: item,
                $model: model,
                $label: parserResult.viewMapper(originalScope, locals),
                $event: evt
            });
            resetMatches();
            if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                $timeout(function () { element[0].focus(); }, 0, false);
            }
        };
        element.on('keydown', function (evt) {
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                return;
            }
            var shouldSelect = isSelectEvent(originalScope, { $event: evt });
            if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
                resetMatches();
                scope.$digest();
                return;
            }
            evt.preventDefault();
            var target;
            switch (evt.which) {
                case 27:
                    evt.stopPropagation();
                    resetMatches();
                    originalScope.$digest();
                    break;
                case 38:
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                case 40:
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                    target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                default:
                    if (shouldSelect) {
                        scope.$apply(function () {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(scope.activeIdx, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            }
                            else {
                                scope.select(scope.activeIdx, evt);
                            }
                        });
                    }
            }
        });
        element.on('focus', function (evt) {
            hasFocus = true;
            if (minLength === 0 && !modelCtrl.$viewValue) {
                $timeout(function () {
                    getMatchesAsync(modelCtrl.$viewValue, evt);
                }, 0);
            }
        });
        element.on('blur', function (evt) {
            if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                selected = true;
                scope.$apply(function () {
                    if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
                        $$debounce(function () {
                            scope.select(scope.activeIdx, evt);
                        }, scope.debounceUpdate.blur);
                    }
                    else {
                        scope.select(scope.activeIdx, evt);
                    }
                });
            }
            if (!isEditable && modelCtrl.$error.editable) {
                modelCtrl.$setViewValue();
                scope.$apply(function () {
                    modelCtrl.$setValidity('editable', true);
                    modelCtrl.$setValidity('parse', true);
                });
                element.val('');
            }
            hasFocus = false;
            selected = false;
        });
        var dismissClickHandler = function (evt) {
            if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                resetMatches();
                if (!$rootScope.$$phase) {
                    originalScope.$digest();
                }
            }
        };
        $document.on('click', dismissClickHandler);
        originalScope.$on('$destroy', function () {
            $document.off('click', dismissClickHandler);
            if (appendToBody || appendTo) {
                $popup.remove();
            }
            if (appendToBody) {
                angular.element($window).off('resize', fireRecalculating);
                $document.find('body').off('scroll', fireRecalculating);
            }
            popUpEl.remove();
            if (showHint) {
                inputsContainer.remove();
            }
        });
        var $popup = $compile(popUpEl)(scope);
        if (appendToBody) {
            $document.find('body').append($popup);
        }
        else if (appendTo) {
            angular.element(appendTo).eq(0).append($popup);
        }
        else {
            element.after($popup);
        }
        this.init = function (_modelCtrl) {
            modelCtrl = _modelCtrl;
            ngModelOptions = extractOptions(modelCtrl);
            scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);
            modelCtrl.$parsers.unshift(function (inputValue) {
                hasFocus = true;
                if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                    if (waitTime > 0) {
                        cancelPreviousTimeout();
                        scheduleSearchWithTimeout(inputValue);
                    }
                    else {
                        getMatchesAsync(inputValue);
                    }
                }
                else {
                    isLoadingSetter(originalScope, false);
                    cancelPreviousTimeout();
                    resetMatches();
                }
                if (isEditable) {
                    return inputValue;
                }
                if (!inputValue) {
                    modelCtrl.$setValidity('editable', true);
                    return null;
                }
                modelCtrl.$setValidity('editable', false);
                return undefined;
            });
            modelCtrl.$formatters.push(function (modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};
                if (!isEditable) {
                    modelCtrl.$setValidity('editable', true);
                }
                if (inputFormatter) {
                    locals.$model = modelValue;
                    return inputFormatter(originalScope, locals);
                }
                locals[parserResult.itemName] = modelValue;
                candidateViewValue = parserResult.viewMapper(originalScope, locals);
                locals[parserResult.itemName] = undefined;
                emptyViewValue = parserResult.viewMapper(originalScope, locals);
                return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            });
        };
        function extractOptions(ngModelCtrl) {
            var ngModelOptions;
            if (angular.version.minor < 6) {
                ngModelOptions = ngModelCtrl.$options || {};
                ngModelOptions.getOption = function (key) {
                    return ngModelOptions[key];
                };
            }
            else {
                ngModelOptions = ngModelCtrl.$options;
            }
            return ngModelOptions;
        }
    }])
    .directive('uibTypeahead', function () {
    return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', 'uibTypeahead'],
        link: function (originalScope, element, attrs, ctrls) {
            ctrls[1].init(ctrls[0]);
        }
    };
})
    .directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
        return {
            scope: {
                matches: '=',
                query: '=',
                active: '=',
                position: '&',
                moveInProgress: '=',
                select: '&',
                assignIsOpen: '&',
                debounce: '&'
            },
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
            },
            link: function (scope, element, attrs) {
                scope.templateUrl = attrs.templateUrl;
                scope.isOpen = function () {
                    var isDropdownOpen = scope.matches.length > 0;
                    scope.assignIsOpen({ isOpen: isDropdownOpen });
                    return isDropdownOpen;
                };
                scope.isActive = function (matchIdx) {
                    return scope.active === matchIdx;
                };
                scope.selectActive = function (matchIdx) {
                    scope.active = matchIdx;
                };
                scope.selectMatch = function (activeIdx, evt) {
                    var debounce = scope.debounce();
                    if (angular.isNumber(debounce) || angular.isObject(debounce)) {
                        $$debounce(function () {
                            scope.select({ activeIdx: activeIdx, evt: evt });
                        }, angular.isNumber(debounce) ? debounce : debounce['default']);
                    }
                    else {
                        scope.select({ activeIdx: activeIdx, evt: evt });
                    }
                };
            }
        };
    }])
    .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
        return {
            scope: {
                index: '=',
                match: '=',
                query: '='
            },
            link: function (scope, element, attrs) {
                var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
                $templateRequest(tplUrl).then(function (tplContent) {
                    var tplEl = angular.element(tplContent.trim());
                    element.replaceWith(tplEl);
                    $compile(tplEl)(scope);
                });
            }
        };
    }])
    .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
        var isSanitizePresent;
        isSanitizePresent = $injector.has('$sanitize');
        function escapeRegexp(queryToEscape) {
            return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }
        function containsHtml(matchItem) {
            return /<.*>/g.test(matchItem);
        }
        return function (matchItem, query) {
            if (!isSanitizePresent && containsHtml(matchItem)) {
                $log.warn('Unsafe use of typeahead please use ngSanitize');
            }
            matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
            if (!isSanitizePresent) {
                matchItem = $sce.trustAsHtml(matchItem);
            }
            return matchItem;
        };
    }]);
angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/accordion/accordion-group.html", "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
            "  <h4 class=\"panel-title\">\n" +
            "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
            "  </h4>\n" +
            "</div>\n" +
            "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
            "  <div class=\"panel-body\" ng-transclude></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
    }]);
angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/alert/alert.html", "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
            "  <span aria-hidden=\"true\">&times;</span>\n" +
            "  <span class=\"sr-only\">Close</span>\n" +
            "</button>\n" +
            "<div ng-transclude></div>\n" +
            "");
    }]);
angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/carousel/carousel.html", "<div class=\"carousel-inner\" ng-transclude></div>\n" +
            "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
            "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
            "  <span class=\"sr-only\">previous</span>\n" +
            "</a>\n" +
            "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
            "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
            "  <span class=\"sr-only\">next</span>\n" +
            "</a>\n" +
            "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
            "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
            "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
            "  </li>\n" +
            "</ol>\n" +
            "");
    }]);
angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/carousel/slide.html", "<div class=\"text-center\" ng-transclude></div>\n" +
            "");
    }]);
angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\">\n" +
            "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" +
            "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" +
            "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
            "  <thead>\n" +
            "    <tr>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
            "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
            "    </tr>\n" +
            "    <tr>\n" +
            "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
            "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
            "    </tr>\n" +
            "  </thead>\n" +
            "  <tbody>\n" +
            "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
            "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
            "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
            "        id=\"{{::dt.uid}}\"\n" +
            "        ng-class=\"::dt.customClass\">\n" +
            "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
            "          uib-is-class=\"\n" +
            "            'btn-info' for selectedDt,\n" +
            "            'active' for activeDt\n" +
            "            on dt\"\n" +
            "          ng-click=\"select(dt.date)\"\n" +
            "          ng-disabled=\"::dt.disabled\"\n" +
            "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
            "      </td>\n" +
            "    </tr>\n" +
            "  </tbody>\n" +
            "</table>\n" +
            "");
    }]);
angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
            "  <thead>\n" +
            "    <tr>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
            "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" +
            "    </tr>\n" +
            "  </thead>\n" +
            "  <tbody>\n" +
            "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
            "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
            "        id=\"{{::dt.uid}}\"\n" +
            "        ng-class=\"::dt.customClass\">\n" +
            "        <button type=\"button\" class=\"btn btn-default\"\n" +
            "          uib-is-class=\"\n" +
            "            'btn-info' for selectedDt,\n" +
            "            'active' for activeDt\n" +
            "            on dt\"\n" +
            "          ng-click=\"select(dt.date)\"\n" +
            "          ng-disabled=\"::dt.disabled\"\n" +
            "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
            "      </td>\n" +
            "    </tr>\n" +
            "  </tbody>\n" +
            "</table>\n" +
            "");
    }]);
angular.module("uib/template/datepicker/popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepicker/popup.html", "<div>\n" +
            "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
            "    <li ng-transclude></li>\n" +
            "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
            "      <span class=\"btn-group pull-left\">\n" +
            "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
            "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
            "      </span>\n" +
            "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
            "    </li>\n" +
            "  </ul>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
            "  <thead>\n" +
            "    <tr>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
            "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
            "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
            "    </tr>\n" +
            "  </thead>\n" +
            "  <tbody>\n" +
            "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
            "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
            "        id=\"{{::dt.uid}}\"\n" +
            "        ng-class=\"::dt.customClass\">\n" +
            "        <button type=\"button\" class=\"btn btn-default\"\n" +
            "          uib-is-class=\"\n" +
            "            'btn-info' for selectedDt,\n" +
            "            'active' for activeDt\n" +
            "            on dt\"\n" +
            "          ng-click=\"select(dt.date)\"\n" +
            "          ng-disabled=\"::dt.disabled\"\n" +
            "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
            "      </td>\n" +
            "    </tr>\n" +
            "  </tbody>\n" +
            "</table>\n" +
            "");
    }]);
angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/datepickerPopup/popup.html", "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
            "  <li ng-transclude></li>\n" +
            "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
            "    <span class=\"btn-group pull-left\">\n" +
            "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
            "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
            "    </span>\n" +
            "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
            "  </li>\n" +
            "</ul>\n" +
            "");
    }]);
angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/modal/backdrop.html", "<div class=\"modal-backdrop\"\n" +
            "     uib-modal-animation-class=\"fade\"\n" +
            "     modal-in-class=\"in\"\n" +
            "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
            "></div>\n" +
            "");
    }]);
angular.module("uib/template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
            "");
    }]);
angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/pager/pager.html", "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
            "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
            "");
    }]);
angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/pagination/pagination.html", "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" +
            "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
            "<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" +
            "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
            "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" +
            "");
    }]);
angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip-arrow\"></div>\n" +
            "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
            "");
    }]);
angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip-arrow\"></div>\n" +
            "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
            "");
    }]);
angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip-arrow\"></div>\n" +
            "<div class=\"tooltip-inner\"\n" +
            "  uib-tooltip-template-transclude=\"contentExp()\"\n" +
            "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
            "");
    }]);
angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"arrow\"></div>\n" +
            "\n" +
            "<div class=\"popover-inner\">\n" +
            "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
            "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"arrow\"></div>\n" +
            "\n" +
            "<div class=\"popover-inner\">\n" +
            "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
            "    <div class=\"popover-content\"\n" +
            "      uib-tooltip-template-transclude=\"contentExp()\"\n" +
            "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/popover/popover.html", "<div class=\"arrow\"></div>\n" +
            "\n" +
            "<div class=\"popover-inner\">\n" +
            "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
            "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
            "");
    }]);
angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
    }]);
angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" +
            "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
            "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
            "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
            "</span>\n" +
            "");
    }]);
angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
            "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
            "</li>\n" +
            "");
    }]);
angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" +
            "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
            "  <div class=\"tab-content\">\n" +
            "    <div class=\"tab-pane\"\n" +
            "         ng-repeat=\"tab in tabset.tabs\"\n" +
            "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
            "         uib-tab-content-transclude=\"tab\">\n" +
            "    </div>\n" +
            "  </div>\n" +
            "</div>\n" +
            "");
    }]);
angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" +
            "  <tbody>\n" +
            "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
            "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
            "      <td>&nbsp;</td>\n" +
            "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
            "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
            "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
            "      <td ng-show=\"showMeridian\"></td>\n" +
            "    </tr>\n" +
            "    <tr>\n" +
            "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
            "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
            "      </td>\n" +
            "      <td class=\"uib-separator\">:</td>\n" +
            "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
            "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
            "      </td>\n" +
            "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
            "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
            "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
            "      </td>\n" +
            "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
            "    </tr>\n" +
            "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
            "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
            "      <td>&nbsp;</td>\n" +
            "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
            "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
            "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
            "      <td ng-show=\"showMeridian\"></td>\n" +
            "    </tr>\n" +
            "  </tbody>\n" +
            "</table>\n" +
            "");
    }]);
angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" +
            "   tabindex=\"-1\"\n" +
            "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
            "   ng-attr-title=\"{{match.label}}\"></a>\n" +
            "");
    }]);
angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
        $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
            "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
            "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
            "    </li>\n" +
            "</ul>\n" +
            "");
    }]);
angular.module('ui.bootstrap.carousel').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });
(function (factory, root) {
    if (typeof define == "function" && define.amd) {
        define(factory);
    }
    else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory();
    }
    else {
        root.rangy = factory();
    }
})(function () {
    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";
    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer"];
    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];
    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];
    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
        "setEndPoint", "getBoundingClientRect"];
    function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
    }
    function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
    }
    function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
    }
    function createMultiplePropertyTest(testFunc) {
        return function (o, props) {
            var i = props.length;
            while (i--) {
                if (!testFunc(o, props[i])) {
                    return false;
                }
            }
            return true;
        };
    }
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);
    function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
    }
    function getBody(doc) {
        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }
    var forEach = [].forEach ?
        function (arr, func) {
            arr.forEach(func);
        } :
        function (arr, func) {
            for (var i = 0, len = arr.length; i < len; ++i) {
                func(arr[i], i);
            }
        };
    var modules = {};
    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);
    var util = {
        isHostMethod: isHostMethod,
        isHostObject: isHostObject,
        isHostProperty: isHostProperty,
        areHostMethods: areHostMethods,
        areHostObjects: areHostObjects,
        areHostProperties: areHostProperties,
        isTextRange: isTextRange,
        getBody: getBody,
        forEach: forEach
    };
    var api = {
        version: "1.3.0",
        initialized: false,
        isBrowser: isBrowser,
        supported: true,
        util: util,
        features: {},
        modules: modules,
        config: {
            alertOnFail: false,
            alertOnWarn: false,
            preferTextRange: false,
            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
        }
    };
    function consoleLog(msg) {
        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
            console.log(msg);
        }
    }
    function alertOrLog(msg, shouldAlert) {
        if (isBrowser && shouldAlert) {
            alert(msg);
        }
        else {
            consoleLog(msg);
        }
    }
    function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
    }
    api.fail = fail;
    function warn(msg) {
        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
    }
    api.warn = warn;
    var extend;
    if ({}.hasOwnProperty) {
        util.extend = extend = function (obj, props, deep) {
            var o, p;
            for (var i in props) {
                if (props.hasOwnProperty(i)) {
                    o = obj[i];
                    p = props[i];
                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
                        extend(o, p, true);
                    }
                    obj[i] = p;
                }
            }
            if (props.hasOwnProperty("toString")) {
                obj.toString = props.toString;
            }
            return obj;
        };
        util.createOptions = function (optionsParam, defaults) {
            var options = {};
            extend(options, defaults);
            if (optionsParam) {
                extend(options, optionsParam);
            }
            return options;
        };
    }
    else {
        fail("hasOwnProperty not supported");
    }
    if (!isBrowser) {
        fail("Rangy can only run in a browser");
    }
    (function () {
        var toArray;
        if (isBrowser) {
            var el = document.createElement("div");
            el.appendChild(document.createElement("span"));
            var slice = [].slice;
            try {
                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
                    toArray = function (arrayLike) {
                        return slice.call(arrayLike, 0);
                    };
                }
            }
            catch (e) { }
        }
        if (!toArray) {
            toArray = function (arrayLike) {
                var arr = [];
                for (var i = 0, len = arrayLike.length; i < len; ++i) {
                    arr[i] = arrayLike[i];
                }
                return arr;
            };
        }
        util.toArray = toArray;
    })();
    var addListener;
    if (isBrowser) {
        if (isHostMethod(document, "addEventListener")) {
            addListener = function (obj, eventType, listener) {
                obj.addEventListener(eventType, listener, false);
            };
        }
        else if (isHostMethod(document, "attachEvent")) {
            addListener = function (obj, eventType, listener) {
                obj.attachEvent("on" + eventType, listener);
            };
        }
        else {
            fail("Document does not have required addEventListener or attachEvent method");
        }
        util.addListener = addListener;
    }
    var initListeners = [];
    function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
    }
    function init() {
        if (!isBrowser || api.initialized) {
            return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;
        if (isHostMethod(document, "createRange")) {
            testRange = document.createRange();
            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
                implementsDomRange = true;
            }
        }
        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != "body") {
            fail("No body element found");
            return;
        }
        if (body && isHostMethod(body, "createTextRange")) {
            testRange = body.createTextRange();
            if (isTextRange(testRange)) {
                implementsTextRange = true;
            }
        }
        if (!implementsDomRange && !implementsTextRange) {
            fail("Neither Range nor TextRange are available");
            return;
        }
        api.initialized = true;
        api.features = {
            implementsDomRange: implementsDomRange,
            implementsTextRange: implementsTextRange
        };
        var module, errorMessage;
        for (var moduleName in modules) {
            if ((module = modules[moduleName]) instanceof Module) {
                module.init(module, api);
            }
        }
        for (var i = 0, len = initListeners.length; i < len; ++i) {
            try {
                initListeners[i](api);
            }
            catch (ex) {
                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
                consoleLog(errorMessage);
            }
        }
    }
    function deprecationNotice(deprecated, replacement, module) {
        if (module) {
            deprecated += " in module " + module.name;
        }
        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +
            replacement + " instead.");
    }
    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {
        owner[deprecated] = function () {
            deprecationNotice(deprecated, replacement, module);
            return owner[replacement].apply(owner, util.toArray(arguments));
        };
    }
    util.deprecationNotice = deprecationNotice;
    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;
    api.init = init;
    api.addInitListener = function (listener) {
        if (api.initialized) {
            listener(api);
        }
        else {
            initListeners.push(listener);
        }
    };
    var shimListeners = [];
    api.addShimListener = function (listener) {
        shimListeners.push(listener);
    };
    function shim(win) {
        win = win || window;
        init();
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
            shimListeners[i](win);
        }
    }
    if (isBrowser) {
        api.shim = api.createMissingNativeApi = shim;
        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
    }
    function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
    }
    Module.prototype = {
        init: function () {
            var requiredModuleNames = this.dependencies || [];
            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
                moduleName = requiredModuleNames[i];
                requiredModule = modules[moduleName];
                if (!requiredModule || !(requiredModule instanceof Module)) {
                    throw new Error("required module '" + moduleName + "' not found");
                }
                requiredModule.init();
                if (!requiredModule.supported) {
                    throw new Error("required module '" + moduleName + "' not supported");
                }
            }
            this.initializer(this);
        },
        fail: function (reason) {
            this.initialized = true;
            this.supported = false;
            throw new Error(reason);
        },
        warn: function (msg) {
            api.warn("Module " + this.name + ": " + msg);
        },
        deprecationNotice: function (deprecated, replacement) {
            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +
                replacement + " instead");
        },
        createError: function (msg) {
            return new Error("Error in Rangy " + this.name + " module: " + msg);
        }
    };
    function createModule(name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function (module) {
            if (!module.initialized) {
                module.initialized = true;
                try {
                    initFunc(api, module);
                    module.supported = true;
                }
                catch (ex) {
                    var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
                    consoleLog(errorMessage);
                    if (ex.stack) {
                        consoleLog(ex.stack);
                    }
                }
            }
        });
        modules[name] = newModule;
        return newModule;
    }
    api.createModule = function (name) {
        var initFunc, dependencies;
        if (arguments.length == 2) {
            initFunc = arguments[1];
            dependencies = [];
        }
        else {
            initFunc = arguments[2];
            dependencies = arguments[1];
        }
        var module = createModule(name, dependencies, initFunc);
        if (api.initialized && api.supported) {
            module.init();
        }
    };
    api.createCoreModule = function (name, dependencies, initFunc) {
        createModule(name, dependencies, initFunc);
    };
    function RangePrototype() { }
    api.RangePrototype = RangePrototype;
    api.rangePrototype = new RangePrototype();
    function SelectionPrototype() { }
    api.selectionPrototype = new SelectionPrototype();
    api.createCoreModule("DomUtil", [], function (api, module) {
        var UNDEF = "undefined";
        var util = api.util;
        var getBody = util.getBody;
        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
            module.fail("document missing a Node creation method");
        }
        if (!util.isHostMethod(document, "getElementsByTagName")) {
            module.fail("document missing getElementsByTagName method");
        }
        var el = document.createElement("div");
        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
            !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
            module.fail("Incomplete Element implementation");
        }
        if (!util.isHostProperty(el, "innerHTML")) {
            module.fail("Element is missing innerHTML property");
        }
        var textNode = document.createTextNode("test");
        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
            !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
            !util.areHostProperties(textNode, ["data"]))) {
            module.fail("Incomplete Text Node implementation");
        }
        var arrayContains = function (arr, val) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === val) {
                    return true;
                }
            }
            return false;
        };
        function isHtmlNamespace(node) {
            var ns;
            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
        }
        function parentElement(node) {
            var parent = node.parentNode;
            return (parent.nodeType == 1) ? parent : null;
        }
        function getNodeIndex(node) {
            var i = 0;
            while ((node = node.previousSibling)) {
                ++i;
            }
            return i;
        }
        function getNodeLength(node) {
            switch (node.nodeType) {
                case 7:
                case 10:
                    return 0;
                case 3:
                case 8:
                    return node.length;
                default:
                    return node.childNodes.length;
            }
        }
        function getCommonAncestor(node1, node2) {
            var ancestors = [], n;
            for (n = node1; n; n = n.parentNode) {
                ancestors.push(n);
            }
            for (n = node2; n; n = n.parentNode) {
                if (arrayContains(ancestors, n)) {
                    return n;
                }
            }
            return null;
        }
        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
            var n = selfIsAncestor ? descendant : descendant.parentNode;
            while (n) {
                if (n === ancestor) {
                    return true;
                }
                else {
                    n = n.parentNode;
                }
            }
            return false;
        }
        function isOrIsAncestorOf(ancestor, descendant) {
            return isAncestorOf(ancestor, descendant, true);
        }
        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
            var p, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
                p = n.parentNode;
                if (p === ancestor) {
                    return n;
                }
                n = p;
            }
            return null;
        }
        function isCharacterDataNode(node) {
            var t = node.nodeType;
            return t == 3 || t == 4 || t == 8;
        }
        function isTextOrCommentNode(node) {
            if (!node) {
                return false;
            }
            var t = node.nodeType;
            return t == 3 || t == 8;
        }
        function insertAfter(node, precedingNode) {
            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
            if (nextNode) {
                parent.insertBefore(node, nextNode);
            }
            else {
                parent.appendChild(node);
            }
            return node;
        }
        function splitDataNode(node, index, positionsToPreserve) {
            var newNode = node.cloneNode(false);
            newNode.deleteData(0, index);
            node.deleteData(index, node.length - index);
            insertAfter(newNode, node);
            if (positionsToPreserve) {
                for (var i = 0, position; position = positionsToPreserve[i++];) {
                    if (position.node == node && position.offset > index) {
                        position.node = newNode;
                        position.offset -= index;
                    }
                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
                        ++position.offset;
                    }
                }
            }
            return newNode;
        }
        function getDocument(node) {
            if (node.nodeType == 9) {
                return node;
            }
            else if (typeof node.ownerDocument != UNDEF) {
                return node.ownerDocument;
            }
            else if (typeof node.document != UNDEF) {
                return node.document;
            }
            else if (node.parentNode) {
                return getDocument(node.parentNode);
            }
            else {
                throw module.createError("getDocument: no document found for node");
            }
        }
        function getWindow(node) {
            var doc = getDocument(node);
            if (typeof doc.defaultView != UNDEF) {
                return doc.defaultView;
            }
            else if (typeof doc.parentWindow != UNDEF) {
                return doc.parentWindow;
            }
            else {
                throw module.createError("Cannot get a window object for node");
            }
        }
        function getIframeDocument(iframeEl) {
            if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument;
            }
            else if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow.document;
            }
            else {
                throw module.createError("getIframeDocument: No Document object found for iframe element");
            }
        }
        function getIframeWindow(iframeEl) {
            if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow;
            }
            else if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument.defaultView;
            }
            else {
                throw module.createError("getIframeWindow: No Window object found for iframe element");
            }
        }
        function isWindow(obj) {
            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
        }
        function getContentDocument(obj, module, methodName) {
            var doc;
            if (!obj) {
                doc = document;
            }
            else if (util.isHostProperty(obj, "nodeType")) {
                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
                    getIframeDocument(obj) : getDocument(obj);
            }
            else if (isWindow(obj)) {
                doc = obj.document;
            }
            if (!doc) {
                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
            }
            return doc;
        }
        function getRootContainer(node) {
            var parent;
            while ((parent = node.parentNode)) {
                node = parent;
            }
            return node;
        }
        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
            var nodeC, root, childA, childB, n;
            if (nodeA == nodeB) {
                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
            }
            else if ((nodeC = getClosestAncestorIn(nodeB, nodeA, true))) {
                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
            }
            else if ((nodeC = getClosestAncestorIn(nodeA, nodeB, true))) {
                return getNodeIndex(nodeC) < offsetB ? -1 : 1;
            }
            else {
                root = getCommonAncestor(nodeA, nodeB);
                if (!root) {
                    throw new Error("comparePoints error: nodes have no common ancestor");
                }
                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);
                if (childA === childB) {
                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
                }
                else {
                    n = root.firstChild;
                    while (n) {
                        if (n === childA) {
                            return -1;
                        }
                        else if (n === childB) {
                            return 1;
                        }
                        n = n.nextSibling;
                    }
                }
            }
        }
        var crashyTextNodes = false;
        function isBrokenNode(node) {
            var n;
            try {
                n = node.parentNode;
                return false;
            }
            catch (e) {
                return true;
            }
        }
        (function () {
            var el = document.createElement("b");
            el.innerHTML = "1";
            var textNode = el.firstChild;
            el.innerHTML = "<br />";
            crashyTextNodes = isBrokenNode(textNode);
            api.features.crashyTextNodes = crashyTextNodes;
        })();
        function inspectNode(node) {
            if (!node) {
                return "[No node]";
            }
            if (crashyTextNodes && isBrokenNode(node)) {
                return "[Broken node]";
            }
            if (isCharacterDataNode(node)) {
                return '"' + node.data + '"';
            }
            if (node.nodeType == 1) {
                var idAttr = node.id ? ' id="' + node.id + '"' : "";
                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
            }
            return node.nodeName;
        }
        function fragmentFromNodeChildren(node) {
            var fragment = getDocument(node).createDocumentFragment(), child;
            while ((child = node.firstChild)) {
                fragment.appendChild(child);
            }
            return fragment;
        }
        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
            getComputedStyleProperty = function (el, propName) {
                return getWindow(el).getComputedStyle(el, null)[propName];
            };
        }
        else if (typeof document.documentElement.currentStyle != UNDEF) {
            getComputedStyleProperty = function (el, propName) {
                return el.currentStyle ? el.currentStyle[propName] : "";
            };
        }
        else {
            module.fail("No means of obtaining computed style properties found");
        }
        function createTestElement(doc, html, contentEditable) {
            var body = getBody(doc);
            var el = doc.createElement("div");
            el.contentEditable = "" + !!contentEditable;
            if (html) {
                el.innerHTML = html;
            }
            var bodyFirstChild = body.firstChild;
            if (bodyFirstChild) {
                body.insertBefore(el, bodyFirstChild);
            }
            else {
                body.appendChild(el);
            }
            return el;
        }
        function removeNode(node) {
            return node.parentNode.removeChild(node);
        }
        function NodeIterator(root) {
            this.root = root;
            this._next = root;
        }
        NodeIterator.prototype = {
            _current: null,
            hasNext: function () {
                return !!this._next;
            },
            next: function () {
                var n = this._current = this._next;
                var child, next;
                if (this._current) {
                    child = n.firstChild;
                    if (child) {
                        this._next = child;
                    }
                    else {
                        next = null;
                        while ((n !== this.root) && !(next = n.nextSibling)) {
                            n = n.parentNode;
                        }
                        this._next = next;
                    }
                }
                return this._current;
            },
            detach: function () {
                this._current = this._next = this.root = null;
            }
        };
        function createIterator(root) {
            return new NodeIterator(root);
        }
        function DomPosition(node, offset) {
            this.node = node;
            this.offset = offset;
        }
        DomPosition.prototype = {
            equals: function (pos) {
                return !!pos && this.node === pos.node && this.offset == pos.offset;
            },
            inspect: function () {
                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
            },
            toString: function () {
                return this.inspect();
            }
        };
        function DOMException(codeName) {
            this.code = this[codeName];
            this.codeName = codeName;
            this.message = "DOMException: " + this.codeName;
        }
        DOMException.prototype = {
            INDEX_SIZE_ERR: 1,
            HIERARCHY_REQUEST_ERR: 3,
            WRONG_DOCUMENT_ERR: 4,
            NO_MODIFICATION_ALLOWED_ERR: 7,
            NOT_FOUND_ERR: 8,
            NOT_SUPPORTED_ERR: 9,
            INVALID_STATE_ERR: 11,
            INVALID_NODE_TYPE_ERR: 24
        };
        DOMException.prototype.toString = function () {
            return this.message;
        };
        api.dom = {
            arrayContains: arrayContains,
            isHtmlNamespace: isHtmlNamespace,
            parentElement: parentElement,
            getNodeIndex: getNodeIndex,
            getNodeLength: getNodeLength,
            getCommonAncestor: getCommonAncestor,
            isAncestorOf: isAncestorOf,
            isOrIsAncestorOf: isOrIsAncestorOf,
            getClosestAncestorIn: getClosestAncestorIn,
            isCharacterDataNode: isCharacterDataNode,
            isTextOrCommentNode: isTextOrCommentNode,
            insertAfter: insertAfter,
            splitDataNode: splitDataNode,
            getDocument: getDocument,
            getWindow: getWindow,
            getIframeWindow: getIframeWindow,
            getIframeDocument: getIframeDocument,
            getBody: getBody,
            isWindow: isWindow,
            getContentDocument: getContentDocument,
            getRootContainer: getRootContainer,
            comparePoints: comparePoints,
            isBrokenNode: isBrokenNode,
            inspectNode: inspectNode,
            getComputedStyleProperty: getComputedStyleProperty,
            createTestElement: createTestElement,
            removeNode: removeNode,
            fragmentFromNodeChildren: fragmentFromNodeChildren,
            createIterator: createIterator,
            DomPosition: DomPosition
        };
        api.DOMException = DOMException;
    });
    api.createCoreModule("DomRange", ["DomUtil"], function (api, module) {
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DOMException = api.DOMException;
        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api.features.crashyTextNodes;
        var removeNode = dom.removeNode;
        function isNonTextPartiallySelected(node, range) {
            return (node.nodeType != 3) &&
                (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
        }
        function getRangeDocument(range) {
            return range.document || getDocument(range.startContainer);
        }
        function getRangeRoot(range) {
            return getRootContainer(range.startContainer);
        }
        function getBoundaryBeforeNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node));
        }
        function getBoundaryAfterNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
        }
        function insertNodeAtPosition(node, n, o) {
            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
            if (isCharacterDataNode(n)) {
                if (o == n.length) {
                    dom.insertAfter(node, n);
                }
                else {
                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
                }
            }
            else if (o >= n.childNodes.length) {
                n.appendChild(node);
            }
            else {
                n.insertBefore(node, n.childNodes[o]);
            }
            return firstNodeInserted;
        }
        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
            assertRangeValid(rangeA);
            assertRangeValid(rangeB);
            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);
            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }
        function cloneSubtree(iterator) {
            var partiallySelected;
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {
                partiallySelected = iterator.isPartiallySelectedSubtree();
                node = node.cloneNode(!partiallySelected);
                if (partiallySelected) {
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(cloneSubtree(subIterator));
                    subIterator.detach();
                }
                if (node.nodeType == 10) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }
        function iterateSubtree(rangeIterator, func, iteratorState) {
            var it, n;
            iteratorState = iteratorState || { stop: false };
            for (var node, subRangeIterator; node = rangeIterator.next();) {
                if (rangeIterator.isPartiallySelectedSubtree()) {
                    if (func(node) === false) {
                        iteratorState.stop = true;
                        return;
                    }
                    else {
                        subRangeIterator = rangeIterator.getSubtreeIterator();
                        iterateSubtree(subRangeIterator, func, iteratorState);
                        subRangeIterator.detach();
                        if (iteratorState.stop) {
                            return;
                        }
                    }
                }
                else {
                    it = dom.createIterator(node);
                    while ((n = it.next())) {
                        if (func(n) === false) {
                            iteratorState.stop = true;
                            return;
                        }
                    }
                }
            }
        }
        function deleteSubtree(iterator) {
            var subIterator;
            while (iterator.next()) {
                if (iterator.isPartiallySelectedSubtree()) {
                    subIterator = iterator.getSubtreeIterator();
                    deleteSubtree(subIterator);
                    subIterator.detach();
                }
                else {
                    iterator.remove();
                }
            }
        }
        function extractSubtree(iterator) {
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {
                if (iterator.isPartiallySelectedSubtree()) {
                    node = node.cloneNode(false);
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(extractSubtree(subIterator));
                    subIterator.detach();
                }
                else {
                    iterator.remove();
                }
                if (node.nodeType == 10) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }
        function getNodesInRange(range, nodeTypes, filter) {
            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
            var filterExists = !!filter;
            if (filterNodeTypes) {
                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
            }
            var nodes = [];
            iterateSubtree(new RangeIterator(range, false), function (node) {
                if (filterNodeTypes && !regex.test(node.nodeType)) {
                    return;
                }
                if (filterExists && !filter(node)) {
                    return;
                }
                var sc = range.startContainer;
                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
                    return;
                }
                var ec = range.endContainer;
                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
                    return;
                }
                nodes.push(node);
            });
            return nodes;
        }
        function inspect(range) {
            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
                dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
        }
        function RangeIterator(range, clonePartiallySelectedTextNodes) {
            this.range = range;
            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;
            if (!range.collapsed) {
                this.sc = range.startContainer;
                this.so = range.startOffset;
                this.ec = range.endContainer;
                this.eo = range.endOffset;
                var root = range.commonAncestorContainer;
                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
                    this.isSingleCharacterDataNode = true;
                    this._first = this._last = this._next = this.sc;
                }
                else {
                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
                }
            }
        }
        RangeIterator.prototype = {
            _current: null,
            _next: null,
            _first: null,
            _last: null,
            isSingleCharacterDataNode: false,
            reset: function () {
                this._current = null;
                this._next = this._first;
            },
            hasNext: function () {
                return !!this._next;
            },
            next: function () {
                var current = this._current = this._next;
                if (current) {
                    this._next = (current !== this._last) ? current.nextSibling : null;
                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                        if (current === this.ec) {
                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                        }
                        if (this._current === this.sc) {
                            (current = current.cloneNode(true)).deleteData(0, this.so);
                        }
                    }
                }
                return current;
            },
            remove: function () {
                var current = this._current, start, end;
                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
                    start = (current === this.sc) ? this.so : 0;
                    end = (current === this.ec) ? this.eo : current.length;
                    if (start != end) {
                        current.deleteData(start, end - start);
                    }
                }
                else {
                    if (current.parentNode) {
                        removeNode(current);
                    }
                    else {
                    }
                }
            },
            isPartiallySelectedSubtree: function () {
                var current = this._current;
                return isNonTextPartiallySelected(current, this.range);
            },
            getSubtreeIterator: function () {
                var subRange;
                if (this.isSingleCharacterDataNode) {
                    subRange = this.range.cloneRange();
                    subRange.collapse(false);
                }
                else {
                    subRange = new Range(getRangeDocument(this.range));
                    var current = this._current;
                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);
                    if (isOrIsAncestorOf(current, this.sc)) {
                        startContainer = this.sc;
                        startOffset = this.so;
                    }
                    if (isOrIsAncestorOf(current, this.ec)) {
                        endContainer = this.ec;
                        endOffset = this.eo;
                    }
                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
                }
                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
            },
            detach: function () {
                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
            }
        };
        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
        var rootContainerNodeTypes = [2, 9, 11];
        var readonlyNodeTypes = [5, 6, 10, 12];
        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];
        function createAncestorFinder(nodeTypes) {
            return function (node, selfIsAncestor) {
                var t, n = selfIsAncestor ? node : node.parentNode;
                while (n) {
                    t = n.nodeType;
                    if (arrayContains(nodeTypes, t)) {
                        return n;
                    }
                    n = n.parentNode;
                }
                return null;
            };
        }
        var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);
        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }
        function assertValidNodeType(node, invalidTypes) {
            if (!arrayContains(invalidTypes, node.nodeType)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }
        function assertValidOffset(node, offset) {
            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
                throw new DOMException("INDEX_SIZE_ERR");
            }
        }
        function assertSameDocumentOrFragment(node1, node2) {
            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }
        function assertNodeNotReadOnly(node) {
            if (getReadonlyAncestor(node, true)) {
                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
            }
        }
        function assertNode(node, codeName) {
            if (!node) {
                throw new DOMException(codeName);
            }
        }
        function isValidOffset(node, offset) {
            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
        }
        function isRangeValid(range) {
            return (!!range.startContainer && !!range.endContainer &&
                !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&
                getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&
                isValidOffset(range.startContainer, range.startOffset) &&
                isValidOffset(range.endContainer, range.endOffset));
        }
        function assertRangeValid(range) {
            if (!isRangeValid(range)) {
                throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");
            }
        }
        var styleEl = document.createElement("style");
        var htmlParsingConforms = false;
        try {
            styleEl.innerHTML = "<b>x</b>";
            htmlParsingConforms = (styleEl.firstChild.nodeType == 3);
        }
        catch (e) {
        }
        api.features.htmlParsingConforms = htmlParsingConforms;
        var createContextualFragment = htmlParsingConforms ?
            function (fragmentStr) {
                var node = this.startContainer;
                var doc = getDocument(node);
                if (!node) {
                    throw new DOMException("INVALID_STATE_ERR");
                }
                var el = null;
                if (node.nodeType == 1) {
                    el = node;
                }
                else if (isCharacterDataNode(node)) {
                    el = dom.parentElement(node);
                }
                if (el === null || (el.nodeName == "HTML" &&
                    dom.isHtmlNamespace(getDocument(el).documentElement) &&
                    dom.isHtmlNamespace(el))) {
                    el = doc.createElement("body");
                }
                else {
                    el = el.cloneNode(false);
                }
                el.innerHTML = fragmentStr;
                return dom.fragmentFromNodeChildren(el);
            } :
            function (fragmentStr) {
                var doc = getRangeDocument(this);
                var el = doc.createElement("body");
                el.innerHTML = fragmentStr;
                return dom.fragmentFromNodeChildren(el);
            };
        function splitRangeBoundaries(range, positionsToPreserve) {
            assertRangeValid(range);
            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
            var startEndSame = (sc === ec);
            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
                splitDataNode(ec, eo, positionsToPreserve);
            }
            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
                sc = splitDataNode(sc, so, positionsToPreserve);
                if (startEndSame) {
                    eo -= so;
                    ec = sc;
                }
                else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
                    eo++;
                }
                so = 0;
            }
            range.setStartAndEnd(sc, so, ec, eo);
        }
        function rangeToHtml(range) {
            assertRangeValid(range);
            var container = range.commonAncestorContainer.parentNode.cloneNode(false);
            container.appendChild(range.cloneContents());
            return container.innerHTML;
        }
        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
            "commonAncestorContainer"];
        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;
        util.extend(api.rangePrototype, {
            compareBoundaryPoints: function (how, range) {
                assertRangeValid(this);
                assertSameDocumentOrFragment(this.startContainer, range.startContainer);
                var nodeA, offsetA, nodeB, offsetB;
                var prefixA = (how == e2s || how == s2s) ? "start" : "end";
                var prefixB = (how == s2e || how == s2s) ? "start" : "end";
                nodeA = this[prefixA + "Container"];
                offsetA = this[prefixA + "Offset"];
                nodeB = range[prefixB + "Container"];
                offsetB = range[prefixB + "Offset"];
                return comparePoints(nodeA, offsetA, nodeB, offsetB);
            },
            insertNode: function (node) {
                assertRangeValid(this);
                assertValidNodeType(node, insertableNodeTypes);
                assertNodeNotReadOnly(this.startContainer);
                if (isOrIsAncestorOf(node, this.startContainer)) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
                this.setStartBefore(firstNodeInserted);
            },
            cloneContents: function () {
                assertRangeValid(this);
                var clone, frag;
                if (this.collapsed) {
                    return getRangeDocument(this).createDocumentFragment();
                }
                else {
                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                        clone = this.startContainer.cloneNode(true);
                        clone.data = clone.data.slice(this.startOffset, this.endOffset);
                        frag = getRangeDocument(this).createDocumentFragment();
                        frag.appendChild(clone);
                        return frag;
                    }
                    else {
                        var iterator = new RangeIterator(this, true);
                        clone = cloneSubtree(iterator);
                        iterator.detach();
                    }
                    return clone;
                }
            },
            canSurroundContents: function () {
                assertRangeValid(this);
                assertNodeNotReadOnly(this.startContainer);
                assertNodeNotReadOnly(this.endContainer);
                var iterator = new RangeIterator(this, true);
                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                    (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                iterator.detach();
                return !boundariesInvalid;
            },
            surroundContents: function (node) {
                assertValidNodeType(node, surroundNodeTypes);
                if (!this.canSurroundContents()) {
                    throw new DOMException("INVALID_STATE_ERR");
                }
                var content = this.extractContents();
                if (node.hasChildNodes()) {
                    while (node.lastChild) {
                        node.removeChild(node.lastChild);
                    }
                }
                insertNodeAtPosition(node, this.startContainer, this.startOffset);
                node.appendChild(content);
                this.selectNode(node);
            },
            cloneRange: function () {
                assertRangeValid(this);
                var range = new Range(getRangeDocument(this));
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = this[prop];
                }
                return range;
            },
            toString: function () {
                assertRangeValid(this);
                var sc = this.startContainer;
                if (sc === this.endContainer && isCharacterDataNode(sc)) {
                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
                }
                else {
                    var textParts = [], iterator = new RangeIterator(this, true);
                    iterateSubtree(iterator, function (node) {
                        if (node.nodeType == 3 || node.nodeType == 4) {
                            textParts.push(node.data);
                        }
                    });
                    iterator.detach();
                    return textParts.join("");
                }
            },
            compareNode: function (node) {
                assertRangeValid(this);
                var parent = node.parentNode;
                var nodeIndex = getNodeIndex(node);
                if (!parent) {
                    throw new DOMException("NOT_FOUND_ERR");
                }
                var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);
                if (startComparison < 0) {
                    return (endComparison > 0) ? n_b_a : n_b;
                }
                else {
                    return (endComparison > 0) ? n_a : n_i;
                }
            },
            comparePoint: function (node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);
                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
                    return -1;
                }
                else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
                    return 1;
                }
                return 0;
            },
            createContextualFragment: createContextualFragment,
            toHtml: function () {
                return rangeToHtml(this);
            },
            intersectsNode: function (node, touchingIsIntersecting) {
                assertRangeValid(this);
                if (getRootContainer(node) != getRangeRoot(this)) {
                    return false;
                }
                var parent = node.parentNode, offset = getNodeIndex(node);
                if (!parent) {
                    return true;
                }
                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset), endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);
                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
            },
            isPointInRange: function (node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);
                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
                    (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
            },
            intersectsRange: function (range) {
                return rangesIntersect(this, range, false);
            },
            intersectsOrTouchesRange: function (range) {
                return rangesIntersect(this, range, true);
            },
            intersection: function (range) {
                if (this.intersectsRange(range)) {
                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset), endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);
                    var intersectionRange = this.cloneRange();
                    if (startComparison == -1) {
                        intersectionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (endComparison == 1) {
                        intersectionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return intersectionRange;
                }
                return null;
            },
            union: function (range) {
                if (this.intersectsOrTouchesRange(range)) {
                    var unionRange = this.cloneRange();
                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                        unionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                        unionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return unionRange;
                }
                else {
                    throw new DOMException("Ranges do not intersect");
                }
            },
            containsNode: function (node, allowPartial) {
                if (allowPartial) {
                    return this.intersectsNode(node, false);
                }
                else {
                    return this.compareNode(node) == n_i;
                }
            },
            containsNodeContents: function (node) {
                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
            },
            containsRange: function (range) {
                var intersection = this.intersection(range);
                return intersection !== null && range.equals(intersection);
            },
            containsNodeText: function (node) {
                var nodeRange = this.cloneRange();
                nodeRange.selectNode(node);
                var textNodes = nodeRange.getNodes([3]);
                if (textNodes.length > 0) {
                    nodeRange.setStart(textNodes[0], 0);
                    var lastTextNode = textNodes.pop();
                    nodeRange.setEnd(lastTextNode, lastTextNode.length);
                    return this.containsRange(nodeRange);
                }
                else {
                    return this.containsNodeContents(node);
                }
            },
            getNodes: function (nodeTypes, filter) {
                assertRangeValid(this);
                return getNodesInRange(this, nodeTypes, filter);
            },
            getDocument: function () {
                return getRangeDocument(this);
            },
            collapseBefore: function (node) {
                this.setEndBefore(node);
                this.collapse(false);
            },
            collapseAfter: function (node) {
                this.setStartAfter(node);
                this.collapse(true);
            },
            getBookmark: function (containerNode) {
                var doc = getRangeDocument(this);
                var preSelectionRange = api.createRange(doc);
                containerNode = containerNode || dom.getBody(doc);
                preSelectionRange.selectNodeContents(containerNode);
                var range = this.intersection(preSelectionRange);
                var start = 0, end = 0;
                if (range) {
                    preSelectionRange.setEnd(range.startContainer, range.startOffset);
                    start = preSelectionRange.toString().length;
                    end = start + range.toString().length;
                }
                return {
                    start: start,
                    end: end,
                    containerNode: containerNode
                };
            },
            moveToBookmark: function (bookmark) {
                var containerNode = bookmark.containerNode;
                var charIndex = 0;
                this.setStart(containerNode, 0);
                this.collapse(true);
                var nodeStack = [containerNode], node, foundStart = false, stop = false;
                var nextCharIndex, i, childNodes;
                while (!stop && (node = nodeStack.pop())) {
                    if (node.nodeType == 3) {
                        nextCharIndex = charIndex + node.length;
                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                            this.setStart(node, bookmark.start - charIndex);
                            foundStart = true;
                        }
                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                            this.setEnd(node, bookmark.end - charIndex);
                            stop = true;
                        }
                        charIndex = nextCharIndex;
                    }
                    else {
                        childNodes = node.childNodes;
                        i = childNodes.length;
                        while (i--) {
                            nodeStack.push(childNodes[i]);
                        }
                    }
                }
            },
            getName: function () {
                return "DomRange";
            },
            equals: function (range) {
                return Range.rangesEqual(this, range);
            },
            isValid: function () {
                return isRangeValid(this);
            },
            inspect: function () {
                return inspect(this);
            },
            detach: function () {
            }
        });
        function copyComparisonConstantsToObject(obj) {
            obj.START_TO_START = s2s;
            obj.START_TO_END = s2e;
            obj.END_TO_END = e2e;
            obj.END_TO_START = e2s;
            obj.NODE_BEFORE = n_b;
            obj.NODE_AFTER = n_a;
            obj.NODE_BEFORE_AND_AFTER = n_b_a;
            obj.NODE_INSIDE = n_i;
        }
        function copyComparisonConstants(constructor) {
            copyComparisonConstantsToObject(constructor);
            copyComparisonConstantsToObject(constructor.prototype);
        }
        function createRangeContentRemover(remover, boundaryUpdater) {
            return function () {
                assertRangeValid(this);
                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;
                var iterator = new RangeIterator(this, true);
                var node, boundary;
                if (sc !== root) {
                    node = getClosestAncestorIn(sc, root, true);
                    boundary = getBoundaryAfterNode(node);
                    sc = boundary.node;
                    so = boundary.offset;
                }
                iterateSubtree(iterator, assertNodeNotReadOnly);
                iterator.reset();
                var returnValue = remover(iterator);
                iterator.detach();
                boundaryUpdater(this, sc, so, sc, so);
                return returnValue;
            };
        }
        function createPrototypeRange(constructor, boundaryUpdater) {
            function createBeforeAfterNodeSetter(isBefore, isStart) {
                return function (node) {
                    assertValidNodeType(node, beforeAfterNodeTypes);
                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);
                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
                };
            }
            function setRangeStart(range, node, offset) {
                var ec = range.endContainer, eo = range.endOffset;
                if (node !== range.startContainer || offset !== range.startOffset) {
                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
                        ec = node;
                        eo = offset;
                    }
                    boundaryUpdater(range, node, offset, ec, eo);
                }
            }
            function setRangeEnd(range, node, offset) {
                var sc = range.startContainer, so = range.startOffset;
                if (node !== range.endContainer || offset !== range.endOffset) {
                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
                        sc = node;
                        so = offset;
                    }
                    boundaryUpdater(range, sc, so, node, offset);
                }
            }
            var F = function () { };
            F.prototype = api.rangePrototype;
            constructor.prototype = new F();
            util.extend(constructor.prototype, {
                setStart: function (node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    setRangeStart(this, node, offset);
                },
                setEnd: function (node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    setRangeEnd(this, node, offset);
                },
                setStartAndEnd: function () {
                    var args = arguments;
                    var sc = args[0], so = args[1], ec = sc, eo = so;
                    switch (args.length) {
                        case 3:
                            eo = args[2];
                            break;
                        case 4:
                            ec = args[2];
                            eo = args[3];
                            break;
                    }
                    boundaryUpdater(this, sc, so, ec, eo);
                },
                setBoundary: function (node, offset, isStart) {
                    this["set" + (isStart ? "Start" : "End")](node, offset);
                },
                setStartBefore: createBeforeAfterNodeSetter(true, true),
                setStartAfter: createBeforeAfterNodeSetter(false, true),
                setEndBefore: createBeforeAfterNodeSetter(true, false),
                setEndAfter: createBeforeAfterNodeSetter(false, false),
                collapse: function (isStart) {
                    assertRangeValid(this);
                    if (isStart) {
                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
                    }
                    else {
                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
                    }
                },
                selectNodeContents: function (node) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    boundaryUpdater(this, node, 0, node, getNodeLength(node));
                },
                selectNode: function (node) {
                    assertNoDocTypeNotationEntityAncestor(node, false);
                    assertValidNodeType(node, beforeAfterNodeTypes);
                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
                },
                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),
                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),
                canSurroundContents: function () {
                    assertRangeValid(this);
                    assertNodeNotReadOnly(this.startContainer);
                    assertNodeNotReadOnly(this.endContainer);
                    var iterator = new RangeIterator(this, true);
                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                    iterator.detach();
                    return !boundariesInvalid;
                },
                splitBoundaries: function () {
                    splitRangeBoundaries(this);
                },
                splitBoundariesPreservingPositions: function (positionsToPreserve) {
                    splitRangeBoundaries(this, positionsToPreserve);
                },
                normalizeBoundaries: function () {
                    assertRangeValid(this);
                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;
                    var mergeForward = function (node) {
                        var sibling = node.nextSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            ec = node;
                            eo = node.length;
                            node.appendData(sibling.data);
                            removeNode(sibling);
                        }
                    };
                    var mergeBackward = function (node) {
                        var sibling = node.previousSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            sc = node;
                            var nodeLength = node.length;
                            so = sibling.length;
                            node.insertData(0, sibling.data);
                            removeNode(sibling);
                            if (sc == ec) {
                                eo += so;
                                ec = sc;
                            }
                            else if (ec == node.parentNode) {
                                var nodeIndex = getNodeIndex(node);
                                if (eo == nodeIndex) {
                                    ec = node;
                                    eo = nodeLength;
                                }
                                else if (eo > nodeIndex) {
                                    eo--;
                                }
                            }
                        }
                    };
                    var normalizeStart = true;
                    var sibling;
                    if (isCharacterDataNode(ec)) {
                        if (eo == ec.length) {
                            mergeForward(ec);
                        }
                        else if (eo == 0) {
                            sibling = ec.previousSibling;
                            if (sibling && sibling.nodeType == ec.nodeType) {
                                eo = sibling.length;
                                if (sc == ec) {
                                    normalizeStart = false;
                                }
                                sibling.appendData(ec.data);
                                removeNode(ec);
                                ec = sibling;
                            }
                        }
                    }
                    else {
                        if (eo > 0) {
                            var endNode = ec.childNodes[eo - 1];
                            if (endNode && isCharacterDataNode(endNode)) {
                                mergeForward(endNode);
                            }
                        }
                        normalizeStart = !this.collapsed;
                    }
                    if (normalizeStart) {
                        if (isCharacterDataNode(sc)) {
                            if (so == 0) {
                                mergeBackward(sc);
                            }
                            else if (so == sc.length) {
                                sibling = sc.nextSibling;
                                if (sibling && sibling.nodeType == sc.nodeType) {
                                    if (ec == sibling) {
                                        ec = sc;
                                        eo += sc.length;
                                    }
                                    sc.appendData(sibling.data);
                                    removeNode(sibling);
                                }
                            }
                        }
                        else {
                            if (so < sc.childNodes.length) {
                                var startNode = sc.childNodes[so];
                                if (startNode && isCharacterDataNode(startNode)) {
                                    mergeBackward(startNode);
                                }
                            }
                        }
                    }
                    else {
                        sc = ec;
                        so = eo;
                    }
                    boundaryUpdater(this, sc, so, ec, eo);
                },
                collapseToPoint: function (node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    this.setStartAndEnd(node, offset);
                }
            });
            copyComparisonConstants(constructor);
        }
        function updateCollapsedAndCommonAncestor(range) {
            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
            range.commonAncestorContainer = range.collapsed ?
                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }
        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
            range.startContainer = startContainer;
            range.startOffset = startOffset;
            range.endContainer = endContainer;
            range.endOffset = endOffset;
            range.document = dom.getDocument(startContainer);
            updateCollapsedAndCommonAncestor(range);
        }
        function Range(doc) {
            this.startContainer = doc;
            this.startOffset = 0;
            this.endContainer = doc;
            this.endOffset = 0;
            this.document = doc;
            updateCollapsedAndCommonAncestor(this);
        }
        createPrototypeRange(Range, updateBoundaries);
        util.extend(Range, {
            rangeProperties: rangeProperties,
            RangeIterator: RangeIterator,
            copyComparisonConstants: copyComparisonConstants,
            createPrototypeRange: createPrototypeRange,
            inspect: inspect,
            toHtml: rangeToHtml,
            getRangeDocument: getRangeDocument,
            rangesEqual: function (r1, r2) {
                return r1.startContainer === r2.startContainer &&
                    r1.startOffset === r2.startOffset &&
                    r1.endContainer === r2.endContainer &&
                    r1.endOffset === r2.endOffset;
            }
        });
        api.DomRange = Range;
    });
    api.createCoreModule("WrappedRange", ["DomRange"], function (api, module) {
        var WrappedRange, WrappedTextRange;
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api.DomRange;
        var getBody = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;
        if (api.features.implementsDomRange) {
            (function () {
                var rangeProto;
                var rangeProperties = DomRange.rangeProperties;
                function updateRangeProperties(range) {
                    var i = rangeProperties.length, prop;
                    while (i--) {
                        prop = rangeProperties[i];
                        range[prop] = range.nativeRange[prop];
                    }
                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
                }
                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
                    var nativeRangeDifferent = !range.equals(range.nativeRange);
                    if (startMoved || endMoved || nativeRangeDifferent) {
                        range.setEnd(endContainer, endOffset);
                        range.setStart(startContainer, startOffset);
                    }
                }
                var createBeforeAfterNodeSetter;
                WrappedRange = function (range) {
                    if (!range) {
                        throw module.createError("WrappedRange: Range must be specified");
                    }
                    this.nativeRange = range;
                    updateRangeProperties(this);
                };
                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);
                rangeProto = WrappedRange.prototype;
                rangeProto.selectNode = function (node) {
                    this.nativeRange.selectNode(node);
                    updateRangeProperties(this);
                };
                rangeProto.cloneContents = function () {
                    return this.nativeRange.cloneContents();
                };
                rangeProto.surroundContents = function (node) {
                    this.nativeRange.surroundContents(node);
                    updateRangeProperties(this);
                };
                rangeProto.collapse = function (isStart) {
                    this.nativeRange.collapse(isStart);
                    updateRangeProperties(this);
                };
                rangeProto.cloneRange = function () {
                    return new WrappedRange(this.nativeRange.cloneRange());
                };
                rangeProto.refresh = function () {
                    updateRangeProperties(this);
                };
                rangeProto.toString = function () {
                    return this.nativeRange.toString();
                };
                var testTextNode = document.createTextNode("test");
                getBody(document).appendChild(testTextNode);
                var range = document.createRange();
                range.setStart(testTextNode, 0);
                range.setEnd(testTextNode, 0);
                try {
                    range.setStart(testTextNode, 1);
                    rangeProto.setStart = function (node, offset) {
                        this.nativeRange.setStart(node, offset);
                        updateRangeProperties(this);
                    };
                    rangeProto.setEnd = function (node, offset) {
                        this.nativeRange.setEnd(node, offset);
                        updateRangeProperties(this);
                    };
                    createBeforeAfterNodeSetter = function (name) {
                        return function (node) {
                            this.nativeRange[name](node);
                            updateRangeProperties(this);
                        };
                    };
                }
                catch (ex) {
                    rangeProto.setStart = function (node, offset) {
                        try {
                            this.nativeRange.setStart(node, offset);
                        }
                        catch (ex) {
                            this.nativeRange.setEnd(node, offset);
                            this.nativeRange.setStart(node, offset);
                        }
                        updateRangeProperties(this);
                    };
                    rangeProto.setEnd = function (node, offset) {
                        try {
                            this.nativeRange.setEnd(node, offset);
                        }
                        catch (ex) {
                            this.nativeRange.setStart(node, offset);
                            this.nativeRange.setEnd(node, offset);
                        }
                        updateRangeProperties(this);
                    };
                    createBeforeAfterNodeSetter = function (name, oppositeName) {
                        return function (node) {
                            try {
                                this.nativeRange[name](node);
                            }
                            catch (ex) {
                                this.nativeRange[oppositeName](node);
                                this.nativeRange[name](node);
                            }
                            updateRangeProperties(this);
                        };
                    };
                }
                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");
                rangeProto.selectNodeContents = function (node) {
                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));
                };
                range.selectNodeContents(testTextNode);
                range.setEnd(testTextNode, 3);
                var range2 = document.createRange();
                range2.selectNodeContents(testTextNode);
                range2.setEnd(testTextNode, 4);
                range2.setStart(testTextNode, 2);
                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
                    range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
                    rangeProto.compareBoundaryPoints = function (type, range) {
                        range = range.nativeRange || range;
                        if (type == range.START_TO_END) {
                            type = range.END_TO_START;
                        }
                        else if (type == range.END_TO_START) {
                            type = range.START_TO_END;
                        }
                        return this.nativeRange.compareBoundaryPoints(type, range);
                    };
                }
                else {
                    rangeProto.compareBoundaryPoints = function (type, range) {
                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
                    };
                }
                var el = document.createElement("div");
                el.innerHTML = "123";
                var textNode = el.firstChild;
                var body = getBody(document);
                body.appendChild(el);
                range.setStart(textNode, 1);
                range.setEnd(textNode, 2);
                range.deleteContents();
                if (textNode.data == "13") {
                    rangeProto.deleteContents = function () {
                        this.nativeRange.deleteContents();
                        updateRangeProperties(this);
                    };
                    rangeProto.extractContents = function () {
                        var frag = this.nativeRange.extractContents();
                        updateRangeProperties(this);
                        return frag;
                    };
                }
                else {
                }
                body.removeChild(el);
                body = null;
                if (util.isHostMethod(range, "createContextualFragment")) {
                    rangeProto.createContextualFragment = function (fragmentStr) {
                        return this.nativeRange.createContextualFragment(fragmentStr);
                    };
                }
                getBody(document).removeChild(testTextNode);
                rangeProto.getName = function () {
                    return "WrappedRange";
                };
                api.WrappedRange = WrappedRange;
                api.createNativeRange = function (doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return doc.createRange();
                };
            })();
        }
        if (api.features.implementsTextRange) {
            var getTextRangeContainerElement = function (textRange) {
                var parentEl = textRange.parentElement();
                var range = textRange.duplicate();
                range.collapse(true);
                var startEl = range.parentElement();
                range = textRange.duplicate();
                range.collapse(false);
                var endEl = range.parentElement();
                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);
                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
            };
            var textRangeIsCollapsed = function (textRange) {
                return textRange.compareEndPoints("StartToEnd", textRange) == 0;
            };
            var getTextRangeBoundaryPosition = function (textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
                var workingRange = textRange.duplicate();
                workingRange.collapse(isStart);
                var containerElement = workingRange.parentElement();
                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
                    containerElement = wholeRangeContainerElement;
                }
                if (!containerElement.canHaveHTML) {
                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
                    return {
                        boundaryPosition: pos,
                        nodeInfo: {
                            nodeIndex: pos.offset,
                            containerElement: pos.node
                        }
                    };
                }
                var workingNode = dom.getDocument(containerElement).createElement("span");
                if (workingNode.parentNode) {
                    dom.removeNode(workingNode);
                }
                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
                var previousNode, nextNode, boundaryPosition, boundaryNode;
                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
                var childNodeCount = containerElement.childNodes.length;
                var end = childNodeCount;
                var nodeIndex = end;
                while (true) {
                    if (nodeIndex == childNodeCount) {
                        containerElement.appendChild(workingNode);
                    }
                    else {
                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
                    }
                    workingRange.moveToElementText(workingNode);
                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
                    if (comparison == 0 || start == end) {
                        break;
                    }
                    else if (comparison == -1) {
                        if (end == start + 1) {
                            break;
                        }
                        else {
                            start = nodeIndex;
                        }
                    }
                    else {
                        end = (end == start + 1) ? start : nodeIndex;
                    }
                    nodeIndex = Math.floor((start + end) / 2);
                    containerElement.removeChild(workingNode);
                }
                boundaryNode = workingNode.nextSibling;
                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);
                    var offset;
                    if (/[\r\n]/.test(boundaryNode.data)) {
                        var tempRange = workingRange.duplicate();
                        var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;
                        offset = tempRange.moveStart("character", rangeLength);
                        while ((comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                            offset++;
                            tempRange.moveStart("character", 1);
                        }
                    }
                    else {
                        offset = workingRange.text.length;
                    }
                    boundaryPosition = new DomPosition(boundaryNode, offset);
                }
                else {
                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
                    if (nextNode && isCharacterDataNode(nextNode)) {
                        boundaryPosition = new DomPosition(nextNode, 0);
                    }
                    else if (previousNode && isCharacterDataNode(previousNode)) {
                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
                    }
                    else {
                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
                    }
                }
                dom.removeNode(workingNode);
                return {
                    boundaryPosition: boundaryPosition,
                    nodeInfo: {
                        nodeIndex: nodeIndex,
                        containerElement: containerElement
                    }
                };
            };
            var createBoundaryTextRange = function (boundaryPosition, isStart) {
                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
                var doc = dom.getDocument(boundaryPosition.node);
                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);
                if (nodeIsDataNode) {
                    boundaryNode = boundaryPosition.node;
                    boundaryParent = boundaryNode.parentNode;
                }
                else {
                    childNodes = boundaryPosition.node.childNodes;
                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
                    boundaryParent = boundaryPosition.node;
                }
                workingNode = doc.createElement("span");
                workingNode.innerHTML = "&#feff;";
                if (boundaryNode) {
                    boundaryParent.insertBefore(workingNode, boundaryNode);
                }
                else {
                    boundaryParent.appendChild(workingNode);
                }
                workingRange.moveToElementText(workingNode);
                workingRange.collapse(!isStart);
                boundaryParent.removeChild(workingNode);
                if (nodeIsDataNode) {
                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
                }
                return workingRange;
            };
            WrappedTextRange = function (textRange) {
                this.textRange = textRange;
                this.refresh();
            };
            WrappedTextRange.prototype = new DomRange(document);
            WrappedTextRange.prototype.refresh = function () {
                var start, end, startBoundary;
                var rangeContainerElement = getTextRangeContainerElement(this.textRange);
                if (textRangeIsCollapsed(this.textRange)) {
                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true).boundaryPosition;
                }
                else {
                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
                    start = startBoundary.boundaryPosition;
                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false, startBoundary.nodeInfo).boundaryPosition;
                }
                this.setStart(start.node, start.offset);
                this.setEnd(end.node, end.offset);
            };
            WrappedTextRange.prototype.getName = function () {
                return "WrappedTextRange";
            };
            DomRange.copyComparisonConstants(WrappedTextRange);
            var rangeToTextRange = function (range) {
                if (range.collapsed) {
                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                }
                else {
                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
                    var textRange = getBody(DomRange.getRangeDocument(range)).createTextRange();
                    textRange.setEndPoint("StartToStart", startRange);
                    textRange.setEndPoint("EndToEnd", endRange);
                    return textRange;
                }
            };
            WrappedTextRange.rangeToTextRange = rangeToTextRange;
            WrappedTextRange.prototype.toTextRange = function () {
                return rangeToTextRange(this);
            };
            api.WrappedTextRange = WrappedTextRange;
            if (!api.features.implementsDomRange || api.config.preferTextRange) {
                var globalObj = (function (f) { return f("return this;")(); })(Function);
                if (typeof globalObj.Range == "undefined") {
                    globalObj.Range = WrappedTextRange;
                }
                api.createNativeRange = function (doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return getBody(doc).createTextRange();
                };
                api.WrappedRange = WrappedTextRange;
            }
        }
        api.createRange = function (doc) {
            doc = getContentDocument(doc, module, "createRange");
            return new api.WrappedRange(api.createNativeRange(doc));
        };
        api.createRangyRange = function (doc) {
            doc = getContentDocument(doc, module, "createRangyRange");
            return new DomRange(doc);
        };
        util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");
        util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");
        api.addShimListener(function (win) {
            var doc = win.document;
            if (typeof doc.createRange == "undefined") {
                doc.createRange = function () {
                    return api.createRange(doc);
                };
            }
            doc = win = null;
        });
    });
    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function (api, module) {
        api.config.checkSelectionRanges = true;
        var BOOLEAN = "boolean";
        var NUMBER = "number";
        var dom = api.dom;
        var util = api.util;
        var isHostMethod = util.isHostMethod;
        var DomRange = api.DomRange;
        var WrappedRange = api.WrappedRange;
        var DOMException = api.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api.features;
        var CONTROL = "Control";
        var getDocument = dom.getDocument;
        var getBody = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;
        function isDirectionBackward(dir) {
            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
        }
        function getWindow(win, methodName) {
            if (!win) {
                return window;
            }
            else if (dom.isWindow(win)) {
                return win;
            }
            else if (win instanceof WrappedSelection) {
                return win.win;
            }
            else {
                var doc = dom.getContentDocument(win, module, methodName);
                return dom.getWindow(doc);
            }
        }
        function getWinSelection(winParam) {
            return getWindow(winParam, "getWinSelection").getSelection();
        }
        function getDocSelection(winParam) {
            return getWindow(winParam, "getDocSelection").document.selection;
        }
        function winSelectionIsBackward(sel) {
            var backward = false;
            if (sel.anchorNode) {
                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
            }
            return backward;
        }
        var implementsWinGetSelection = isHostMethod(window, "getSelection"), implementsDocSelection = util.isHostObject(document, "selection");
        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;
        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);
        if (useDocumentSelection) {
            getNativeSelection = getDocSelection;
            api.isSelectionValid = function (winParam) {
                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;
                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
            };
        }
        else if (implementsWinGetSelection) {
            getNativeSelection = getWinSelection;
            api.isSelectionValid = function () {
                return true;
            };
        }
        else {
            module.fail("Neither document.selection or window.getSelection() detected.");
            return false;
        }
        api.getNativeSelection = getNativeSelection;
        var testSelection = getNativeSelection();
        if (!testSelection) {
            module.fail("Native selection was null (possibly issue 138?)");
            return false;
        }
        var testRange = api.createNativeRange(document);
        var body = getBody(document);
        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection, ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);
        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;
        var selectionHasExtend = isHostMethod(testSelection, "extend");
        features.selectionHasExtend = selectionHasExtend;
        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
        features.selectionHasRangeCount = selectionHasRangeCount;
        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;
        var addRangeBackwardToNative = selectionHasExtend ?
            function (nativeSelection, range) {
                var doc = DomRange.getRangeDocument(range);
                var endRange = api.createRange(doc);
                endRange.collapseToPoint(range.endContainer, range.endOffset);
                nativeSelection.addRange(getNativeRange(endRange));
                nativeSelection.extend(range.startContainer, range.startOffset);
            } : null;
        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
            typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {
            (function () {
                var sel = window.getSelection();
                if (sel) {
                    var originalSelectionRangeCount = sel.rangeCount;
                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
                    var originalSelectionRanges = [];
                    var originalSelectionBackward = winSelectionIsBackward(sel);
                    for (var i = 0; i < originalSelectionRangeCount; ++i) {
                        originalSelectionRanges[i] = sel.getRangeAt(i);
                    }
                    var testEl = dom.createTestElement(document, "", false);
                    var textNode = testEl.appendChild(document.createTextNode("\u00a0\u00a0\u00a0"));
                    var r1 = document.createRange();
                    r1.setStart(textNode, 1);
                    r1.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(r1);
                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
                    sel.removeAllRanges();
                    if (!selectionHasMultipleRanges) {
                        var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                            selectionSupportsMultipleRanges = false;
                        }
                        else {
                            var r2 = r1.cloneRange();
                            r1.setStart(textNode, 0);
                            r2.setEnd(textNode, 3);
                            r2.setStart(textNode, 2);
                            sel.addRange(r1);
                            sel.addRange(r2);
                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);
                        }
                    }
                    dom.removeNode(testEl);
                    sel.removeAllRanges();
                    for (i = 0; i < originalSelectionRangeCount; ++i) {
                        if (i == 0 && originalSelectionBackward) {
                            if (addRangeBackwardToNative) {
                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                            }
                            else {
                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                                sel.addRange(originalSelectionRanges[i]);
                            }
                        }
                        else {
                            sel.addRange(originalSelectionRanges[i]);
                        }
                    }
                }
            })();
        }
        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;
        var implementsControlRange = false, testControlRange;
        if (body && isHostMethod(body, "createControlRange")) {
            testControlRange = body.createControlRange();
            if (util.areHostProperties(testControlRange, ["item", "add"])) {
                implementsControlRange = true;
            }
        }
        features.implementsControlRange = implementsControlRange;
        if (selectionHasAnchorAndFocus) {
            selectionIsCollapsed = function (sel) {
                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
            };
        }
        else {
            selectionIsCollapsed = function (sel) {
                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
            };
        }
        function updateAnchorAndFocusFromRange(sel, range, backward) {
            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
            sel.anchorNode = range[anchorPrefix + "Container"];
            sel.anchorOffset = range[anchorPrefix + "Offset"];
            sel.focusNode = range[focusPrefix + "Container"];
            sel.focusOffset = range[focusPrefix + "Offset"];
        }
        function updateAnchorAndFocusFromNativeSelection(sel) {
            var nativeSel = sel.nativeSelection;
            sel.anchorNode = nativeSel.anchorNode;
            sel.anchorOffset = nativeSel.anchorOffset;
            sel.focusNode = nativeSel.focusNode;
            sel.focusOffset = nativeSel.focusOffset;
        }
        function updateEmptySelection(sel) {
            sel.anchorNode = sel.focusNode = null;
            sel.anchorOffset = sel.focusOffset = 0;
            sel.rangeCount = 0;
            sel.isCollapsed = true;
            sel._ranges.length = 0;
        }
        function getNativeRange(range) {
            var nativeRange;
            if (range instanceof DomRange) {
                nativeRange = api.createNativeRange(range.getDocument());
                nativeRange.setEnd(range.endContainer, range.endOffset);
                nativeRange.setStart(range.startContainer, range.startOffset);
            }
            else if (range instanceof WrappedRange) {
                nativeRange = range.nativeRange;
            }
            else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
                nativeRange = range;
            }
            return nativeRange;
        }
        function rangeContainsSingleElement(rangeNodes) {
            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
                return false;
            }
            for (var i = 1, len = rangeNodes.length; i < len; ++i) {
                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
                    return false;
                }
            }
            return true;
        }
        function getSingleElementFromRange(range) {
            var nodes = range.getNodes();
            if (!rangeContainsSingleElement(nodes)) {
                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
            }
            return nodes[0];
        }
        function isTextRange(range) {
            return !!range && typeof range.text != "undefined";
        }
        function updateFromTextRange(sel, range) {
            var wrappedRange = new WrappedRange(range);
            sel._ranges = [wrappedRange];
            updateAnchorAndFocusFromRange(sel, wrappedRange, false);
            sel.rangeCount = 1;
            sel.isCollapsed = wrappedRange.collapsed;
        }
        function updateControlSelection(sel) {
            sel._ranges.length = 0;
            if (sel.docSelection.type == "None") {
                updateEmptySelection(sel);
            }
            else {
                var controlRange = sel.docSelection.createRange();
                if (isTextRange(controlRange)) {
                    updateFromTextRange(sel, controlRange);
                }
                else {
                    sel.rangeCount = controlRange.length;
                    var range, doc = getDocument(controlRange.item(0));
                    for (var i = 0; i < sel.rangeCount; ++i) {
                        range = api.createRange(doc);
                        range.selectNode(controlRange.item(i));
                        sel._ranges.push(range);
                    }
                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
                }
            }
        }
        function addRangeToControlSelection(sel, range) {
            var controlRange = sel.docSelection.createRange();
            var rangeElement = getSingleElementFromRange(range);
            var doc = getDocument(controlRange.item(0));
            var newControlRange = getBody(doc).createControlRange();
            for (var i = 0, len = controlRange.length; i < len; ++i) {
                newControlRange.add(controlRange.item(i));
            }
            try {
                newControlRange.add(rangeElement);
            }
            catch (ex) {
                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
            }
            newControlRange.select();
            updateControlSelection(sel);
        }
        var getSelectionRangeAt;
        if (isHostMethod(testSelection, "getRangeAt")) {
            getSelectionRangeAt = function (sel, index) {
                try {
                    return sel.getRangeAt(index);
                }
                catch (ex) {
                    return null;
                }
            };
        }
        else if (selectionHasAnchorAndFocus) {
            getSelectionRangeAt = function (sel) {
                var doc = getDocument(sel.anchorNode);
                var range = api.createRange(doc);
                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);
                if (range.collapsed !== this.isCollapsed) {
                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
                }
                return range;
            };
        }
        function WrappedSelection(selection, docSelection, win) {
            this.nativeSelection = selection;
            this.docSelection = docSelection;
            this._ranges = [];
            this.win = win;
            this.refresh();
        }
        WrappedSelection.prototype = api.selectionPrototype;
        function deleteProperties(sel) {
            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
            sel.detached = true;
        }
        var cachedRangySelections = [];
        function actOnCachedSelection(win, action) {
            var i = cachedRangySelections.length, cached, sel;
            while (i--) {
                cached = cachedRangySelections[i];
                sel = cached.selection;
                if (action == "deleteAll") {
                    deleteProperties(sel);
                }
                else if (cached.win == win) {
                    if (action == "delete") {
                        cachedRangySelections.splice(i, 1);
                        return true;
                    }
                    else {
                        return sel;
                    }
                }
            }
            if (action == "deleteAll") {
                cachedRangySelections.length = 0;
            }
            return null;
        }
        var getSelection = function (win) {
            if (win && win instanceof WrappedSelection) {
                win.refresh();
                return win;
            }
            win = getWindow(win, "getNativeSelection");
            var sel = actOnCachedSelection(win);
            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
            if (sel) {
                sel.nativeSelection = nativeSel;
                sel.docSelection = docSel;
                sel.refresh();
            }
            else {
                sel = new WrappedSelection(nativeSel, docSel, win);
                cachedRangySelections.push({ win: win, selection: sel });
            }
            return sel;
        };
        api.getSelection = getSelection;
        util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");
        var selProto = WrappedSelection.prototype;
        function createControlSelection(sel, ranges) {
            var doc = getDocument(ranges[0].startContainer);
            var controlRange = getBody(doc).createControlRange();
            for (var i = 0, el, len = ranges.length; i < len; ++i) {
                el = getSingleElementFromRange(ranges[i]);
                try {
                    controlRange.add(el);
                }
                catch (ex) {
                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
                }
            }
            controlRange.select();
            updateControlSelection(sel);
        }
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
            selProto.removeAllRanges = function () {
                this.nativeSelection.removeAllRanges();
                updateEmptySelection(this);
            };
            var addRangeBackward = function (sel, range) {
                addRangeBackwardToNative(sel.nativeSelection, range);
                sel.refresh();
            };
            if (selectionHasRangeCount) {
                selProto.addRange = function (range, direction) {
                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                        addRangeToControlSelection(this, range);
                    }
                    else {
                        if (isDirectionBackward(direction) && selectionHasExtend) {
                            addRangeBackward(this, range);
                        }
                        else {
                            var previousRangeCount;
                            if (selectionSupportsMultipleRanges) {
                                previousRangeCount = this.rangeCount;
                            }
                            else {
                                this.removeAllRanges();
                                previousRangeCount = 0;
                            }
                            var clonedNativeRange = getNativeRange(range).cloneRange();
                            try {
                                this.nativeSelection.addRange(clonedNativeRange);
                            }
                            catch (ex) {
                            }
                            this.rangeCount = this.nativeSelection.rangeCount;
                            if (this.rangeCount == previousRangeCount + 1) {
                                if (api.config.checkSelectionRanges) {
                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                                    if (nativeRange && !rangesEqual(nativeRange, range)) {
                                        range = new WrappedRange(nativeRange);
                                    }
                                }
                                this._ranges[this.rangeCount - 1] = range;
                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                                this.isCollapsed = selectionIsCollapsed(this);
                            }
                            else {
                                this.refresh();
                            }
                        }
                    }
                };
            }
            else {
                selProto.addRange = function (range, direction) {
                    if (isDirectionBackward(direction) && selectionHasExtend) {
                        addRangeBackward(this, range);
                    }
                    else {
                        this.nativeSelection.addRange(getNativeRange(range));
                        this.refresh();
                    }
                };
            }
            selProto.setRanges = function (ranges) {
                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
                    createControlSelection(this, ranges);
                }
                else {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        this.addRange(ranges[i]);
                    }
                }
            };
        }
        else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
            implementsControlRange && useDocumentSelection) {
            selProto.removeAllRanges = function () {
                try {
                    this.docSelection.empty();
                    if (this.docSelection.type != "None") {
                        var doc;
                        if (this.anchorNode) {
                            doc = getDocument(this.anchorNode);
                        }
                        else if (this.docSelection.type == CONTROL) {
                            var controlRange = this.docSelection.createRange();
                            if (controlRange.length) {
                                doc = getDocument(controlRange.item(0));
                            }
                        }
                        if (doc) {
                            var textRange = getBody(doc).createTextRange();
                            textRange.select();
                            this.docSelection.empty();
                        }
                    }
                }
                catch (ex) { }
                updateEmptySelection(this);
            };
            selProto.addRange = function (range) {
                if (this.docSelection.type == CONTROL) {
                    addRangeToControlSelection(this, range);
                }
                else {
                    api.WrappedTextRange.rangeToTextRange(range).select();
                    this._ranges[0] = range;
                    this.rangeCount = 1;
                    this.isCollapsed = this._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(this, range, false);
                }
            };
            selProto.setRanges = function (ranges) {
                this.removeAllRanges();
                var rangeCount = ranges.length;
                if (rangeCount > 1) {
                    createControlSelection(this, ranges);
                }
                else if (rangeCount) {
                    this.addRange(ranges[0]);
                }
            };
        }
        else {
            module.fail("No means of selecting a Range or TextRange was found");
            return false;
        }
        selProto.getRangeAt = function (index) {
            if (index < 0 || index >= this.rangeCount) {
                throw new DOMException("INDEX_SIZE_ERR");
            }
            else {
                return this._ranges[index].cloneRange();
            }
        };
        var refreshSelection;
        if (useDocumentSelection) {
            refreshSelection = function (sel) {
                var range;
                if (api.isSelectionValid(sel.win)) {
                    range = sel.docSelection.createRange();
                }
                else {
                    range = getBody(sel.win.document).createTextRange();
                    range.collapse(true);
                }
                if (sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                }
                else if (isTextRange(range)) {
                    updateFromTextRange(sel, range);
                }
                else {
                    updateEmptySelection(sel);
                }
            };
        }
        else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
            refreshSelection = function (sel) {
                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                }
                else {
                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
                    if (sel.rangeCount) {
                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                        }
                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                        sel.isCollapsed = selectionIsCollapsed(sel);
                    }
                    else {
                        updateEmptySelection(sel);
                    }
                }
            };
        }
        else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
            refreshSelection = function (sel) {
                var range, nativeSel = sel.nativeSelection;
                if (nativeSel.anchorNode) {
                    range = getSelectionRangeAt(nativeSel, 0);
                    sel._ranges = [range];
                    sel.rangeCount = 1;
                    updateAnchorAndFocusFromNativeSelection(sel);
                    sel.isCollapsed = selectionIsCollapsed(sel);
                }
                else {
                    updateEmptySelection(sel);
                }
            };
        }
        else {
            module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
            return false;
        }
        selProto.refresh = function (checkForChanges) {
            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;
            refreshSelection(this);
            if (checkForChanges) {
                var i = oldRanges.length;
                if (i != this._ranges.length) {
                    return true;
                }
                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
                    return true;
                }
                while (i--) {
                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                        return true;
                    }
                }
                return false;
            }
        };
        var removeRangeManually = function (sel, range) {
            var ranges = sel.getAllRanges();
            sel.removeAllRanges();
            for (var i = 0, len = ranges.length; i < len; ++i) {
                if (!rangesEqual(range, ranges[i])) {
                    sel.addRange(ranges[i]);
                }
            }
            if (!sel.rangeCount) {
                updateEmptySelection(sel);
            }
        };
        if (implementsControlRange && implementsDocSelection) {
            selProto.removeRange = function (range) {
                if (this.docSelection.type == CONTROL) {
                    var controlRange = this.docSelection.createRange();
                    var rangeElement = getSingleElementFromRange(range);
                    var doc = getDocument(controlRange.item(0));
                    var newControlRange = getBody(doc).createControlRange();
                    var el, removed = false;
                    for (var i = 0, len = controlRange.length; i < len; ++i) {
                        el = controlRange.item(i);
                        if (el !== rangeElement || removed) {
                            newControlRange.add(controlRange.item(i));
                        }
                        else {
                            removed = true;
                        }
                    }
                    newControlRange.select();
                    updateControlSelection(this);
                }
                else {
                    removeRangeManually(this, range);
                }
            };
        }
        else {
            selProto.removeRange = function (range) {
                removeRangeManually(this, range);
            };
        }
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
            selectionIsBackward = winSelectionIsBackward;
            selProto.isBackward = function () {
                return selectionIsBackward(this);
            };
        }
        else {
            selectionIsBackward = selProto.isBackward = function () {
                return false;
            };
        }
        selProto.isBackwards = selProto.isBackward;
        selProto.toString = function () {
            var rangeTexts = [];
            for (var i = 0, len = this.rangeCount; i < len; ++i) {
                rangeTexts[i] = "" + this._ranges[i];
            }
            return rangeTexts.join("");
        };
        function assertNodeInSameDocument(sel, node) {
            if (sel.win.document != getDocument(node)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }
        selProto.collapse = function (node, offset) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.collapseToPoint(node, offset);
            this.setSingleRange(range);
            this.isCollapsed = true;
        };
        selProto.collapseToStart = function () {
            if (this.rangeCount) {
                var range = this._ranges[0];
                this.collapse(range.startContainer, range.startOffset);
            }
            else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };
        selProto.collapseToEnd = function () {
            if (this.rangeCount) {
                var range = this._ranges[this.rangeCount - 1];
                this.collapse(range.endContainer, range.endOffset);
            }
            else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };
        selProto.selectAllChildren = function (node) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.selectNodeContents(node);
            this.setSingleRange(range);
        };
        selProto.deleteFromDocument = function () {
            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                var element;
                while (controlRange.length) {
                    element = controlRange.item(0);
                    controlRange.remove(element);
                    dom.removeNode(element);
                }
                this.refresh();
            }
            else if (this.rangeCount) {
                var ranges = this.getAllRanges();
                if (ranges.length) {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        ranges[i].deleteContents();
                    }
                    this.addRange(ranges[len - 1]);
                }
            }
        };
        selProto.eachRange = function (func, returnValue) {
            for (var i = 0, len = this._ranges.length; i < len; ++i) {
                if (func(this.getRangeAt(i))) {
                    return returnValue;
                }
            }
        };
        selProto.getAllRanges = function () {
            var ranges = [];
            this.eachRange(function (range) {
                ranges.push(range);
            });
            return ranges;
        };
        selProto.setSingleRange = function (range, direction) {
            this.removeAllRanges();
            this.addRange(range, direction);
        };
        selProto.callMethodOnEachRange = function (methodName, params) {
            var results = [];
            this.eachRange(function (range) {
                results.push(range[methodName].apply(range, params || []));
            });
            return results;
        };
        function createStartOrEndSetter(isStart) {
            return function (node, offset) {
                var range;
                if (this.rangeCount) {
                    range = this.getRangeAt(0);
                    range["set" + (isStart ? "Start" : "End")](node, offset);
                }
                else {
                    range = api.createRange(this.win.document);
                    range.setStartAndEnd(node, offset);
                }
                this.setSingleRange(range, this.isBackward());
            };
        }
        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);
        api.rangePrototype.select = function (direction) {
            getSelection(this.getDocument()).setSingleRange(this, direction);
        };
        selProto.changeEachRange = function (func) {
            var ranges = [];
            var backward = this.isBackward();
            this.eachRange(function (range) {
                func(range);
                ranges.push(range);
            });
            this.removeAllRanges();
            if (backward && ranges.length == 1) {
                this.addRange(ranges[0], "backward");
            }
            else {
                this.setRanges(ranges);
            }
        };
        selProto.containsNode = function (node, allowPartial) {
            return this.eachRange(function (range) {
                return range.containsNode(node, allowPartial);
            }, true) || false;
        };
        selProto.getBookmark = function (containerNode) {
            return {
                backward: this.isBackward(),
                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
            };
        };
        selProto.moveToBookmark = function (bookmark) {
            var selRanges = [];
            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++];) {
                range = api.createRange(this.win);
                range.moveToBookmark(rangeBookmark);
                selRanges.push(range);
            }
            if (bookmark.backward) {
                this.setSingleRange(selRanges[0], "backward");
            }
            else {
                this.setRanges(selRanges);
            }
        };
        selProto.saveRanges = function () {
            return {
                backward: this.isBackward(),
                ranges: this.callMethodOnEachRange("cloneRange")
            };
        };
        selProto.restoreRanges = function (selRanges) {
            this.removeAllRanges();
            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
                this.addRange(range, (selRanges.backward && i == 0));
            }
        };
        selProto.toHtml = function () {
            var rangeHtmls = [];
            this.eachRange(function (range) {
                rangeHtmls.push(DomRange.toHtml(range));
            });
            return rangeHtmls.join("");
        };
        if (features.implementsTextRange) {
            selProto.getNativeTextRange = function () {
                var sel, textRange;
                if ((sel = this.docSelection)) {
                    var range = sel.createRange();
                    if (isTextRange(range)) {
                        return range;
                    }
                    else {
                        throw module.createError("getNativeTextRange: selection is a control selection");
                    }
                }
                else if (this.rangeCount > 0) {
                    return api.WrappedTextRange.rangeToTextRange(this.getRangeAt(0));
                }
                else {
                    throw module.createError("getNativeTextRange: selection contains no range");
                }
            };
        }
        function inspect(sel) {
            var rangeInspects = [];
            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
            var focus = new DomPosition(sel.focusNode, sel.focusOffset);
            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";
            if (typeof sel.rangeCount != "undefined") {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
                }
            }
            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
                ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
        }
        selProto.getName = function () {
            return "WrappedSelection";
        };
        selProto.inspect = function () {
            return inspect(this);
        };
        selProto.detach = function () {
            actOnCachedSelection(this.win, "delete");
            deleteProperties(this);
        };
        WrappedSelection.detachAll = function () {
            actOnCachedSelection(null, "deleteAll");
        };
        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;
        api.Selection = WrappedSelection;
        api.selectionPrototype = selProto;
        api.addShimListener(function (win) {
            if (typeof win.getSelection == "undefined") {
                win.getSelection = function () {
                    return getSelection(win);
                };
            }
            win = null;
        });
    });
    var docReady = false;
    var loadHandler = function (e) {
        if (!docReady) {
            docReady = true;
            if (!api.initialized && api.config.autoInitialize) {
                init();
            }
        }
    };
    if (isBrowser) {
        if (document.readyState == "complete") {
            loadHandler();
        }
        else {
            if (isHostMethod(document, "addEventListener")) {
                document.addEventListener("DOMContentLoaded", loadHandler, false);
            }
            addListener(window, "load", loadHandler);
        }
    }
    return api;
}, this);
(function (factory, root) {
    if (typeof define == "function" && define.amd) {
        define(["./rangy-core"], factory);
    }
    else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory(require("rangy"));
    }
    else {
        factory(root.rangy);
    }
})(function (rangy) {
    rangy.createModule("ClassApplier", ["WrappedSelection"], function (api, module) {
        var dom = api.dom;
        var DomPosition = dom.DomPosition;
        var contains = dom.arrayContains;
        var util = api.util;
        var forEach = util.forEach;
        var defaultTagName = "span";
        var createElementNSSupported = util.isHostMethod(document, "createElementNS");
        function each(obj, func) {
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (func(i, obj[i]) === false) {
                        return false;
                    }
                }
            }
            return true;
        }
        function trim(str) {
            return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function classNameContainsClass(fullClassName, className) {
            return !!fullClassName && new RegExp("(?:^|\\s)" + className + "(?:\\s|$)").test(fullClassName);
        }
        function hasClass(el, className) {
            if (typeof el.classList == "object") {
                return el.classList.contains(className);
            }
            else {
                var classNameSupported = (typeof el.className == "string");
                var elClass = classNameSupported ? el.className : el.getAttribute("class");
                return classNameContainsClass(elClass, className);
            }
        }
        function addClass(el, className) {
            if (typeof el.classList == "object") {
                el.classList.add(className);
            }
            else {
                var classNameSupported = (typeof el.className == "string");
                var elClass = classNameSupported ? el.className : el.getAttribute("class");
                if (elClass) {
                    if (!classNameContainsClass(elClass, className)) {
                        elClass += " " + className;
                    }
                }
                else {
                    elClass = className;
                }
                if (classNameSupported) {
                    el.className = elClass;
                }
                else {
                    el.setAttribute("class", elClass);
                }
            }
        }
        var removeClass = (function () {
            function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {
                return (whiteSpaceBefore && whiteSpaceAfter) ? " " : "";
            }
            return function (el, className) {
                if (typeof el.classList == "object") {
                    el.classList.remove(className);
                }
                else {
                    var classNameSupported = (typeof el.className == "string");
                    var elClass = classNameSupported ? el.className : el.getAttribute("class");
                    elClass = elClass.replace(new RegExp("(^|\\s)" + className + "(\\s|$)"), replacer);
                    if (classNameSupported) {
                        el.className = elClass;
                    }
                    else {
                        el.setAttribute("class", elClass);
                    }
                }
            };
        })();
        function getClass(el) {
            var classNameSupported = (typeof el.className == "string");
            return classNameSupported ? el.className : el.getAttribute("class");
        }
        function sortClassName(className) {
            return className && className.split(/\s+/).sort().join(" ");
        }
        function getSortedClassName(el) {
            return sortClassName(getClass(el));
        }
        function haveSameClasses(el1, el2) {
            return getSortedClassName(el1) == getSortedClassName(el2);
        }
        function hasAllClasses(el, className) {
            var classes = className.split(/\s+/);
            for (var i = 0, len = classes.length; i < len; ++i) {
                if (!hasClass(el, trim(classes[i]))) {
                    return false;
                }
            }
            return true;
        }
        function canTextBeStyled(textNode) {
            var parent = textNode.parentNode;
            return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));
        }
        function movePosition(position, oldParent, oldIndex, newParent, newIndex) {
            var posNode = position.node, posOffset = position.offset;
            var newNode = posNode, newOffset = posOffset;
            if (posNode == newParent && posOffset > newIndex) {
                ++newOffset;
            }
            if (posNode == oldParent && (posOffset == oldIndex || posOffset == oldIndex + 1)) {
                newNode = newParent;
                newOffset += newIndex - oldIndex;
            }
            if (posNode == oldParent && posOffset > oldIndex + 1) {
                --newOffset;
            }
            position.node = newNode;
            position.offset = newOffset;
        }
        function movePositionWhenRemovingNode(position, parentNode, index) {
            if (position.node == parentNode && position.offset > index) {
                --position.offset;
            }
        }
        function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {
            if (newIndex == -1) {
                newIndex = newParent.childNodes.length;
            }
            var oldParent = node.parentNode;
            var oldIndex = dom.getNodeIndex(node);
            forEach(positionsToPreserve, function (position) {
                movePosition(position, oldParent, oldIndex, newParent, newIndex);
            });
            if (newParent.childNodes.length == newIndex) {
                newParent.appendChild(node);
            }
            else {
                newParent.insertBefore(node, newParent.childNodes[newIndex]);
            }
        }
        function removePreservingPositions(node, positionsToPreserve) {
            var oldParent = node.parentNode;
            var oldIndex = dom.getNodeIndex(node);
            forEach(positionsToPreserve, function (position) {
                movePositionWhenRemovingNode(position, oldParent, oldIndex);
            });
            dom.removeNode(node);
        }
        function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {
            var child, children = [];
            while ((child = node.firstChild)) {
                movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);
                children.push(child);
            }
            if (removeNode) {
                removePreservingPositions(node, positionsToPreserve);
            }
            return children;
        }
        function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {
            return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);
        }
        function rangeSelectsAnyText(range, textNode) {
            var textNodeRange = range.cloneRange();
            textNodeRange.selectNodeContents(textNode);
            var intersectionRange = textNodeRange.intersection(range);
            var text = intersectionRange ? intersectionRange.toString() : "";
            return text != "";
        }
        function getEffectiveTextNodes(range) {
            var nodes = range.getNodes([3]);
            var start = 0, node;
            while ((node = nodes[start]) && !rangeSelectsAnyText(range, node)) {
                ++start;
            }
            var end = nodes.length - 1;
            while ((node = nodes[end]) && !rangeSelectsAnyText(range, node)) {
                --end;
            }
            return nodes.slice(start, end + 1);
        }
        function elementsHaveSameNonClassAttributes(el1, el2) {
            if (el1.attributes.length != el2.attributes.length)
                return false;
            for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
                attr1 = el1.attributes[i];
                name = attr1.name;
                if (name != "class") {
                    attr2 = el2.attributes.getNamedItem(name);
                    if ((attr1 === null) != (attr2 === null))
                        return false;
                    if (attr1.specified != attr2.specified)
                        return false;
                    if (attr1.specified && attr1.nodeValue !== attr2.nodeValue)
                        return false;
                }
            }
            return true;
        }
        function elementHasNonClassAttributes(el, exceptions) {
            for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {
                attrName = el.attributes[i].name;
                if (!(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != "class") {
                    return true;
                }
            }
            return false;
        }
        var getComputedStyleProperty = dom.getComputedStyleProperty;
        var isEditableElement = (function () {
            var testEl = document.createElement("div");
            return typeof testEl.isContentEditable == "boolean" ?
                function (node) {
                    return node && node.nodeType == 1 && node.isContentEditable;
                } :
                function (node) {
                    if (!node || node.nodeType != 1 || node.contentEditable == "false") {
                        return false;
                    }
                    return node.contentEditable == "true" || isEditableElement(node.parentNode);
                };
        })();
        function isEditingHost(node) {
            var parent;
            return node && node.nodeType == 1 &&
                (((parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == "on") ||
                    (isEditableElement(node) && !isEditableElement(node.parentNode)));
        }
        function isEditable(node) {
            return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);
        }
        var inlineDisplayRegex = /^inline(-block|-table)?$/i;
        function isNonInlineElement(node) {
            return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, "display"));
        }
        var htmlNonWhiteSpaceRegex = /[^\r\n\t\f \u200B]/;
        function isUnrenderedWhiteSpaceNode(node) {
            if (node.data.length == 0) {
                return true;
            }
            if (htmlNonWhiteSpaceRegex.test(node.data)) {
                return false;
            }
            var cssWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");
            switch (cssWhiteSpace) {
                case "pre":
                case "pre-wrap":
                case "-moz-pre-wrap":
                    return false;
                case "pre-line":
                    if (/[\r\n]/.test(node.data)) {
                        return false;
                    }
            }
            return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);
        }
        function getRangeBoundaries(ranges) {
            var positions = [], i, range;
            for (i = 0; range = ranges[i++];) {
                positions.push(new DomPosition(range.startContainer, range.startOffset), new DomPosition(range.endContainer, range.endOffset));
            }
            return positions;
        }
        function updateRangesFromBoundaries(ranges, positions) {
            for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {
                range = ranges[i];
                start = positions[i * 2];
                end = positions[i * 2 + 1];
                range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
            }
        }
        function isSplitPoint(node, offset) {
            if (dom.isCharacterDataNode(node)) {
                if (offset == 0) {
                    return !!node.previousSibling;
                }
                else if (offset == node.length) {
                    return !!node.nextSibling;
                }
                else {
                    return true;
                }
            }
            return offset > 0 && offset < node.childNodes.length;
        }
        function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {
            var newNode, parentNode;
            var splitAtStart = (descendantOffset == 0);
            if (dom.isAncestorOf(descendantNode, node)) {
                return node;
            }
            if (dom.isCharacterDataNode(descendantNode)) {
                var descendantIndex = dom.getNodeIndex(descendantNode);
                if (descendantOffset == 0) {
                    descendantOffset = descendantIndex;
                }
                else if (descendantOffset == descendantNode.length) {
                    descendantOffset = descendantIndex + 1;
                }
                else {
                    throw module.createError("splitNodeAt() should not be called with offset in the middle of a data node (" +
                        descendantOffset + " in " + descendantNode.data);
                }
                descendantNode = descendantNode.parentNode;
            }
            if (isSplitPoint(descendantNode, descendantOffset)) {
                newNode = descendantNode.cloneNode(false);
                parentNode = descendantNode.parentNode;
                if (newNode.id) {
                    newNode.removeAttribute("id");
                }
                var child, newChildIndex = 0;
                while ((child = descendantNode.childNodes[descendantOffset])) {
                    movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);
                }
                movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);
                return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);
            }
            else if (node != descendantNode) {
                newNode = descendantNode.parentNode;
                var newNodeIndex = dom.getNodeIndex(descendantNode);
                if (!splitAtStart) {
                    newNodeIndex++;
                }
                return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);
            }
            return node;
        }
        function areElementsMergeable(el1, el2) {
            return el1.namespaceURI == el2.namespaceURI &&
                el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&
                haveSameClasses(el1, el2) &&
                elementsHaveSameNonClassAttributes(el1, el2) &&
                getComputedStyleProperty(el1, "display") == "inline" &&
                getComputedStyleProperty(el2, "display") == "inline";
        }
        function createAdjacentMergeableTextNodeGetter(forward) {
            var siblingPropName = forward ? "nextSibling" : "previousSibling";
            return function (textNode, checkParentElement) {
                var el = textNode.parentNode;
                var adjacentNode = textNode[siblingPropName];
                if (adjacentNode) {
                    if (adjacentNode && adjacentNode.nodeType == 3) {
                        return adjacentNode;
                    }
                }
                else if (checkParentElement) {
                    adjacentNode = el[siblingPropName];
                    if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {
                        var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];
                        if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {
                            return adjacentNodeChild;
                        }
                    }
                }
                return null;
            };
        }
        var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false), getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);
        function Merge(firstNode) {
            this.isElementMerge = (firstNode.nodeType == 1);
            this.textNodes = [];
            var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
            if (firstTextNode) {
                this.textNodes[0] = firstTextNode;
            }
        }
        Merge.prototype = {
            doMerge: function (positionsToPreserve) {
                var textNodes = this.textNodes;
                var firstTextNode = textNodes[0];
                if (textNodes.length > 1) {
                    var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);
                    var textParts = [], combinedTextLength = 0, textNode, parent;
                    forEach(textNodes, function (textNode, i) {
                        parent = textNode.parentNode;
                        if (i > 0) {
                            parent.removeChild(textNode);
                            if (!parent.hasChildNodes()) {
                                dom.removeNode(parent);
                            }
                            if (positionsToPreserve) {
                                forEach(positionsToPreserve, function (position) {
                                    if (position.node == textNode) {
                                        position.node = firstTextNode;
                                        position.offset += combinedTextLength;
                                    }
                                    if (position.node == parent && position.offset > firstTextNodeIndex) {
                                        --position.offset;
                                        if (position.offset == firstTextNodeIndex + 1 && i < len - 1) {
                                            position.node = firstTextNode;
                                            position.offset = combinedTextLength;
                                        }
                                    }
                                });
                            }
                        }
                        textParts[i] = textNode.data;
                        combinedTextLength += textNode.data.length;
                    });
                    firstTextNode.data = textParts.join("");
                }
                return firstTextNode.data;
            },
            getLength: function () {
                var i = this.textNodes.length, len = 0;
                while (i--) {
                    len += this.textNodes[i].length;
                }
                return len;
            },
            toString: function () {
                var textParts = [];
                forEach(this.textNodes, function (textNode, i) {
                    textParts[i] = "'" + textNode.data + "'";
                });
                return "[Merge(" + textParts.join(",") + ")]";
            }
        };
        var optionProperties = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly", "useExistingElements",
            "removeEmptyElements", "onElementCreate"];
        var attrNamesForProperties = {};
        function ClassApplier(className, options, tagNames) {
            var normalize, i, len, propName, applier = this;
            applier.cssClass = applier.className = className;
            var elementPropertiesFromOptions = null, elementAttributes = {};
            if (typeof options == "object" && options !== null) {
                if (typeof options.elementTagName !== "undefined") {
                    options.elementTagName = options.elementTagName.toLowerCase();
                }
                tagNames = options.tagNames;
                elementPropertiesFromOptions = options.elementProperties;
                elementAttributes = options.elementAttributes;
                for (i = 0; propName = optionProperties[i++];) {
                    if (options.hasOwnProperty(propName)) {
                        applier[propName] = options[propName];
                    }
                }
                normalize = options.normalize;
            }
            else {
                normalize = options;
            }
            applier.normalize = (typeof normalize == "undefined") ? true : normalize;
            applier.attrExceptions = [];
            var el = document.createElement(applier.elementTagName);
            applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);
            each(elementAttributes, function (attrName, attrValue) {
                applier.attrExceptions.push(attrName);
                elementAttributes[attrName] = "" + attrValue;
            });
            applier.elementAttributes = elementAttributes;
            applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ?
                sortClassName(applier.elementProperties.className + " " + className) : className;
            applier.applyToAnyTagName = false;
            var type = typeof tagNames;
            if (type == "string") {
                if (tagNames == "*") {
                    applier.applyToAnyTagName = true;
                }
                else {
                    applier.tagNames = trim(tagNames.toLowerCase()).split(/\s*,\s*/);
                }
            }
            else if (type == "object" && typeof tagNames.length == "number") {
                applier.tagNames = [];
                for (i = 0, len = tagNames.length; i < len; ++i) {
                    if (tagNames[i] == "*") {
                        applier.applyToAnyTagName = true;
                    }
                    else {
                        applier.tagNames.push(tagNames[i].toLowerCase());
                    }
                }
            }
            else {
                applier.tagNames = [applier.elementTagName];
            }
        }
        ClassApplier.prototype = {
            elementTagName: defaultTagName,
            elementProperties: {},
            elementAttributes: {},
            ignoreWhiteSpace: true,
            applyToEditableOnly: false,
            useExistingElements: true,
            removeEmptyElements: true,
            onElementCreate: null,
            copyPropertiesToElement: function (props, el, createCopy) {
                var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;
                for (var p in props) {
                    if (props.hasOwnProperty(p)) {
                        propValue = props[p];
                        elPropValue = el[p];
                        if (p == "className") {
                            addClass(el, propValue);
                            addClass(el, this.className);
                            el[p] = sortClassName(el[p]);
                            if (createCopy) {
                                elProps[p] = propValue;
                            }
                        }
                        else if (p == "style") {
                            elStyle = elPropValue;
                            if (createCopy) {
                                elProps[p] = elPropsStyle = {};
                            }
                            for (s in props[p]) {
                                if (props[p].hasOwnProperty(s)) {
                                    elStyle[s] = propValue[s];
                                    if (createCopy) {
                                        elPropsStyle[s] = elStyle[s];
                                    }
                                }
                            }
                            this.attrExceptions.push(p);
                        }
                        else {
                            el[p] = propValue;
                            if (createCopy) {
                                elProps[p] = el[p];
                                attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;
                                this.attrExceptions.push(attrName);
                            }
                        }
                    }
                }
                return createCopy ? elProps : "";
            },
            copyAttributesToElement: function (attrs, el) {
                for (var attrName in attrs) {
                    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {
                        el.setAttribute(attrName, attrs[attrName]);
                    }
                }
            },
            appliesToElement: function (el) {
                return contains(this.tagNames, el.tagName.toLowerCase());
            },
            getEmptyElements: function (range) {
                var applier = this;
                return range.getNodes([1], function (el) {
                    return applier.appliesToElement(el) && !el.hasChildNodes();
                });
            },
            hasClass: function (node) {
                return node.nodeType == 1 &&
                    (this.applyToAnyTagName || this.appliesToElement(node)) &&
                    hasClass(node, this.className);
            },
            getSelfOrAncestorWithClass: function (node) {
                while (node) {
                    if (this.hasClass(node)) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            },
            isModifiable: function (node) {
                return !this.applyToEditableOnly || isEditable(node);
            },
            isIgnorableWhiteSpaceNode: function (node) {
                return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);
            },
            postApply: function (textNodes, range, positionsToPreserve, isUndo) {
                var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];
                var merges = [], currentMerge;
                var rangeStartNode = firstNode, rangeEndNode = lastNode;
                var rangeStartOffset = 0, rangeEndOffset = lastNode.length;
                var textNode, precedingTextNode;
                forEach(textNodes, function (textNode) {
                    precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);
                    if (precedingTextNode) {
                        if (!currentMerge) {
                            currentMerge = new Merge(precedingTextNode);
                            merges.push(currentMerge);
                        }
                        currentMerge.textNodes.push(textNode);
                        if (textNode === firstNode) {
                            rangeStartNode = currentMerge.textNodes[0];
                            rangeStartOffset = rangeStartNode.length;
                        }
                        if (textNode === lastNode) {
                            rangeEndNode = currentMerge.textNodes[0];
                            rangeEndOffset = currentMerge.getLength();
                        }
                    }
                    else {
                        currentMerge = null;
                    }
                });
                var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);
                if (nextTextNode) {
                    if (!currentMerge) {
                        currentMerge = new Merge(lastNode);
                        merges.push(currentMerge);
                    }
                    currentMerge.textNodes.push(nextTextNode);
                }
                if (merges.length) {
                    for (i = 0, len = merges.length; i < len; ++i) {
                        merges[i].doMerge(positionsToPreserve);
                    }
                    range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);
                }
            },
            createContainer: function (parentNode) {
                var doc = dom.getDocument(parentNode);
                var namespace;
                var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?
                    doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :
                    doc.createElement(this.elementTagName);
                this.copyPropertiesToElement(this.elementProperties, el, false);
                this.copyAttributesToElement(this.elementAttributes, el);
                addClass(el, this.className);
                if (this.onElementCreate) {
                    this.onElementCreate(el, this);
                }
                return el;
            },
            elementHasProperties: function (el, props) {
                var applier = this;
                return each(props, function (p, propValue) {
                    if (p == "className") {
                        return hasAllClasses(el, propValue);
                    }
                    else if (typeof propValue == "object") {
                        if (!applier.elementHasProperties(el[p], propValue)) {
                            return false;
                        }
                    }
                    else if (el[p] !== propValue) {
                        return false;
                    }
                });
            },
            elementHasAttributes: function (el, attrs) {
                return each(attrs, function (name, value) {
                    if (el.getAttribute(name) !== value) {
                        return false;
                    }
                });
            },
            applyToTextNode: function (textNode, positionsToPreserve) {
                if (canTextBeStyled(textNode)) {
                    var parent = textNode.parentNode;
                    if (parent.childNodes.length == 1 &&
                        this.useExistingElements &&
                        this.appliesToElement(parent) &&
                        this.elementHasProperties(parent, this.elementProperties) &&
                        this.elementHasAttributes(parent, this.elementAttributes)) {
                        addClass(parent, this.className);
                    }
                    else {
                        var textNodeParent = textNode.parentNode;
                        var el = this.createContainer(textNodeParent);
                        textNodeParent.insertBefore(el, textNode);
                        el.appendChild(textNode);
                    }
                }
            },
            isRemovable: function (el) {
                return el.tagName.toLowerCase() == this.elementTagName &&
                    getSortedClassName(el) == this.elementSortedClassName &&
                    this.elementHasProperties(el, this.elementProperties) &&
                    !elementHasNonClassAttributes(el, this.attrExceptions) &&
                    this.elementHasAttributes(el, this.elementAttributes) &&
                    this.isModifiable(el);
            },
            isEmptyContainer: function (el) {
                var childNodeCount = el.childNodes.length;
                return el.nodeType == 1 &&
                    this.isRemovable(el) &&
                    (childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));
            },
            removeEmptyContainers: function (range) {
                var applier = this;
                var nodesToRemove = range.getNodes([1], function (el) {
                    return applier.isEmptyContainer(el);
                });
                var rangesToPreserve = [range];
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);
                forEach(nodesToRemove, function (node) {
                    removePreservingPositions(node, positionsToPreserve);
                });
                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
            },
            undoToTextNode: function (textNode, range, ancestorWithClass, positionsToPreserve) {
                if (!range.containsNode(ancestorWithClass)) {
                    var ancestorRange = range.cloneRange();
                    ancestorRange.selectNode(ancestorWithClass);
                    if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {
                        splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);
                        range.setEndAfter(ancestorWithClass);
                    }
                    if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {
                        ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);
                    }
                }
                if (this.isRemovable(ancestorWithClass)) {
                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
                }
                else {
                    removeClass(ancestorWithClass, this.className);
                }
            },
            splitAncestorWithClass: function (container, offset, positionsToPreserve) {
                var ancestorWithClass = this.getSelfOrAncestorWithClass(container);
                if (ancestorWithClass) {
                    splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);
                }
            },
            undoToAncestor: function (ancestorWithClass, positionsToPreserve) {
                if (this.isRemovable(ancestorWithClass)) {
                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
                }
                else {
                    removeClass(ancestorWithClass, this.className);
                }
            },
            applyToRange: function (range, rangesToPreserve) {
                var applier = this;
                rangesToPreserve = rangesToPreserve || [];
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);
                range.splitBoundariesPreservingPositions(positionsToPreserve);
                if (applier.removeEmptyElements) {
                    applier.removeEmptyContainers(range);
                }
                var textNodes = getEffectiveTextNodes(range);
                if (textNodes.length) {
                    forEach(textNodes, function (textNode) {
                        if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&
                            applier.isModifiable(textNode)) {
                            applier.applyToTextNode(textNode, positionsToPreserve);
                        }
                    });
                    var lastTextNode = textNodes[textNodes.length - 1];
                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
                    if (applier.normalize) {
                        applier.postApply(textNodes, range, positionsToPreserve, false);
                    }
                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
                }
                var emptyElements = applier.getEmptyElements(range);
                forEach(emptyElements, function (el) {
                    addClass(el, applier.className);
                });
            },
            applyToRanges: function (ranges) {
                var i = ranges.length;
                while (i--) {
                    this.applyToRange(ranges[i], ranges);
                }
                return ranges;
            },
            applyToSelection: function (win) {
                var sel = api.getSelection(win);
                sel.setRanges(this.applyToRanges(sel.getAllRanges()));
            },
            undoToRange: function (range, rangesToPreserve) {
                var applier = this;
                rangesToPreserve = rangesToPreserve || [];
                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);
                range.splitBoundariesPreservingPositions(positionsToPreserve);
                if (applier.removeEmptyElements) {
                    applier.removeEmptyContainers(range, positionsToPreserve);
                }
                var textNodes = getEffectiveTextNodes(range);
                var textNode, ancestorWithClass;
                var lastTextNode = textNodes[textNodes.length - 1];
                if (textNodes.length) {
                    applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);
                    applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);
                    for (var i = 0, len = textNodes.length; i < len; ++i) {
                        textNode = textNodes[i];
                        ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);
                        if (ancestorWithClass && applier.isModifiable(textNode)) {
                            applier.undoToAncestor(ancestorWithClass, positionsToPreserve);
                        }
                    }
                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
                    if (applier.normalize) {
                        applier.postApply(textNodes, range, positionsToPreserve, true);
                    }
                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
                }
                var emptyElements = applier.getEmptyElements(range);
                forEach(emptyElements, function (el) {
                    removeClass(el, applier.className);
                });
            },
            undoToRanges: function (ranges) {
                var i = ranges.length;
                while (i--) {
                    this.undoToRange(ranges[i], ranges);
                }
                return ranges;
            },
            undoToSelection: function (win) {
                var sel = api.getSelection(win);
                var ranges = api.getSelection(win).getAllRanges();
                this.undoToRanges(ranges);
                sel.setRanges(ranges);
            },
            isAppliedToRange: function (range) {
                if (range.collapsed || range.toString() == "") {
                    return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);
                }
                else {
                    var textNodes = range.getNodes([3]);
                    if (textNodes.length)
                        for (var i = 0, textNode; textNode = textNodes[i++];) {
                            if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&
                                this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {
                                return false;
                            }
                        }
                    return true;
                }
            },
            isAppliedToRanges: function (ranges) {
                var i = ranges.length;
                if (i == 0) {
                    return false;
                }
                while (i--) {
                    if (!this.isAppliedToRange(ranges[i])) {
                        return false;
                    }
                }
                return true;
            },
            isAppliedToSelection: function (win) {
                var sel = api.getSelection(win);
                return this.isAppliedToRanges(sel.getAllRanges());
            },
            toggleRange: function (range) {
                if (this.isAppliedToRange(range)) {
                    this.undoToRange(range);
                }
                else {
                    this.applyToRange(range);
                }
            },
            toggleSelection: function (win) {
                if (this.isAppliedToSelection(win)) {
                    this.undoToSelection(win);
                }
                else {
                    this.applyToSelection(win);
                }
            },
            getElementsWithClassIntersectingRange: function (range) {
                var elements = [];
                var applier = this;
                range.getNodes([3], function (textNode) {
                    var el = applier.getSelfOrAncestorWithClass(textNode);
                    if (el && !contains(elements, el)) {
                        elements.push(el);
                    }
                });
                return elements;
            },
            detach: function () { }
        };
        function createClassApplier(className, options, tagNames) {
            return new ClassApplier(className, options, tagNames);
        }
        ClassApplier.util = {
            hasClass: hasClass,
            addClass: addClass,
            removeClass: removeClass,
            getClass: getClass,
            hasSameClasses: haveSameClasses,
            hasAllClasses: hasAllClasses,
            replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,
            elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,
            elementHasNonClassAttributes: elementHasNonClassAttributes,
            splitNodeAt: splitNodeAt,
            isEditableElement: isEditableElement,
            isEditingHost: isEditingHost,
            isEditable: isEditable
        };
        api.CssClassApplier = api.ClassApplier = ClassApplier;
        api.createClassApplier = createClassApplier;
        util.createAliasForDeprecatedMethod(api, "createCssClassApplier", "createClassApplier", module);
    });
    return rangy;
}, this);
(function (factory, root) {
    if (typeof define == "function" && define.amd) {
        define(["./rangy-core"], factory);
    }
    else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory(require("rangy"));
    }
    else {
        factory(root.rangy);
    }
})(function (rangy) {
    rangy.createModule("SaveRestore", ["WrappedRange"], function (api, module) {
        var dom = api.dom;
        var removeNode = dom.removeNode;
        var isDirectionBackward = api.Selection.isDirectionBackward;
        var markerTextChar = "\ufeff";
        function gEBI(id, doc) {
            return (doc || document).getElementById(id);
        }
        function insertRangeBoundaryMarker(range, atStart) {
            var markerId = "selectionBoundary_" + (+new Date()) + "_" + ("" + Math.random()).slice(2);
            var markerEl;
            var doc = dom.getDocument(range.startContainer);
            var boundaryRange = range.cloneRange();
            boundaryRange.collapse(atStart);
            markerEl = doc.createElement("span");
            markerEl.id = markerId;
            markerEl.style.lineHeight = "0";
            markerEl.style.display = "none";
            markerEl.className = "rangySelectionBoundary";
            markerEl.appendChild(doc.createTextNode(markerTextChar));
            boundaryRange.insertNode(markerEl);
            return markerEl;
        }
        function setRangeBoundary(doc, range, markerId, atStart) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                range[atStart ? "setStartBefore" : "setEndBefore"](markerEl);
                removeNode(markerEl);
            }
            else {
                module.warn("Marker element has been removed. Cannot restore selection.");
            }
        }
        function compareRanges(r1, r2) {
            return r2.compareBoundaryPoints(r1.START_TO_START, r1);
        }
        function saveRange(range, direction) {
            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();
            var backward = isDirectionBackward(direction);
            if (range.collapsed) {
                endEl = insertRangeBoundaryMarker(range, false);
                return {
                    document: doc,
                    markerId: endEl.id,
                    collapsed: true
                };
            }
            else {
                endEl = insertRangeBoundaryMarker(range, false);
                startEl = insertRangeBoundaryMarker(range, true);
                return {
                    document: doc,
                    startMarkerId: startEl.id,
                    endMarkerId: endEl.id,
                    collapsed: false,
                    backward: backward,
                    toString: function () {
                        return "original text: '" + text + "', new text: '" + range.toString() + "'";
                    }
                };
            }
        }
        function restoreRange(rangeInfo, normalize) {
            var doc = rangeInfo.document;
            if (typeof normalize == "undefined") {
                normalize = true;
            }
            var range = api.createRange(doc);
            if (rangeInfo.collapsed) {
                var markerEl = gEBI(rangeInfo.markerId, doc);
                if (markerEl) {
                    markerEl.style.display = "inline";
                    var previousNode = markerEl.previousSibling;
                    if (previousNode && previousNode.nodeType == 3) {
                        removeNode(markerEl);
                        range.collapseToPoint(previousNode, previousNode.length);
                    }
                    else {
                        range.collapseBefore(markerEl);
                        removeNode(markerEl);
                    }
                }
                else {
                    module.warn("Marker element has been removed. Cannot restore selection.");
                }
            }
            else {
                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);
                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);
            }
            if (normalize) {
                range.normalizeBoundaries();
            }
            return range;
        }
        function saveRanges(ranges, direction) {
            var rangeInfos = [], range, doc;
            var backward = isDirectionBackward(direction);
            ranges = ranges.slice(0);
            ranges.sort(compareRanges);
            for (var i = 0, len = ranges.length; i < len; ++i) {
                rangeInfos[i] = saveRange(ranges[i], backward);
            }
            for (i = len - 1; i >= 0; --i) {
                range = ranges[i];
                doc = api.DomRange.getRangeDocument(range);
                if (range.collapsed) {
                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));
                }
                else {
                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));
                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));
                }
            }
            return rangeInfos;
        }
        function saveSelection(win) {
            if (!api.isSelectionValid(win)) {
                module.warn("Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.");
                return null;
            }
            var sel = api.getSelection(win);
            var ranges = sel.getAllRanges();
            var backward = (ranges.length == 1 && sel.isBackward());
            var rangeInfos = saveRanges(ranges, backward);
            if (backward) {
                sel.setSingleRange(ranges[0], backward);
            }
            else {
                sel.setRanges(ranges);
            }
            return {
                win: win,
                rangeInfos: rangeInfos,
                restored: false
            };
        }
        function restoreRanges(rangeInfos) {
            var ranges = [];
            var rangeCount = rangeInfos.length;
            for (var i = rangeCount - 1; i >= 0; i--) {
                ranges[i] = restoreRange(rangeInfos[i], true);
            }
            return ranges;
        }
        function restoreSelection(savedSelection, preserveDirection) {
            if (!savedSelection.restored) {
                var rangeInfos = savedSelection.rangeInfos;
                var sel = api.getSelection(savedSelection.win);
                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;
                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {
                    sel.removeAllRanges();
                    sel.addRange(ranges[0], true);
                }
                else {
                    sel.setRanges(ranges);
                }
                savedSelection.restored = true;
            }
        }
        function removeMarkerElement(doc, markerId) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                removeNode(markerEl);
            }
        }
        function removeMarkers(savedSelection) {
            var rangeInfos = savedSelection.rangeInfos;
            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {
                rangeInfo = rangeInfos[i];
                if (rangeInfo.collapsed) {
                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);
                }
                else {
                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);
                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);
                }
            }
        }
        api.util.extend(api, {
            saveRange: saveRange,
            restoreRange: restoreRange,
            saveRanges: saveRanges,
            restoreRanges: restoreRanges,
            saveSelection: saveSelection,
            restoreSelection: restoreSelection,
            removeMarkerElement: removeMarkerElement,
            removeMarkers: removeMarkers
        });
    });
    return rangy;
}, this);
(function (factory, root) {
    if (typeof define == "function" && define.amd) {
        define(["./rangy-core"], factory);
    }
    else if (typeof module != "undefined" && typeof exports == "object") {
        module.exports = factory(require("rangy"));
    }
    else {
        factory(root.rangy);
    }
})(function (rangy) {
    rangy.createModule("Serializer", ["WrappedSelection"], function (api, module) {
        var UNDEF = "undefined";
        var util = api.util;
        if (typeof encodeURIComponent == UNDEF || typeof decodeURIComponent == UNDEF) {
            module.fail("encodeURIComponent and/or decodeURIComponent method is missing");
        }
        var crc32 = (function () {
            function utf8encode(str) {
                var utf8CharCodes = [];
                for (var i = 0, len = str.length, c; i < len; ++i) {
                    c = str.charCodeAt(i);
                    if (c < 128) {
                        utf8CharCodes.push(c);
                    }
                    else if (c < 2048) {
                        utf8CharCodes.push((c >> 6) | 192, (c & 63) | 128);
                    }
                    else {
                        utf8CharCodes.push((c >> 12) | 224, ((c >> 6) & 63) | 128, (c & 63) | 128);
                    }
                }
                return utf8CharCodes;
            }
            var cachedCrcTable = null;
            function buildCRCTable() {
                var table = [];
                for (var i = 0, j, crc; i < 256; ++i) {
                    crc = i;
                    j = 8;
                    while (j--) {
                        if ((crc & 1) == 1) {
                            crc = (crc >>> 1) ^ 0xEDB88320;
                        }
                        else {
                            crc >>>= 1;
                        }
                    }
                    table[i] = crc >>> 0;
                }
                return table;
            }
            function getCrcTable() {
                if (!cachedCrcTable) {
                    cachedCrcTable = buildCRCTable();
                }
                return cachedCrcTable;
            }
            return function (str) {
                var utf8CharCodes = utf8encode(str), crc = -1, crcTable = getCrcTable();
                for (var i = 0, len = utf8CharCodes.length, y; i < len; ++i) {
                    y = (crc ^ utf8CharCodes[i]) & 0xFF;
                    crc = (crc >>> 8) ^ crcTable[y];
                }
                return (crc ^ -1) >>> 0;
            };
        })();
        var dom = api.dom;
        function escapeTextForHtml(str) {
            return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function nodeToInfoString(node, infoParts) {
            infoParts = infoParts || [];
            var nodeType = node.nodeType, children = node.childNodes, childCount = children.length;
            var nodeInfo = [nodeType, node.nodeName, childCount].join(":");
            var start = "", end = "";
            switch (nodeType) {
                case 3:
                    start = escapeTextForHtml(node.nodeValue);
                    break;
                case 8:
                    start = "<!--" + escapeTextForHtml(node.nodeValue) + "-->";
                    break;
                default:
                    start = "<" + nodeInfo + ">";
                    end = "</>";
                    break;
            }
            if (start) {
                infoParts.push(start);
            }
            for (var i = 0; i < childCount; ++i) {
                nodeToInfoString(children[i], infoParts);
            }
            if (end) {
                infoParts.push(end);
            }
            return infoParts;
        }
        function getElementChecksum(el) {
            var info = nodeToInfoString(el).join("");
            return crc32(info).toString(16);
        }
        function serializePosition(node, offset, rootNode) {
            var pathParts = [], n = node;
            rootNode = rootNode || dom.getDocument(node).documentElement;
            while (n && n != rootNode) {
                pathParts.push(dom.getNodeIndex(n, true));
                n = n.parentNode;
            }
            return pathParts.join("/") + ":" + offset;
        }
        function deserializePosition(serialized, rootNode, doc) {
            if (!rootNode) {
                rootNode = (doc || document).documentElement;
            }
            var parts = serialized.split(":");
            var node = rootNode;
            var nodeIndices = parts[0] ? parts[0].split("/") : [], i = nodeIndices.length, nodeIndex;
            while (i--) {
                nodeIndex = parseInt(nodeIndices[i], 10);
                if (nodeIndex < node.childNodes.length) {
                    node = node.childNodes[nodeIndex];
                }
                else {
                    throw module.createError("deserializePosition() failed: node " + dom.inspectNode(node) +
                        " has no child with index " + nodeIndex + ", " + i);
                }
            }
            return new dom.DomPosition(node, parseInt(parts[1], 10));
        }
        function serializeRange(range, omitChecksum, rootNode) {
            rootNode = rootNode || api.DomRange.getRangeDocument(range).documentElement;
            if (!dom.isOrIsAncestorOf(rootNode, range.commonAncestorContainer)) {
                throw module.createError("serializeRange(): range " + range.inspect() +
                    " is not wholly contained within specified root node " + dom.inspectNode(rootNode));
            }
            var serialized = serializePosition(range.startContainer, range.startOffset, rootNode) + "," +
                serializePosition(range.endContainer, range.endOffset, rootNode);
            if (!omitChecksum) {
                serialized += "{" + getElementChecksum(rootNode) + "}";
            }
            return serialized;
        }
        var deserializeRegex = /^([^,]+),([^,\{]+)(\{([^}]+)\})?$/;
        function deserializeRange(serialized, rootNode, doc) {
            if (rootNode) {
                doc = doc || dom.getDocument(rootNode);
            }
            else {
                doc = doc || document;
                rootNode = doc.documentElement;
            }
            var result = deserializeRegex.exec(serialized);
            var checksum = result[4];
            if (checksum) {
                var rootNodeChecksum = getElementChecksum(rootNode);
                if (checksum !== rootNodeChecksum) {
                    throw module.createError("deserializeRange(): checksums of serialized range root node (" + checksum +
                        ") and target root node (" + rootNodeChecksum + ") do not match");
                }
            }
            var start = deserializePosition(result[1], rootNode, doc), end = deserializePosition(result[2], rootNode, doc);
            var range = api.createRange(doc);
            range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
            return range;
        }
        function canDeserializeRange(serialized, rootNode, doc) {
            if (!rootNode) {
                rootNode = (doc || document).documentElement;
            }
            var result = deserializeRegex.exec(serialized);
            var checksum = result[3];
            return !checksum || checksum === getElementChecksum(rootNode);
        }
        function serializeSelection(selection, omitChecksum, rootNode) {
            selection = api.getSelection(selection);
            var ranges = selection.getAllRanges(), serializedRanges = [];
            for (var i = 0, len = ranges.length; i < len; ++i) {
                serializedRanges[i] = serializeRange(ranges[i], omitChecksum, rootNode);
            }
            return serializedRanges.join("|");
        }
        function deserializeSelection(serialized, rootNode, win) {
            if (rootNode) {
                win = win || dom.getWindow(rootNode);
            }
            else {
                win = win || window;
                rootNode = win.document.documentElement;
            }
            var serializedRanges = serialized.split("|");
            var sel = api.getSelection(win);
            var ranges = [];
            for (var i = 0, len = serializedRanges.length; i < len; ++i) {
                ranges[i] = deserializeRange(serializedRanges[i], rootNode, win.document);
            }
            sel.setRanges(ranges);
            return sel;
        }
        function canDeserializeSelection(serialized, rootNode, win) {
            var doc;
            if (rootNode) {
                doc = win ? win.document : dom.getDocument(rootNode);
            }
            else {
                win = win || window;
                rootNode = win.document.documentElement;
            }
            var serializedRanges = serialized.split("|");
            for (var i = 0, len = serializedRanges.length; i < len; ++i) {
                if (!canDeserializeRange(serializedRanges[i], rootNode, doc)) {
                    return false;
                }
            }
            return true;
        }
        var cookieName = "rangySerializedSelection";
        function getSerializedSelectionFromCookie(cookie) {
            var parts = cookie.split(/[;,]/);
            for (var i = 0, len = parts.length, nameVal, val; i < len; ++i) {
                nameVal = parts[i].split("=");
                if (nameVal[0].replace(/^\s+/, "") == cookieName) {
                    val = nameVal[1];
                    if (val) {
                        return decodeURIComponent(val.replace(/\s+$/, ""));
                    }
                }
            }
            return null;
        }
        function restoreSelectionFromCookie(win) {
            win = win || window;
            var serialized = getSerializedSelectionFromCookie(win.document.cookie);
            if (serialized) {
                deserializeSelection(serialized, win.doc);
            }
        }
        function saveSelectionCookie(win, props) {
            win = win || window;
            props = (typeof props == "object") ? props : {};
            var expires = props.expires ? ";expires=" + props.expires.toUTCString() : "";
            var path = props.path ? ";path=" + props.path : "";
            var domain = props.domain ? ";domain=" + props.domain : "";
            var secure = props.secure ? ";secure" : "";
            var serialized = serializeSelection(api.getSelection(win));
            win.document.cookie = encodeURIComponent(cookieName) + "=" + encodeURIComponent(serialized) + expires + path + domain + secure;
        }
        util.extend(api, {
            serializePosition: serializePosition,
            deserializePosition: deserializePosition,
            serializeRange: serializeRange,
            deserializeRange: deserializeRange,
            canDeserializeRange: canDeserializeRange,
            serializeSelection: serializeSelection,
            deserializeSelection: deserializeSelection,
            canDeserializeSelection: canDeserializeSelection,
            restoreSelectionFromCookie: restoreSelectionFromCookie,
            saveSelectionCookie: saveSelectionCookie,
            getElementChecksum: getElementChecksum,
            nodeToInfoString: nodeToInfoString
        });
        util.crc32 = crc32;
    });
    return rangy;
}, this);
(function (U, a) {
    'use strict';
    function L(m, f) { f = f || {}; a.forEach(f, function (a, d) { delete f[d]; }); for (var d in m)
        !m.hasOwnProperty(d) || "$" === d.charAt(0) && "$" === d.charAt(1) || (f[d] = m[d]); return f; }
    var B = a.$$minErr("$resource"), Q = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    a.module("ngResource", ["ng"]).info({ angularVersion: "1.6.10" }).provider("$resource", function () {
        var m = /^https?:\/\/\[[^\]]*][^/]*/, f = this;
        this.defaults = { stripTrailingSlashes: !0, cancellable: !1, actions: { get: { method: "GET" }, save: { method: "POST" }, query: { method: "GET",
                    isArray: !0 }, remove: { method: "DELETE" }, "delete": { method: "DELETE" } } };
        this.$get = ["$http", "$log", "$q", "$timeout", function (d, P, F, M) {
                function C(a, d) { this.template = a; this.defaults = n({}, f.defaults, d); this.urlParams = {}; }
                var D = a.noop, r = a.forEach, n = a.extend, R = a.copy, N = a.isArray, w = a.isDefined, x = a.isFunction, S = a.isNumber, y = a.$$encodeUriQuery, T = a.$$encodeUriSegment;
                C.prototype = { setUrlParams: function (a, d, f) {
                        var g = this, c = f || g.template, s, h, n = "", b = g.urlParams = Object.create(null);
                        r(c.split(/\W/), function (a) {
                            if ("hasOwnProperty" ===
                                a)
                                throw B("badname");
                            !/^\d+$/.test(a) && a && (new RegExp("(^|[^\\\\]):" + a + "(\\W|$)")).test(c) && (b[a] = { isQueryParamValue: (new RegExp("\\?.*=:" + a + "(?:\\W|$)")).test(c) });
                        });
                        c = c.replace(/\\:/g, ":");
                        c = c.replace(m, function (b) { n = b; return ""; });
                        d = d || {};
                        r(g.urlParams, function (b, a) {
                            s = d.hasOwnProperty(a) ? d[a] : g.defaults[a];
                            w(s) && null !== s ? (h = b.isQueryParamValue ? y(s, !0) : T(s), c = c.replace(new RegExp(":" + a + "(\\W|$)", "g"), function (b, a) { return h + a; })) : c = c.replace(new RegExp("(/?):" + a + "(\\W|$)", "g"), function (a, b, e) {
                                return "/" ===
                                    e.charAt(0) ? e : b + e;
                            });
                        });
                        g.defaults.stripTrailingSlashes && (c = c.replace(/\/+$/, "") || "/");
                        c = c.replace(/\/\.(?=\w+($|\?))/, ".");
                        a.url = n + c.replace(/\/(\\|%5C)\./, "/.");
                        r(d, function (b, c) { g.urlParams[c] || (a.params = a.params || {}, a.params[c] = b); });
                    } };
                return function (m, y, z, g) {
                    function c(b, c) {
                        var d = {};
                        c = n({}, y, c);
                        r(c, function (c, f) {
                            x(c) && (c = c(b));
                            var e;
                            if (c && c.charAt && "@" === c.charAt(0)) {
                                e = b;
                                var k = c.substr(1);
                                if (null == k || "" === k || "hasOwnProperty" === k || !Q.test("." + k))
                                    throw B("badmember", k);
                                for (var k = k.split("."), h = 0, n = k.length; h < n && a.isDefined(e); h++) {
                                    var g = k[h];
                                    e = null !== e ? e[g] : void 0;
                                }
                            }
                            else
                                e = c;
                            d[f] = e;
                        });
                        return d;
                    }
                    function s(b) { return b.resource; }
                    function h(b) { L(b || {}, this); }
                    var O = new C(m, g);
                    z = n({}, f.defaults.actions, z);
                    h.prototype.toJSON = function () { var b = n({}, this); delete b.$promise; delete b.$resolved; delete b.$cancelRequest; return b; };
                    r(z, function (b, a) {
                        var f = !0 === b.hasBody || !1 !== b.hasBody && /^(POST|PUT|PATCH)$/i.test(b.method), g = b.timeout, m = w(b.cancellable) ? b.cancellable : O.defaults.cancellable;
                        g && !S(g) && (P.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."),
                            delete b.timeout, g = null);
                        h[a] = function (e, k, G, y) {
                            function z(a) { p.catch(D); null !== t && t.resolve(a); }
                            var H = {}, u, v, A;
                            switch (arguments.length) {
                                case 4: A = y, v = G;
                                case 3:
                                case 2: if (x(k)) {
                                    if (x(e)) {
                                        v = e;
                                        A = k;
                                        break;
                                    }
                                    v = k;
                                    A = G;
                                }
                                else {
                                    H = e;
                                    u = k;
                                    v = G;
                                    break;
                                }
                                case 1:
                                    x(e) ? v = e : f ? u = e : H = e;
                                    break;
                                case 0: break;
                                default: throw B("badargs", arguments.length);
                            }
                            var E = this instanceof h, l = E ? u : b.isArray ? [] : new h(u), q = {}, C = b.interceptor && b.interceptor.response || s, w = b.interceptor && b.interceptor.responseError || void 0, I = !!A, J = !!w, t, K;
                            r(b, function (a, b) { switch (b) {
                                default: q[b] = R(a);
                                case "params":
                                case "isArray":
                                case "interceptor":
                                case "cancellable":
                            } });
                            !E && m && (t = F.defer(), q.timeout = t.promise, g && (K = M(t.resolve, g)));
                            f && (q.data = u);
                            O.setUrlParams(q, n({}, c(u, b.params || {}), H), b.url);
                            var p = d(q).then(function (c) {
                                var e = c.data;
                                if (e) {
                                    if (N(e) !== !!b.isArray)
                                        throw B("badcfg", a, b.isArray ? "array" : "object", N(e) ? "array" : "object", q.method, q.url);
                                    if (b.isArray)
                                        l.length = 0, r(e, function (a) { "object" === typeof a ? l.push(new h(a)) : l.push(a); });
                                    else {
                                        var d = l.$promise;
                                        L(e, l);
                                        l.$promise =
                                            d;
                                    }
                                }
                                c.resource = l;
                                return c;
                            }, function (a) { a.resource = l; return F.reject(a); }), p = p["finally"](function () { l.$resolved = !0; !E && m && (l.$cancelRequest = D, M.cancel(K), t = K = q.timeout = null); }), p = p.then(function (a) { var b = C(a); (v || D)(b, a.headers, a.status, a.statusText); return b; }, I || J ? function (a) { I && !J && p.catch(D); I && A(a); return J ? w(a) : F.reject(a); } : void 0);
                            return E ? p : (l.$promise = p, l.$resolved = !1, m && (l.$cancelRequest = z), l);
                        };
                        h.prototype["$" + a] = function (b, c, d) {
                            x(b) && (d = c, c = b, b = {});
                            b = h[a].call(this, b, this, c, d);
                            return b.$promise ||
                                b;
                        };
                    });
                    return h;
                };
            }];
    });
})(window, window.angular);
(function (n, c) {
    'use strict';
    function l(b, a, g) {
        var d = g.baseHref(), k = b[0];
        return function (b, e, f) {
            var g, h;
            f = f || {};
            h = f.expires;
            g = c.isDefined(f.path) ? f.path : d;
            c.isUndefined(e) && (h = "Thu, 01 Jan 1970 00:00:00 GMT", e = "");
            c.isString(h) && (h = new Date(h));
            e = encodeURIComponent(b) + "=" + encodeURIComponent(e);
            e = e + (g ? ";path=" + g : "") + (f.domain ? ";domain=" + f.domain : "");
            e += h ? ";expires=" + h.toUTCString() : "";
            e += f.secure ? ";secure" : "";
            f = e.length + 1;
            4096 < f && a.warn("Cookie '" + b + "' possibly not set or overflowed because it was too large (" +
                f + " > 4096 bytes)!");
            k.cookie = e;
        };
    }
    c.module("ngCookies", ["ng"]).info({ angularVersion: "1.6.10" }).provider("$cookies", [function () { var b = this.defaults = {}; this.$get = ["$$cookieReader", "$$cookieWriter", function (a, g) { return { get: function (d) { return a()[d]; }, getObject: function (d) { return (d = this.get(d)) ? c.fromJson(d) : d; }, getAll: function () { return a(); }, put: function (d, a, m) { g(d, a, m ? c.extend({}, b, m) : b); }, putObject: function (d, b, a) { this.put(d, c.toJson(b), a); }, remove: function (a, k) { g(a, void 0, k ? c.extend({}, b, k) : b); } }; }]; }]);
    c.module("ngCookies").factory("$cookieStore", ["$cookies", function (b) { return { get: function (a) { return b.getObject(a); }, put: function (a, c) { b.putObject(a, c); }, remove: function (a) { b.remove(a); } }; }]);
    l.$inject = ["$document", "$log", "$browser"];
    c.module("ngCookies").provider("$$cookieWriter", function () { this.$get = l; });
})(window, window.angular);
(function (s, c) {
    'use strict';
    function P(c) { var h = []; C(h, E).chars(c); return h.join(""); }
    var D = c.$$minErr("$sanitize"), F, h, G, H, I, q, E, J, K, C;
    c.module("ngSanitize", []).provider("$sanitize", function () {
        function f(a, e) { return B(a.split(","), e); }
        function B(a, e) { var d = {}, b; for (b = 0; b < a.length; b++)
            d[e ? q(a[b]) : a[b]] = !0; return d; }
        function t(a, e) { e && e.length && h(a, B(e)); }
        function Q(a) { for (var e = {}, d = 0, b = a.length; d < b; d++) {
            var k = a[d];
            e[k.name] = k.value;
        } return e; }
        function L(a) {
            return a.replace(/&/g, "&amp;").replace(z, function (a) {
                var d = a.charCodeAt(0);
                a = a.charCodeAt(1);
                return "&#" + (1024 * (d - 55296) + (a - 56320) + 65536) + ";";
            }).replace(u, function (a) { return "&#" + a.charCodeAt(0) + ";"; }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function A(a) { for (; a;) {
            if (a.nodeType === s.Node.ELEMENT_NODE)
                for (var e = a.attributes, d = 0, b = e.length; d < b; d++) {
                    var k = e[d], g = k.name.toLowerCase();
                    if ("xmlns:ns1" === g || 0 === g.lastIndexOf("ns1:", 0))
                        a.removeAttributeNode(k), d--, b--;
                }
            (e = a.firstChild) && A(e);
            a = v("nextSibling", a);
        } }
        function v(a, e) {
            var d = e[a];
            if (d && J.call(e, d))
                throw D("elclob", e.outerHTML || e.outerText);
            return d;
        }
        var y = !1, g = !1;
        this.$get = ["$$sanitizeUri", function (a) { y = !0; g && h(m, l); return function (e) { var d = []; K(e, C(d, function (b, d) { return !/^unsafe:/.test(a(b, d)); })); return d.join(""); }; }];
        this.enableSvg = function (a) { return I(a) ? (g = a, this) : g; };
        this.addValidElements = function (a) { y || (H(a) && (a = { htmlElements: a }), t(l, a.svgElements), t(r, a.htmlVoidElements), t(m, a.htmlVoidElements), t(m, a.htmlElements)); return this; };
        this.addValidAttrs = function (a) { y || h(M, B(a, !0)); return this; };
        F = c.bind;
        h = c.extend;
        G = c.forEach;
        H = c.isArray;
        I = c.isDefined;
        q = c.lowercase;
        E = c.noop;
        K = function (a, e) {
            null === a || void 0 === a ? a = "" : "string" !== typeof a && (a = "" + a);
            var d = N(a);
            if (!d)
                return "";
            var b = 5;
            do {
                if (0 === b)
                    throw D("uinput");
                b--;
                a = d.innerHTML;
                d = N(a);
            } while (a !== d.innerHTML);
            for (b = d.firstChild; b;) {
                switch (b.nodeType) {
                    case 1:
                        e.start(b.nodeName.toLowerCase(), Q(b.attributes));
                        break;
                    case 3: e.chars(b.textContent);
                }
                var k;
                if (!(k = b.firstChild) && (1 === b.nodeType && e.end(b.nodeName.toLowerCase()), k = v("nextSibling", b), !k))
                    for (; null == k;) {
                        b = v("parentNode", b);
                        if (b === d)
                            break;
                        k = v("nextSibling", b);
                        1 === b.nodeType && e.end(b.nodeName.toLowerCase());
                    }
                b = k;
            }
            for (; b = d.firstChild;)
                d.removeChild(b);
        };
        C = function (a, e) { var d = !1, b = F(a, a.push); return { start: function (a, g) { a = q(a); !d && w[a] && (d = a); d || !0 !== m[a] || (b("<"), b(a), G(g, function (d, g) { var c = q(g), f = "img" === a && "src" === c || "background" === c; !0 !== M[c] || !0 === O[c] && !e(d, f) || (b(" "), b(g), b('="'), b(L(d)), b('"')); }), b(">")); }, end: function (a) { a = q(a); d || !0 !== m[a] || !0 === r[a] || (b("</"), b(a), b(">")); a == d && (d = !1); }, chars: function (a) { d || b(L(a)); } }; };
        J = s.Node.prototype.contains || function (a) { return !!(this.compareDocumentPosition(a) & 16); };
        var z = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, u = /([^#-~ |!])/g, r = f("area,br,col,hr,img,wbr"), x = f("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), p = f("rp,rt"), n = h({}, p, x), x = h({}, x, f("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")), p = h({}, p, f("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), l = f("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"), w = f("script,style"), m = h({}, r, x, p, n), O = f("background,cite,href,longdesc,src,xlink:href,xml:base"), n = f("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), p = f("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0), M = h({}, O, p, n), N = function (a, e) {
            function d(b) { b = "<remove></remove>" + b; try {
                var d = (new a.DOMParser).parseFromString(b, "text/html").body;
                d.firstChild.remove();
                return d;
            }
            catch (e) { } }
            function b(a) { c.innerHTML = a; e.documentMode && A(c); return c; }
            var g;
            if (e && e.implementation)
                g = e.implementation.createHTMLDocument("inert");
            else
                throw D("noinert");
            var c = (g.documentElement || g.getDocumentElement()).querySelector("body");
            c.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';
            return c.querySelector("svg") ?
                (c.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', c.querySelector("svg img") ? d : b) : function (b) { b = "<remove></remove>" + b; try {
                b = encodeURI(b);
            }
            catch (d) {
                return;
            } var e = new a.XMLHttpRequest; e.responseType = "document"; e.open("GET", "data:text/html;charset=utf-8," + b, !1); e.send(null); b = e.response.body; b.firstChild.remove(); return b; };
        }(s, s.document);
    }).info({ angularVersion: "1.6.10" });
    c.module("ngSanitize").filter("linky", ["$sanitize", function (f) {
            var h = /((s?ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, t = /^mailto:/i, q = c.$$minErr("linky"), s = c.isDefined, A = c.isFunction, v = c.isObject, y = c.isString;
            return function (c, z, u) {
                function r(c) { c && l.push(P(c)); }
                function x(c, g) { var f, a = p(c); l.push("<a "); for (f in a)
                    l.push(f + '="' + a[f] + '" '); !s(z) || "target" in a || l.push('target="', z, '" '); l.push('href="', c.replace(/"/g, "&quot;"), '">'); r(g); l.push("</a>"); }
                if (null == c || "" === c)
                    return c;
                if (!y(c))
                    throw q("notstring", c);
                for (var p = A(u) ? u : v(u) ? function () { return u; } : function () { return {}; }, n = c, l = [], w, m; c = n.match(h);)
                    w = c[0], c[2] ||
                        c[4] || (w = (c[3] ? "http://" : "mailto:") + w), m = c.index, r(n.substr(0, m)), x(w, c[0].replace(t, "")), n = n.substring(m + c[0].length);
                r(n);
                return f(l.join(""));
            };
        }]);
})(window, window.angular);
(function (S, q) {
    'use strict';
    function Ea(a, b, c) { if (!a)
        throw Pa("areq", b || "?", c || "required"); return a; }
    function Fa(a, b) { if (!a && !b)
        return ""; if (!a)
        return b; if (!b)
        return a; V(a) && (a = a.join(" ")); V(b) && (b = b.join(" ")); return a + " " + b; }
    function Qa(a) { var b = {}; a && (a.to || a.from) && (b.to = a.to, b.from = a.from); return b; }
    function W(a, b, c) { var d = ""; a = V(a) ? a : a && C(a) && a.length ? a.split(/\s+/) : []; t(a, function (a, f) { a && 0 < a.length && (d += 0 < f ? " " : "", d += c ? b + a : a + b); }); return d; }
    function Ga(a) {
        if (a instanceof A)
            switch (a.length) {
                case 0: return a;
                case 1:
                    if (1 === a[0].nodeType)
                        return a;
                    break;
                default: return A(ua(a));
            }
        if (1 === a.nodeType)
            return A(a);
    }
    function ua(a) { if (!a[0])
        return a; for (var b = 0; b < a.length; b++) {
        var c = a[b];
        if (1 === c.nodeType)
            return c;
    } }
    function Ra(a, b, c) { t(b, function (b) { a.addClass(b, c); }); }
    function Sa(a, b, c) { t(b, function (b) { a.removeClass(b, c); }); }
    function X(a) { return function (b, c) { c.addClass && (Ra(a, b, c.addClass), c.addClass = null); c.removeClass && (Sa(a, b, c.removeClass), c.removeClass = null); }; }
    function oa(a) {
        a = a || {};
        if (!a.$$prepared) {
            var b = a.domOperation ||
                O;
            a.domOperation = function () { a.$$domOperationFired = !0; b(); b = O; };
            a.$$prepared = !0;
        }
        return a;
    }
    function ha(a, b) { Ha(a, b); Ia(a, b); }
    function Ha(a, b) { b.from && (a.css(b.from), b.from = null); }
    function Ia(a, b) { b.to && (a.css(b.to), b.to = null); }
    function T(a, b, c) {
        var d = b.options || {};
        c = c.options || {};
        var e = (d.addClass || "") + " " + (c.addClass || ""), f = (d.removeClass || "") + " " + (c.removeClass || "");
        a = Ta(a.attr("class"), e, f);
        c.preparationClasses && (d.preparationClasses = ca(c.preparationClasses, d.preparationClasses), delete c.preparationClasses);
        e = d.domOperation !== O ? d.domOperation : null;
        va(d, c);
        e && (d.domOperation = e);
        d.addClass = a.addClass ? a.addClass : null;
        d.removeClass = a.removeClass ? a.removeClass : null;
        b.addClass = d.addClass;
        b.removeClass = d.removeClass;
        return d;
    }
    function Ta(a, b, c) {
        function d(a) { C(a) && (a = a.split(" ")); var b = {}; t(a, function (a) { a.length && (b[a] = !0); }); return b; }
        var e = {};
        a = d(a);
        b = d(b);
        t(b, function (a, b) { e[b] = 1; });
        c = d(c);
        t(c, function (a, b) { e[b] = 1 === e[b] ? null : -1; });
        var f = { addClass: "", removeClass: "" };
        t(e, function (b, c) {
            var d, e;
            1 === b ? (d = "addClass",
                e = !a[c] || a[c + "-remove"]) : -1 === b && (d = "removeClass", e = a[c] || a[c + "-add"]);
            e && (f[d].length && (f[d] += " "), f[d] += c);
        });
        return f;
    }
    function J(a) { return a instanceof A ? a[0] : a; }
    function Ua(a, b, c) { var d = ""; b && (d = W(b, "ng-", !0)); c.addClass && (d = ca(d, W(c.addClass, "-add"))); c.removeClass && (d = ca(d, W(c.removeClass, "-remove"))); d.length && (c.preparationClasses = d, a.addClass(d)); }
    function pa(a, b) { var c = b ? "-" + b + "s" : ""; ka(a, [la, c]); return [la, c]; }
    function wa(a, b) { var c = b ? "paused" : "", d = Y + "PlayState"; ka(a, [d, c]); return [d, c]; }
    function ka(a, b) { a.style[b[0]] = b[1]; }
    function ca(a, b) { return a ? b ? a + " " + b : a : b; }
    function Ja(a, b, c) { var d = Object.create(null), e = a.getComputedStyle(b) || {}; t(c, function (a, b) { var c = e[a]; if (c) {
        var l = c.charAt(0);
        if ("-" === l || "+" === l || 0 <= l)
            c = Va(c);
        0 === c && (c = null);
        d[b] = c;
    } }); return d; }
    function Va(a) { var b = 0; a = a.split(/\s*,\s*/); t(a, function (a) { "s" === a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1)); a = parseFloat(a) || 0; b = b ? Math.max(a, b) : a; }); return b; }
    function xa(a) { return 0 === a || null != a; }
    function Ka(a, b) {
        var c = Q, d = a + "s";
        b ? c += "Duration" :
            d += " linear all";
        return [c, d];
    }
    function La() { var a = Object.create(null); return { flush: function () { a = Object.create(null); }, count: function (b) { return (b = a[b]) ? b.total : 0; }, get: function (b) { return (b = a[b]) && b.value; }, put: function (b, c) { a[b] ? a[b].total++ : a[b] = { total: 1, value: c }; } }; }
    function Ma(a, b, c) { t(c, function (c) { a[c] = ya(a[c]) ? a[c] : b.style.getPropertyValue(c); }); }
    var Q, za, Y, Aa;
    void 0 === S.ontransitionend && void 0 !== S.onwebkittransitionend ? (Q = "WebkitTransition", za = "webkitTransitionEnd transitionend") : (Q = "transition", za =
        "transitionend");
    void 0 === S.onanimationend && void 0 !== S.onwebkitanimationend ? (Y = "WebkitAnimation", Aa = "webkitAnimationEnd animationend") : (Y = "animation", Aa = "animationend");
    var qa = Y + "Delay", Ba = Y + "Duration", la = Q + "Delay", Na = Q + "Duration", Pa = q.$$minErr("ng"), Wa = { transitionDuration: Na, transitionDelay: la, transitionProperty: Q + "Property", animationDuration: Ba, animationDelay: qa, animationIterationCount: Y + "IterationCount" }, Xa = { transitionDuration: Na, transitionDelay: la, animationDuration: Ba, animationDelay: qa }, Ca, va, t, V, ya, Z, Da, ra, C, P, A, O;
    q.module("ngAnimate", [], function () { O = q.noop; Ca = q.copy; va = q.extend; A = q.element; t = q.forEach; V = q.isArray; C = q.isString; ra = q.isObject; P = q.isUndefined; ya = q.isDefined; Da = q.isFunction; Z = q.isElement; }).info({ angularVersion: "1.6.10" }).directive("ngAnimateSwap", ["$animate", "$rootScope", function (a, b) {
            return { restrict: "A", transclude: "element", terminal: !0, priority: 600, link: function (b, d, e, f, n) {
                    var G, l;
                    b.$watchCollection(e.ngAnimateSwap || e["for"], function (e) {
                        G && a.leave(G);
                        l && (l.$destroy(), l =
                            null);
                        if (e || 0 === e)
                            l = b.$new(), n(l, function (b) { G = b; a.enter(b, null, d); });
                    });
                } };
        }]).directive("ngAnimateChildren", ["$interpolate", function (a) { return { link: function (b, c, d) { function e(a) { c.data("$$ngAnimateChildren", "on" === a || "true" === a); } var f = d.ngAnimateChildren; C(f) && 0 === f.length ? c.data("$$ngAnimateChildren", !0) : (e(a(f)(b)), d.$observe("ngAnimateChildren", e)); } }; }]).factory("$$rAFScheduler", ["$$rAF", function (a) {
            function b(a) { d = d.concat(a); c(); }
            function c() {
                if (d.length) {
                    for (var b = d.shift(), n = 0; n < b.length; n++)
                        b[n]();
                    e || a(function () { e || c(); });
                }
            }
            var d, e;
            d = b.queue = [];
            b.waitUntilQuiet = function (b) { e && e(); e = a(function () { e = null; b(); c(); }); };
            return b;
        }]).provider("$$animateQueue", ["$animateProvider", function (a) {
            function b(a) { if (!a)
                return null; a = a.split(" "); var b = Object.create(null); t(a, function (a) { b[a] = !0; }); return b; }
            function c(a, c) { if (a && c) {
                var d = b(c);
                return a.split(" ").some(function (a) { return d[a]; });
            } }
            function d(a, b, c) { return f[a].some(function (a) { return a(b, c); }); }
            function e(a, b) {
                var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass ||
                    "").length;
                return b ? c && d : c || d;
            }
            var f = this.rules = { skip: [], cancel: [], join: [] };
            f.join.push(function (a, b) { return !a.structural && e(a); });
            f.skip.push(function (a, b) { return !a.structural && !e(a); });
            f.skip.push(function (a, b) { return "leave" === b.event && a.structural; });
            f.skip.push(function (a, b) { return b.structural && 2 === b.state && !a.structural; });
            f.cancel.push(function (a, b) { return b.structural && a.structural; });
            f.cancel.push(function (a, b) { return 2 === b.state && a.structural; });
            f.cancel.push(function (a, b) {
                if (b.structural)
                    return !1;
                var d = a.addClass, e = a.removeClass, f = b.addClass, sa = b.removeClass;
                return P(d) && P(e) || P(f) && P(sa) ? !1 : c(d, sa) || c(e, f);
            });
            this.$get = ["$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function (b, c, f, s, y, sa, da, v, E, g, M) {
                    function x() { var a = !1; return function (b) { a ? b() : c.$$postDigest(function () { a = !0; b(); }); }; }
                    function H(a, b, c) {
                        var h = [], d = k[c];
                        d && t(d, function (d) {
                            u.call(d.node, b) ? h.push(d.callback) : "leave" === c &&
                                u.call(d.node, a) && h.push(d.callback);
                        });
                        return h;
                    }
                    function I(a, b, c) { var h = ua(b); return a.filter(function (a) { return !(a.node === h && (!c || a.callback === c)); }); }
                    function K(a, k, w) {
                        function K(a, c, h, k) { s(function () { var a = H(na, p, c); a.length ? b(function () { t(a, function (a) { a(f, h, k); }); "close" !== h || p.parentNode || ba.off(p); }) : "close" !== h || p.parentNode || ba.off(p); }); a.progress(c, h, k); }
                        function I(a) {
                            var b = f, c = g;
                            c.preparationClasses && (b.removeClass(c.preparationClasses), c.preparationClasses = null);
                            c.activeClasses && (b.removeClass(c.activeClasses),
                                c.activeClasses = null);
                            Oa(f, g);
                            ha(f, g);
                            g.domOperation();
                            l.complete(!a);
                        }
                        var g = Ca(w), f = Ga(a), p = J(f), na = p && p.parentNode, g = oa(g), l = new da, s = x();
                        V(g.addClass) && (g.addClass = g.addClass.join(" "));
                        g.addClass && !C(g.addClass) && (g.addClass = null);
                        V(g.removeClass) && (g.removeClass = g.removeClass.join(" "));
                        g.removeClass && !C(g.removeClass) && (g.removeClass = null);
                        g.from && !ra(g.from) && (g.from = null);
                        g.to && !ra(g.to) && (g.to = null);
                        if (!(h && p && Ya(p, k, w) && D(p, g)))
                            return I(), l;
                        var v = 0 <= ["enter", "move", "leave"].indexOf(k), u = M(), y = u || ga.get(p);
                        w = !y && z.get(p) || {};
                        var E = !!w.state;
                        y || E && 1 === w.state || (y = !L(p, na, k));
                        if (y)
                            return u && K(l, k, "start"), I(), u && K(l, k, "close"), l;
                        v && ta(p);
                        u = { structural: v, element: f, event: k, addClass: g.addClass, removeClass: g.removeClass, close: I, options: g, runner: l };
                        if (E) {
                            if (d("skip", u, w)) {
                                if (2 === w.state)
                                    return I(), l;
                                T(f, w, u);
                                return w.runner;
                            }
                            if (d("cancel", u, w))
                                if (2 === w.state)
                                    w.runner.end();
                                else if (w.structural)
                                    w.close();
                                else
                                    return T(f, w, u), w.runner;
                            else if (d("join", u, w))
                                if (2 === w.state)
                                    T(f, u, {});
                                else
                                    return Ua(f, v ? k : null, g), k = u.event = w.event, g = T(f, w, u), w.runner;
                        }
                        else
                            T(f, u, {});
                        (E = u.structural) || (E = "animate" === u.event && 0 < Object.keys(u.options.to || {}).length || e(u));
                        if (!E)
                            return I(), m(p), l;
                        var q = (w.counter || 0) + 1;
                        u.counter = q;
                        F(p, 1, u);
                        c.$$postDigest(function () {
                            f = Ga(a);
                            var b = z.get(p), c = !b, b = b || {}, h = 0 < (f.parent() || []).length && ("animate" === b.event || b.structural || e(b));
                            if (c || b.counter !== q || !h) {
                                c && (Oa(f, g), ha(f, g));
                                if (c || v && b.event !== k)
                                    g.domOperation(), l.end();
                                h || m(p);
                            }
                            else
                                k = !b.structural && e(b, !0) ? "setClass" : b.event,
                                    F(p, 2), b = sa(f, k, b.options), l.setHost(b), K(l, k, "start", {}), b.done(function (a) { I(!a); (a = z.get(p)) && a.counter === q && m(p); K(l, k, "close", {}); });
                        });
                        return l;
                    }
                    function ta(a) { a = a.querySelectorAll("[data-ng-animate]"); t(a, function (a) { var b = parseInt(a.getAttribute("data-ng-animate"), 10), c = z.get(a); if (c)
                        switch (b) {
                            case 2: c.runner.end();
                            case 1: z.delete(a);
                        } }); }
                    function m(a) { a.removeAttribute("data-ng-animate"); z.delete(a); }
                    function L(a, b, c) {
                        c = s[0].body;
                        var h = J(f), k = a === c || "HTML" === a.nodeName, d = a === h, g = !1, e = ga.get(a), p;
                        for ((a = A.data(a, "$ngAnimatePin")) && (b = J(a)); b;) {
                            d || (d = b === h);
                            if (1 !== b.nodeType)
                                break;
                            a = z.get(b) || {};
                            if (!g) {
                                var H = ga.get(b);
                                if (!0 === H && !1 !== e) {
                                    e = !0;
                                    break;
                                }
                                else
                                    !1 === H && (e = !1);
                                g = a.structural;
                            }
                            if (P(p) || !0 === p)
                                a = A.data(b, "$$ngAnimateChildren"), ya(a) && (p = a);
                            if (g && !1 === p)
                                break;
                            k || (k = b === c);
                            if (k && d)
                                break;
                            if (!d && (a = A.data(b, "$ngAnimatePin"))) {
                                b = J(a);
                                continue;
                            }
                            b = b.parentNode;
                        }
                        return (!g || p) && !0 !== e && d && k;
                    }
                    function F(a, b, c) { c = c || {}; c.state = b; a.setAttribute("data-ng-animate", b); c = (b = z.get(a)) ? va(b, c) : c; z.set(a, c); }
                    var z = new y, ga = new y, h = null, p = c.$watch(function () { return 0 === v.totalPendingRequests; }, function (a) { a && (p(), c.$$postDigest(function () { c.$$postDigest(function () { null === h && (h = !0); }); })); }), k = Object.create(null);
                    y = a.customFilter();
                    var na = a.classNameFilter();
                    g = function () { return !0; };
                    var Ya = y || g, D = na ? function (a, b) { var c = [a.getAttribute("class"), b.addClass, b.removeClass].join(" "); return na.test(c); } : g, Oa = X(E), u = S.Node.prototype.contains || function (a) { return this === a || !!(this.compareDocumentPosition(a) & 16); }, ba = { on: function (a, b, c) { var h = ua(b); k[a] = k[a] || []; k[a].push({ node: h, callback: c }); A(b).on("$destroy", function () { z.get(h) || ba.off(a, b, c); }); }, off: function (a, b, c) { if (1 !== arguments.length || C(arguments[0])) {
                            var h = k[a];
                            h && (k[a] = 1 === arguments.length ? null : I(h, b, c));
                        }
                        else
                            for (h in b = arguments[0], k)
                                k[h] = I(k[h], b); }, pin: function (a, b) { Ea(Z(a), "element", "not an element"); Ea(Z(b), "parentElement", "not an element"); a.data("$ngAnimatePin", b); }, push: function (a, b, c, h) { c = c || {}; c.domOperation = h; return K(a, b, c); }, enabled: function (a, b) {
                            var c = arguments.length;
                            if (0 === c)
                                b = !!h;
                            else if (Z(a)) {
                                var k = J(a);
                                1 === c ? b = !ga.get(k) : ga.set(k, !b);
                            }
                            else
                                b = h = !!a;
                            return b;
                        } };
                    return ba;
                }];
        }]).provider("$$animation", ["$animateProvider", function (a) {
            var b = this.drivers = [];
            this.$get = ["$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function (a, d, e, f, n, G) {
                    function l(a) {
                        function b(a) {
                            if (a.processed)
                                return a;
                            a.processed = !0;
                            var d = a.domNode, e = d.parentNode;
                            g.set(d, a);
                            for (var f; e;) {
                                if (f = g.get(e)) {
                                    f.processed || (f = b(f));
                                    break;
                                }
                                e = e.parentNode;
                            }
                            (f || c).children.push(a);
                            return a;
                        }
                        var c = { children: [] }, d, g = new n;
                        for (d = 0; d < a.length; d++) {
                            var e = a[d];
                            g.set(e.domNode, a[d] = { domNode: e.domNode, fn: e.fn, children: [] });
                        }
                        for (d = 0; d < a.length; d++)
                            b(a[d]);
                        return function (a) { var b = [], c = [], d; for (d = 0; d < a.children.length; d++)
                            c.push(a.children[d]); a = c.length; var g = 0, e = []; for (d = 0; d < c.length; d++) {
                            var f = c[d];
                            0 >= a && (a = g, g = 0, b.push(e), e = []);
                            e.push(f.fn);
                            f.children.forEach(function (a) { g++; c.push(a); });
                            a--;
                        } e.length && b.push(e); return b; }(c);
                    }
                    var s = [], y = X(a);
                    return function (n, q, v) {
                        function E(a) {
                            a = a.hasAttribute("ng-animate-ref") ?
                                [a] : a.querySelectorAll("[ng-animate-ref]");
                            var b = [];
                            t(a, function (a) { var c = a.getAttribute("ng-animate-ref"); c && c.length && b.push(a); });
                            return b;
                        }
                        function g(a) {
                            var b = [], c = {};
                            t(a, function (a, d) { var k = J(a.element), g = 0 <= ["enter", "move"].indexOf(a.event), k = a.structural ? E(k) : []; if (k.length) {
                                var e = g ? "to" : "from";
                                t(k, function (a) { var b = a.getAttribute("ng-animate-ref"); c[b] = c[b] || {}; c[b][e] = { animationID: d, element: A(a) }; });
                            }
                            else
                                b.push(a); });
                            var d = {}, g = {};
                            t(c, function (c, e) {
                                var f = c.from, p = c.to;
                                if (f && p) {
                                    var H = a[f.animationID], z = a[p.animationID], m = f.animationID.toString();
                                    if (!g[m]) {
                                        var l = g[m] = { structural: !0, beforeStart: function () { H.beforeStart(); z.beforeStart(); }, close: function () { H.close(); z.close(); }, classes: M(H.classes, z.classes), from: H, to: z, anchors: [] };
                                        l.classes.length ? b.push(l) : (b.push(H), b.push(z));
                                    }
                                    g[m].anchors.push({ out: f.element, "in": p.element });
                                }
                                else
                                    f = f ? f.animationID : p.animationID, p = f.toString(), d[p] || (d[p] = !0, b.push(a[f]));
                            });
                            return b;
                        }
                        function M(a, b) {
                            a = a.split(" ");
                            b = b.split(" ");
                            for (var c = [], d = 0; d < a.length; d++) {
                                var g = a[d];
                                if ("ng-" !== g.substring(0, 3))
                                    for (var e = 0; e < b.length; e++)
                                        if (g === b[e]) {
                                            c.push(g);
                                            break;
                                        }
                            }
                            return c.join(" ");
                        }
                        function x(a) { for (var c = b.length - 1; 0 <= c; c--) {
                            var d = e.get(b[c])(a);
                            if (d)
                                return d;
                        } }
                        function H(a, b) { function c(a) { (a = a.data("$$animationRunner")) && a.setHost(b); } a.from && a.to ? (c(a.from.element), c(a.to.element)) : c(a.element); }
                        function I() { var a = n.data("$$animationRunner"); !a || "leave" === q && v.$$domOperationFired || a.end(); }
                        function K(b) {
                            n.off("$destroy", I);
                            n.removeData("$$animationRunner");
                            y(n, v);
                            ha(n, v);
                            v.domOperation();
                            F && a.removeClass(n, F);
                            n.removeClass("ng-animate");
                            m.complete(!b);
                        }
                        v = oa(v);
                        var ta = 0 <= ["enter", "move", "leave"].indexOf(q), m = new f({ end: function () { K(); }, cancel: function () { K(!0); } });
                        if (!b.length)
                            return K(), m;
                        n.data("$$animationRunner", m);
                        var L = Fa(n.attr("class"), Fa(v.addClass, v.removeClass)), F = v.tempClasses;
                        F && (L += " " + F, v.tempClasses = null);
                        var z;
                        ta && (z = "ng-" + q + "-prepare", a.addClass(n, z));
                        s.push({ element: n, classes: L, event: q, structural: ta, options: v, beforeStart: function () {
                                n.addClass("ng-animate");
                                F && a.addClass(n, F);
                                z && (a.removeClass(n, z), z = null);
                            }, close: K });
                        n.on("$destroy", I);
                        if (1 < s.length)
                            return m;
                        d.$$postDigest(function () {
                            var a = [];
                            t(s, function (b) { b.element.data("$$animationRunner") ? a.push(b) : b.close(); });
                            s.length = 0;
                            var b = g(a), c = [];
                            t(b, function (a) {
                                c.push({ domNode: J(a.from ? a.from.element : a.element), fn: function () {
                                        a.beforeStart();
                                        var b, c = a.close;
                                        if ((a.anchors ? a.from.element || a.to.element : a.element).data("$$animationRunner")) {
                                            var d = x(a);
                                            d && (b = d.start);
                                        }
                                        b ? (b = b(), b.done(function (a) { c(!a); }), H(a, b)) :
                                            c();
                                    } });
                            });
                            G(l(c));
                        });
                        return m;
                    };
                }];
        }]).provider("$animateCss", ["$animateProvider", function (a) {
            var b = La(), c = La();
            this.$get = ["$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function (a, e, f, n, G, l, s, y) {
                    function q(a, b) { var c = a.parentNode; return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++M)) + "-" + a.getAttribute("class") + "-" + b; }
                    function da(g, f, l, n) {
                        var m;
                        0 < b.count(l) && (m = c.get(l), m || (f = W(f, "-stagger"), e.addClass(g, f), m = Ja(a, g, n), m.animationDuration =
                            Math.max(m.animationDuration, 0), m.transitionDuration = Math.max(m.transitionDuration, 0), e.removeClass(g, f), c.put(l, m)));
                        return m || {};
                    }
                    function v(a) { x.push(a); s.waitUntilQuiet(function () { b.flush(); c.flush(); for (var a = G(), d = 0; d < x.length; d++)
                        x[d](a); x.length = 0; }); }
                    function E(c, g, e) {
                        g = b.get(e);
                        g || (g = Ja(a, c, Wa), "infinite" === g.animationIterationCount && (g.animationIterationCount = 1));
                        b.put(e, g);
                        c = g;
                        e = c.animationDelay;
                        g = c.transitionDelay;
                        c.maxDelay = e && g ? Math.max(e, g) : e || g;
                        c.maxDuration = Math.max(c.animationDuration *
                            c.animationIterationCount, c.transitionDuration);
                        return c;
                    }
                    var g = X(e), M = 0, x = [];
                    return function (a, c) {
                        function d() { m(); }
                        function s() { m(!0); }
                        function m(b) {
                            if (!(M || ba && u)) {
                                M = !0;
                                u = !1;
                                h.$$skipPreparationClasses || e.removeClass(a, fa);
                                e.removeClass(a, ca);
                                wa(k, !1);
                                pa(k, !1);
                                t(x, function (a) { k.style[a[0]] = ""; });
                                g(a, h);
                                ha(a, h);
                                Object.keys(p).length && t(p, function (a, b) { a ? k.style.setProperty(b, a) : k.style.removeProperty(b); });
                                if (h.onDone)
                                    h.onDone();
                                ea && ea.length && a.off(ea.join(" "), z);
                                var c = a.data("$$animateCss");
                                c && (n.cancel(c[0].timer),
                                    a.removeData("$$animateCss"));
                                A && A.complete(!b);
                            }
                        }
                        function L(a) { r.blockTransition && pa(k, a); r.blockKeyframeAnimation && wa(k, !!a); }
                        function F() { A = new f({ end: d, cancel: s }); v(O); m(); return { $$willAnimate: !1, start: function () { return A; }, end: d }; }
                        function z(a) { a.stopPropagation(); var b = a.originalEvent || a; b.target === k && (a = b.$manualTimeStamp || Date.now(), b = parseFloat(b.elapsedTime.toFixed(3)), Math.max(a - T, 0) >= P && b >= N && (ba = !0, m())); }
                        function ga() {
                            function b() {
                                if (!M) {
                                    L(!1);
                                    t(x, function (a) { k.style[a[0]] = a[1]; });
                                    g(a, h);
                                    e.addClass(a, ca);
                                    if (r.recalculateTimingStyles) {
                                        ma = k.getAttribute("class") + " " + fa;
                                        ja = q(k, ma);
                                        B = E(k, ma, ja);
                                        $ = B.maxDelay;
                                        w = Math.max($, 0);
                                        N = B.maxDuration;
                                        if (0 === N) {
                                            m();
                                            return;
                                        }
                                        r.hasTransitions = 0 < B.transitionDuration;
                                        r.hasAnimations = 0 < B.animationDuration;
                                    }
                                    r.applyAnimationDelay && ($ = "boolean" !== typeof h.delay && xa(h.delay) ? parseFloat(h.delay) : $, w = Math.max($, 0), B.animationDelay = $, aa = [qa, $ + "s"], x.push(aa), k.style[aa[0]] = aa[1]);
                                    P = 1E3 * w;
                                    S = 1E3 * N;
                                    if (h.easing) {
                                        var d, f = h.easing;
                                        r.hasTransitions && (d = Q + "TimingFunction",
                                            x.push([d, f]), k.style[d] = f);
                                        r.hasAnimations && (d = Y + "TimingFunction", x.push([d, f]), k.style[d] = f);
                                    }
                                    B.transitionDuration && ea.push(za);
                                    B.animationDuration && ea.push(Aa);
                                    T = Date.now();
                                    var l = P + 1.5 * S;
                                    d = T + l;
                                    var f = a.data("$$animateCss") || [], F = !0;
                                    if (f.length) {
                                        var s = f[0];
                                        (F = d > s.expectedEndTime) ? n.cancel(s.timer) : f.push(m);
                                    }
                                    F && (l = n(c, l, !1), f[0] = { timer: l, expectedEndTime: d }, f.push(m), a.data("$$animateCss", f));
                                    if (ea.length)
                                        a.on(ea.join(" "), z);
                                    h.to && (h.cleanupStyles && Ma(p, k, Object.keys(h.to)), Ia(a, h));
                                }
                            }
                            function c() {
                                var b = a.data("$$animateCss");
                                if (b) {
                                    for (var d = 1; d < b.length; d++)
                                        b[d]();
                                    a.removeData("$$animateCss");
                                }
                            }
                            if (!M)
                                if (k.parentNode) {
                                    var d = function (a) { if (ba)
                                        u && a && (u = !1, m());
                                    else if (u = !a, B.animationDuration)
                                        if (a = wa(k, u), u)
                                            x.push(a);
                                        else {
                                            var b = x, c = b.indexOf(a);
                                            0 <= a && b.splice(c, 1);
                                        } }, f = 0 < Z && (B.transitionDuration && 0 === U.transitionDuration || B.animationDuration && 0 === U.animationDuration) && Math.max(U.animationDelay, U.transitionDelay);
                                    f ? n(b, Math.floor(f * Z * 1E3), !1) : b();
                                    C.resume = function () { d(!0); };
                                    C.pause = function () { d(!1); };
                                }
                                else
                                    m();
                        }
                        var h = c || {};
                        h.$$prepared || (h = oa(Ca(h)));
                        var p = {}, k = J(a);
                        if (!k || !k.parentNode || !y.enabled())
                            return F();
                        var x = [], G = a.attr("class"), D = Qa(h), M, u, ba, A, C, w, P, N, S, T, ea = [];
                        if (0 === h.duration || !l.animations && !l.transitions)
                            return F();
                        var ia = h.event && V(h.event) ? h.event.join(" ") : h.event, X = "", R = "";
                        ia && h.structural ? X = W(ia, "ng-", !0) : ia && (X = ia);
                        h.addClass && (R += W(h.addClass, "-add"));
                        h.removeClass && (R.length && (R += " "), R += W(h.removeClass, "-remove"));
                        h.applyClassesEarly && R.length && g(a, h);
                        var fa = [X, R].join(" ").trim(), ma = G + " " + fa, ca = W(fa, "-active"), G = D.to && 0 < Object.keys(D.to).length;
                        if (!(0 < (h.keyframeStyle || "").length || G || fa))
                            return F();
                        var ja, U;
                        0 < h.stagger ? (D = parseFloat(h.stagger), U = { transitionDelay: D, animationDelay: D, transitionDuration: 0, animationDuration: 0 }) : (ja = q(k, ma), U = da(k, fa, ja, Xa));
                        h.$$skipPreparationClasses || e.addClass(a, fa);
                        h.transitionStyle && (D = [Q, h.transitionStyle], ka(k, D), x.push(D));
                        0 <= h.duration && (D = 0 < k.style[Q].length, D = Ka(h.duration, D), ka(k, D), x.push(D));
                        h.keyframeStyle && (D = [Y, h.keyframeStyle],
                            ka(k, D), x.push(D));
                        var Z = U ? 0 <= h.staggerIndex ? h.staggerIndex : b.count(ja) : 0;
                        (ia = 0 === Z) && !h.skipBlocking && pa(k, 9999);
                        var B = E(k, ma, ja), $ = B.maxDelay;
                        w = Math.max($, 0);
                        N = B.maxDuration;
                        var r = {};
                        r.hasTransitions = 0 < B.transitionDuration;
                        r.hasAnimations = 0 < B.animationDuration;
                        r.hasTransitionAll = r.hasTransitions && "all" === B.transitionProperty;
                        r.applyTransitionDuration = G && (r.hasTransitions && !r.hasTransitionAll || r.hasAnimations && !r.hasTransitions);
                        r.applyAnimationDuration = h.duration && r.hasAnimations;
                        r.applyTransitionDelay =
                            xa(h.delay) && (r.applyTransitionDuration || r.hasTransitions);
                        r.applyAnimationDelay = xa(h.delay) && r.hasAnimations;
                        r.recalculateTimingStyles = 0 < R.length;
                        if (r.applyTransitionDuration || r.applyAnimationDuration)
                            N = h.duration ? parseFloat(h.duration) : N, r.applyTransitionDuration && (r.hasTransitions = !0, B.transitionDuration = N, D = 0 < k.style[Q + "Property"].length, x.push(Ka(N, D))), r.applyAnimationDuration && (r.hasAnimations = !0, B.animationDuration = N, x.push([Ba, N + "s"]));
                        if (0 === N && !r.recalculateTimingStyles)
                            return F();
                        if (null !=
                            h.delay) {
                            var aa;
                            "boolean" !== typeof h.delay && (aa = parseFloat(h.delay), w = Math.max(aa, 0));
                            r.applyTransitionDelay && x.push([la, aa + "s"]);
                            r.applyAnimationDelay && x.push([qa, aa + "s"]);
                        }
                        null == h.duration && 0 < B.transitionDuration && (r.recalculateTimingStyles = r.recalculateTimingStyles || ia);
                        P = 1E3 * w;
                        S = 1E3 * N;
                        h.skipBlocking || (r.blockTransition = 0 < B.transitionDuration, r.blockKeyframeAnimation = 0 < B.animationDuration && 0 < U.animationDelay && 0 === U.animationDuration);
                        h.from && (h.cleanupStyles && Ma(p, k, Object.keys(h.from)), Ha(a, h));
                        r.blockTransition || r.blockKeyframeAnimation ? L(N) : h.skipBlocking || pa(k, !1);
                        return { $$willAnimate: !0, end: d, start: function () { if (!M)
                                return C = { end: d, cancel: s, resume: null, pause: null }, A = new f(C), v(ga), A; } };
                    };
                }];
        }]).provider("$$animateCssDriver", ["$$animationProvider", function (a) {
            a.drivers.push("$$animateCssDriver");
            this.$get = ["$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function (a, c, d, e, f, n, G) {
                    function l(a) { return a.replace(/\bng-\S+\b/g, ""); }
                    function s(a, b) {
                        C(a) &&
                            (a = a.split(" "));
                        C(b) && (b = b.split(" "));
                        return a.filter(function (a) { return -1 === b.indexOf(a); }).join(" ");
                    }
                    function y(c, f, e) {
                        function n(a) { var b = {}, c = J(a).getBoundingClientRect(); t(["width", "height", "top", "left"], function (a) { var d = c[a]; switch (a) {
                            case "top":
                                d += v.scrollTop;
                                break;
                            case "left": d += v.scrollLeft;
                        } b[a] = Math.floor(d) + "px"; }); return b; }
                        function G() {
                            var c = l(e.attr("class") || ""), d = s(c, m), c = s(m, c), d = a(y, { to: n(e), addClass: "ng-anchor-in " + d, removeClass: "ng-anchor-out " + c, delay: !0 });
                            return d.$$willAnimate ?
                                d : null;
                        }
                        function q() { y.remove(); f.removeClass("ng-animate-shim"); e.removeClass("ng-animate-shim"); }
                        var y = A(J(f).cloneNode(!0)), m = l(y.attr("class") || "");
                        f.addClass("ng-animate-shim");
                        e.addClass("ng-animate-shim");
                        y.addClass("ng-anchor");
                        E.append(y);
                        var L;
                        c = function () { var c = a(y, { addClass: "ng-anchor-out", delay: !0, from: n(f) }); return c.$$willAnimate ? c : null; }();
                        if (!c && (L = G(), !L))
                            return q();
                        var F = c || L;
                        return { start: function () {
                                function a() { c && c.end(); }
                                var b, c = F.start();
                                c.done(function () {
                                    c = null;
                                    if (!L && (L = G()))
                                        return c =
                                            L.start(), c.done(function () { c = null; q(); b.complete(); }), c;
                                    q();
                                    b.complete();
                                });
                                return b = new d({ end: a, cancel: a });
                            } };
                    }
                    function q(a, b, c, f) { var e = da(a, O), l = da(b, O), n = []; t(f, function (a) { (a = y(c, a.out, a["in"])) && n.push(a); }); if (e || l || 0 !== n.length)
                        return { start: function () { function a() { t(b, function (a) { a.end(); }); } var b = []; e && b.push(e.start()); l && b.push(l.start()); t(n, function (a) { b.push(a.start()); }); var c = new d({ end: a, cancel: a }); d.all(b, function (a) { c.complete(a); }); return c; } }; }
                    function da(c) {
                        var d = c.element, e = c.options ||
                            {};
                        c.structural && (e.event = c.event, e.structural = !0, e.applyClassesEarly = !0, "leave" === c.event && (e.onDone = e.domOperation));
                        e.preparationClasses && (e.event = ca(e.event, e.preparationClasses));
                        c = a(d, e);
                        return c.$$willAnimate ? c : null;
                    }
                    if (!f.animations && !f.transitions)
                        return O;
                    var v = G[0].body;
                    c = J(e);
                    var E = A(c.parentNode && 11 === c.parentNode.nodeType || v.contains(c) ? c : v);
                    return function (a) { return a.from && a.to ? q(a.from, a.to, a.classes, a.anchors) : da(a); };
                }];
        }]).provider("$$animateJs", ["$animateProvider", function (a) {
            this.$get =
                ["$injector", "$$AnimateRunner", "$$jqLite", function (b, c, d) {
                        function e(c) { c = V(c) ? c : c.split(" "); for (var d = [], e = {}, f = 0; f < c.length; f++) {
                            var y = c[f], q = a.$$registeredAnimations[y];
                            q && !e[y] && (d.push(b.get(q)), e[y] = !0);
                        } return d; }
                        var f = X(d);
                        return function (a, b, d, s) {
                            function q() { s.domOperation(); f(a, s); }
                            function A(a, b, d, e, f) {
                                switch (d) {
                                    case "animate":
                                        b = [b, e.from, e.to, f];
                                        break;
                                    case "setClass":
                                        b = [b, g, M, f];
                                        break;
                                    case "addClass":
                                        b = [b, g, f];
                                        break;
                                    case "removeClass":
                                        b = [b, M, f];
                                        break;
                                    default: b = [b, f];
                                }
                                b.push(e);
                                if (a = a.apply(a, b))
                                    if (Da(a.start) && (a = a.start()), a instanceof c)
                                        a.done(f);
                                    else if (Da(a))
                                        return a;
                                return O;
                            }
                            function C(a, b, d, e, f) { var g = []; t(e, function (e) { var l = e[f]; l && g.push(function () { var e, f, h = !1, g = function (a) { h || (h = !0, (f || O)(a), e.complete(!a)); }; e = new c({ end: function () { g(); }, cancel: function () { g(!0); } }); f = A(l, a, b, d, function (a) { g(!1 === a); }); return e; }); }); return g; }
                            function v(a, b, d, e, f) {
                                var g = C(a, b, d, e, f);
                                if (0 === g.length) {
                                    var k, l;
                                    "beforeSetClass" === f ? (k = C(a, "removeClass", d, e, "beforeRemoveClass"), l = C(a, "addClass", d, e, "beforeAddClass")) :
                                        "setClass" === f && (k = C(a, "removeClass", d, e, "removeClass"), l = C(a, "addClass", d, e, "addClass"));
                                    k && (g = g.concat(k));
                                    l && (g = g.concat(l));
                                }
                                if (0 !== g.length)
                                    return function (a) { var b = []; g.length && t(g, function (a) { b.push(a()); }); b.length ? c.all(b, a) : a(); return function (a) { t(b, function (b) { a ? b.cancel() : b.end(); }); }; };
                            }
                            var E = !1;
                            3 === arguments.length && ra(d) && (s = d, d = null);
                            s = oa(s);
                            d || (d = a.attr("class") || "", s.addClass && (d += " " + s.addClass), s.removeClass && (d += " " + s.removeClass));
                            var g = s.addClass, M = s.removeClass, x = e(d), H, I;
                            if (x.length) {
                                var K, J;
                                "leave" === b ? (J = "leave", K = "afterLeave") : (J = "before" + b.charAt(0).toUpperCase() + b.substr(1), K = b);
                                "enter" !== b && "move" !== b && (H = v(a, b, s, x, J));
                                I = v(a, b, s, x, K);
                            }
                            if (H || I) {
                                var m;
                                return { $$willAnimate: !0, end: function () { m ? m.end() : (E = !0, q(), ha(a, s), m = new c, m.complete(!0)); return m; }, start: function () {
                                        function b(c) { E = !0; q(); ha(a, s); m.complete(c); }
                                        if (m)
                                            return m;
                                        m = new c;
                                        var d, e = [];
                                        H && e.push(function (a) { d = H(a); });
                                        e.length ? e.push(function (a) { q(); a(!0); }) : q();
                                        I && e.push(function (a) { d = I(a); });
                                        m.setHost({ end: function () {
                                                E || ((d ||
                                                    O)(void 0), b(void 0));
                                            }, cancel: function () { E || ((d || O)(!0), b(!0)); } });
                                        c.chain(e, b);
                                        return m;
                                    } };
                            }
                        };
                    }];
        }]).provider("$$animateJsDriver", ["$$animationProvider", function (a) {
            a.drivers.push("$$animateJsDriver");
            this.$get = ["$$animateJs", "$$AnimateRunner", function (a, c) {
                    function d(c) { return a(c.element, c.event, c.classes, c.options); }
                    return function (a) {
                        if (a.from && a.to) {
                            var b = d(a.from), n = d(a.to);
                            if (b || n)
                                return { start: function () {
                                        function a() { return function () { t(d, function (a) { a.end(); }); }; }
                                        var d = [];
                                        b && d.push(b.start());
                                        n &&
                                            d.push(n.start());
                                        c.all(d, function (a) { e.complete(a); });
                                        var e = new c({ end: a(), cancel: a() });
                                        return e;
                                    } };
                        }
                        else
                            return d(a);
                    };
                }];
        }]);
})(window, window.angular);
(function (x, p) {
    'use strict';
    function s(f, k) { var e = !1, a = !1; this.ngClickOverrideEnabled = function (b) { return p.isDefined(b) ? (b && !a && (a = !0, t.$$moduleName = "ngTouch", k.directive("ngClick", t), f.decorator("ngClickDirective", ["$delegate", function (a) { if (e)
            a.shift();
        else
            for (var b = a.length - 1; 0 <= b;) {
                if ("ngTouch" === a[b].$$moduleName) {
                    a.splice(b, 1);
                    break;
                }
                b--;
            } return a; }])), e = b, this) : e; }; this.$get = function () { return { ngClickOverrideEnabled: function () { return e; } }; }; }
    function v(f, k, e) {
        n.directive(f, ["$parse", "$swipe", function (a, b) { return function (l, u, g) { function h(c) { if (!d)
                return !1; var a = Math.abs(c.y - d.y); c = (c.x - d.x) * k; return r && 75 > a && 0 < c && 30 < c && .3 > a / c; } var m = a(g[f]), d, r, c = ["touch"]; p.isDefined(g.ngSwipeDisableMouse) || c.push("mouse"); b.bind(u, { start: function (c, a) { d = c; r = !0; }, cancel: function (c) { r = !1; }, end: function (c, d) { h(c) && l.$apply(function () { u.triggerHandler(e); m(l, { $event: d }); }); } }, c); }; }]);
    }
    var n = p.module("ngTouch", []);
    n.info({ angularVersion: "1.6.10" });
    n.provider("$touch", s);
    s.$inject = ["$provide", "$compileProvider"];
    n.factory("$swipe", [function () {
            function f(a) { a = a.originalEvent || a; var b = a.touches && a.touches.length ? a.touches : [a]; a = a.changedTouches && a.changedTouches[0] || b[0]; return { x: a.clientX, y: a.clientY }; }
            function k(a, b) { var l = []; p.forEach(a, function (a) { (a = e[a][b]) && l.push(a); }); return l.join(" "); }
            var e = { mouse: { start: "mousedown", move: "mousemove", end: "mouseup" }, touch: { start: "touchstart", move: "touchmove", end: "touchend", cancel: "touchcancel" }, pointer: { start: "pointerdown", move: "pointermove", end: "pointerup", cancel: "pointercancel" } };
            return { bind: function (a, b, l) { var e, g, h, m, d = !1; l = l || ["mouse", "touch", "pointer"]; a.on(k(l, "start"), function (c) { h = f(c); d = !0; g = e = 0; m = h; b.start && b.start(h, c); }); var r = k(l, "cancel"); if (r)
                    a.on(r, function (c) { d = !1; b.cancel && b.cancel(c); }); a.on(k(l, "move"), function (c) { if (d && h) {
                    var a = f(c);
                    e += Math.abs(a.x - m.x);
                    g += Math.abs(a.y - m.y);
                    m = a;
                    10 > e && 10 > g || (g > e ? (d = !1, b.cancel && b.cancel(c)) : (c.preventDefault(), b.move && b.move(a, c)));
                } }); a.on(k(l, "end"), function (c) { d && (d = !1, b.end && b.end(f(c), c)); }); } };
        }]);
    var t = ["$parse", "$timeout", "$rootElement", function (f, k, e) {
            function a(a, d, b) { for (var c = 0; c < a.length; c += 2) {
                var g = a[c + 1], e = b;
                if (25 > Math.abs(a[c] - d) && 25 > Math.abs(g - e))
                    return a.splice(c, c + 2), !0;
            } return !1; }
            function b(b) { if (!(2500 < Date.now() - u)) {
                var d = b.touches && b.touches.length ? b.touches : [b], e = d[0].clientX, d = d[0].clientY;
                if (!(1 > e && 1 > d || h && h[0] === e && h[1] === d)) {
                    h && (h = null);
                    var c = b.target;
                    "label" === p.lowercase(c.nodeName || c[0] && c[0].nodeName) && (h = [e, d]);
                    a(g, e, d) || (b.stopPropagation(), b.preventDefault(), b.target && b.target.blur && b.target.blur());
                }
            } }
            function l(a) {
                a =
                    a.touches && a.touches.length ? a.touches : [a];
                var b = a[0].clientX, e = a[0].clientY;
                g.push(b, e);
                k(function () { for (var a = 0; a < g.length; a += 2)
                    if (g[a] === b && g[a + 1] === e) {
                        g.splice(a, a + 2);
                        break;
                    } }, 2500, !1);
            }
            var u, g, h;
            return function (h, d, k) {
                var c = f(k.ngClick), n = !1, q, s, t, v;
                d.on("touchstart", function (a) { n = !0; q = a.target ? a.target : a.srcElement; 3 === q.nodeType && (q = q.parentNode); d.addClass("ng-click-active"); s = Date.now(); a = a.originalEvent || a; a = (a.touches && a.touches.length ? a.touches : [a])[0]; t = a.clientX; v = a.clientY; });
                d.on("touchcancel", function (a) { n = !1; d.removeClass("ng-click-active"); });
                d.on("touchend", function (c) {
                    var h = Date.now() - s, f = c.originalEvent || c, m = (f.changedTouches && f.changedTouches.length ? f.changedTouches : f.touches && f.touches.length ? f.touches : [f])[0], f = m.clientX, m = m.clientY, w = Math.sqrt(Math.pow(f - t, 2) + Math.pow(m - v, 2));
                    n && 750 > h && 12 > w && (g || (e[0].addEventListener("click", b, !0), e[0].addEventListener("touchstart", l, !0), g = []), u = Date.now(), a(g, f, m), q && q.blur(), p.isDefined(k.disabled) && !1 !== k.disabled || d.triggerHandler("click", [c]));
                    n = !1;
                    d.removeClass("ng-click-active");
                });
                d.onclick = function (a) { };
                d.on("click", function (a, b) { h.$apply(function () { c(h, { $event: b || a }); }); });
                d.on("mousedown", function (a) { d.addClass("ng-click-active"); });
                d.on("mousemove mouseup", function (a) { d.removeClass("ng-click-active"); });
            };
        }];
    v("ngSwipeLeft", -1, "swipeleft");
    v("ngSwipeRight", 1, "swiperight");
})(window, window.angular);
(function () {
    'use strict';
    function g(a, f) { f = f || Error; return function () { var d = arguments[0], e; e = "[" + (a ? a + ":" : "") + d + "] http://errors.angularjs.org/1.6.10/" + (a ? a + "/" : "") + d; for (d = 1; d < arguments.length; d++) {
        e = e + (1 == d ? "?" : "&") + "p" + (d - 1) + "=";
        var q = encodeURIComponent, b;
        b = arguments[d];
        b = "function" == typeof b ? b.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof b ? "undefined" : "string" != typeof b ? JSON.stringify(b) : b;
        e += q(b);
    } return new f(e); }; }
    (function (a) {
        function f(a, b, d) { return a[b] || (a[b] = d()); }
        var d = g("$injector"), e = g("ng");
        a = f(a, "angular", Object);
        a.$$minErr = a.$$minErr || g;
        return f(a, "module", function () {
            var a = {};
            return function (b, g, l) {
                var m = {};
                if ("hasOwnProperty" === b)
                    throw e("badname", "module");
                g && a.hasOwnProperty(b) && (a[b] = null);
                return f(a, b, function () {
                    function a(b, d, e, c) { c || (c = f); return function () { c[e || "push"]([b, d, arguments]); return h; }; }
                    function c(a, d, c) { c || (c = f); return function (f, e) { e && "function" === typeof e && (e.$$moduleName = b); c.push([a, d, arguments]); return h; }; }
                    if (!g)
                        throw d("nomod", b);
                    var f = [], k = [], n = [], p = a("$injector", "invoke", "push", k), h = { _invokeQueue: f, _configBlocks: k, _runBlocks: n, info: function (a) { if ("undefined" !== typeof a) {
                            if (null === a || "object" !== typeof a)
                                throw e("aobj", "value");
                            m = a;
                            return this;
                        } return m; }, requires: g, name: b, provider: c("$provide", "provider"), factory: c("$provide", "factory"), service: c("$provide", "service"), value: a("$provide", "value"), constant: a("$provide", "constant", "unshift"), decorator: c("$provide", "decorator", k), animation: c("$animateProvider", "register"), filter: c("$filterProvider", "register"), controller: c("$controllerProvider", "register"), directive: c("$compileProvider", "directive"), component: c("$compileProvider", "component"), config: p, run: function (a) { n.push(a); return this; } };
                    l && p(l);
                    return h;
                });
            };
        });
    })(window);
})(window);
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular')) :
        typeof define === 'function' && define.amd ? define(['exports', 'angular'], factory) :
            (factory((global['@uirouter/angularjs'] = {}), global.angular));
}(this, (function (exports, ng_from_import) {
    'use strict';
    var ng_from_global = angular;
    var ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;
    function curry(fn) {
        var initial_args = [].slice.apply(arguments, [1]);
        var func_args_length = fn.length;
        function curried(args) {
            if (args.length >= func_args_length)
                return fn.apply(null, args);
            return function () {
                return curried(args.concat([].slice.apply(arguments)));
            };
        }
        return curried(initial_args);
    }
    function compose() {
        var args = arguments;
        var start = args.length - 1;
        return function () {
            var i = start, result = args[start].apply(this, arguments);
            while (i--)
                result = args[i].call(this, result);
            return result;
        };
    }
    function pipe() {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        return compose.apply(null, [].slice.call(arguments).reverse());
    }
    var prop = function (name) { return function (obj) { return obj && obj[name]; }; };
    var propEq = curry(function (name, _val, obj) { return obj && obj[name] === _val; });
    var parse = function (name) { return pipe.apply(null, name.split('.').map(prop)); };
    var not = function (fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !fn.apply(null, args);
        };
    };
    function and(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) && fn2.apply(null, args);
        };
    }
    function or(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) || fn2.apply(null, args);
        };
    }
    var all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };
    var any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };
    var is = function (ctor) {
        return function (obj) {
            return (obj != null && obj.constructor === ctor) || obj instanceof ctor;
        };
    };
    var eq = function (value) { return function (other) { return value === other; }; };
    var val = function (v) { return function () { return v; }; };
    function invoke(fnName, args) {
        return function (obj) { return obj[fnName].apply(obj, args); };
    }
    function pattern(struct) {
        return function (x) {
            for (var i = 0; i < struct.length; i++) {
                if (struct[i][0](x))
                    return struct[i][1](x);
            }
        };
    }
    var Glob = (function () {
        function Glob(text) {
            this.text = text;
            this.glob = text.split('.');
            var regexpString = this.text
                .split('.')
                .map(function (seg) {
                if (seg === '**')
                    return '(?:|(?:\\.[^.]*)*)';
                if (seg === '*')
                    return '\\.[^.]*';
                return '\\.' + seg;
            })
                .join('');
            this.regexp = new RegExp('^' + regexpString + '$');
        }
        Glob.is = function (text) {
            return !!/[!,*]+/.exec(text);
        };
        Glob.fromString = function (text) {
            return Glob.is(text) ? new Glob(text) : null;
        };
        Glob.prototype.matches = function (name) {
            return this.regexp.test('.' + name);
        };
        return Glob;
    }());
    var StateObject = (function () {
        function StateObject(config) {
            return StateObject.create(config || {});
        }
        StateObject.create = function (stateDecl) {
            stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
            var state = inherit(inherit(stateDecl, StateObject.prototype));
            stateDecl.$$state = function () { return state; };
            state.self = stateDecl;
            state.__stateObjectCache = {
                nameGlob: Glob.fromString(state.name),
            };
            return state;
        };
        StateObject.prototype.is = function (ref) {
            return this === ref || this.self === ref || this.fqn() === ref;
        };
        StateObject.prototype.fqn = function () {
            if (!this.parent || !(this.parent instanceof this.constructor))
                return this.name;
            var name = this.parent.fqn();
            return name ? name + '.' + this.name : this.name;
        };
        StateObject.prototype.root = function () {
            return (this.parent && this.parent.root()) || this;
        };
        StateObject.prototype.parameters = function (opts) {
            opts = defaults(opts, { inherit: true, matchingKeys: null });
            var inherited = (opts.inherit && this.parent && this.parent.parameters()) || [];
            return inherited
                .concat(values(this.params))
                .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
        };
        StateObject.prototype.parameter = function (id, opts) {
            if (opts === void 0) {
                opts = {};
            }
            return ((this.url && this.url.parameter(id, opts)) ||
                find(values(this.params), propEq('id', id)) ||
                (opts.inherit && this.parent && this.parent.parameter(id)));
        };
        StateObject.prototype.toString = function () {
            return this.fqn();
        };
        StateObject.isStateClass = function (stateDecl) {
            return isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
        };
        StateObject.isState = function (obj) { return isObject(obj['__stateObjectCache']); };
        return StateObject;
    }());
    var toStr = Object.prototype.toString;
    var tis = function (t) { return function (x) { return typeof x === t; }; };
    var isUndefined = tis('undefined');
    var isDefined = not(isUndefined);
    var isNull = function (o) { return o === null; };
    var isNullOrUndefined = or(isNull, isUndefined);
    var isFunction = tis('function');
    var isNumber = tis('number');
    var isString = tis('string');
    var isObject = function (x) { return x !== null && typeof x === 'object'; };
    var isArray = Array.isArray;
    var isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
    var isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
    var isState = StateObject.isState;
    function isInjectable(val$$1) {
        if (isArray(val$$1) && val$$1.length) {
            var head = val$$1.slice(0, -1), tail = val$$1.slice(-1);
            return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);
        }
        return isFunction(val$$1);
    }
    var isPromise = and(isObject, pipe(prop('then'), isFunction));
    var notImplemented = function (fnname) {
        return function () {
            throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");
        };
    };
    var services = {
        $q: undefined,
        $injector: undefined,
    };
    var root = (typeof self === 'object' && self.self === self && self) ||
        (typeof global === 'object' && global.global === global && global) ||
        undefined;
    var angular$1 = root.angular || {};
    var fromJson = angular$1.fromJson || JSON.parse.bind(JSON);
    var toJson = angular$1.toJson || JSON.stringify.bind(JSON);
    var forEach = angular$1.forEach || _forEach;
    var extend = Object.assign || _extend;
    var equals = angular$1.equals || _equals;
    function identity(x) {
        return x;
    }
    function noop() { }
    function createProxyFunctions(source, target, bind, fnNames, latebind) {
        if (latebind === void 0) {
            latebind = false;
        }
        var bindFunction = function (fnName) { return source()[fnName].bind(bind()); };
        var makeLateRebindFn = function (fnName) {
            return function lateRebindFunction() {
                target[fnName] = bindFunction(fnName);
                return target[fnName].apply(null, arguments);
            };
        };
        fnNames = fnNames || Object.keys(source());
        return fnNames.reduce(function (acc, name) {
            acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
            return acc;
        }, target);
    }
    var inherit = function (parent, extra) { return extend(Object.create(parent), extra); };
    var inArray = curry(_inArray);
    function _inArray(array, obj) {
        return array.indexOf(obj) !== -1;
    }
    var removeFrom = curry(_removeFrom);
    function _removeFrom(array, obj) {
        var idx = array.indexOf(obj);
        if (idx >= 0)
            array.splice(idx, 1);
        return array;
    }
    var pushTo = curry(_pushTo);
    function _pushTo(arr, val$$1) {
        return arr.push(val$$1), val$$1;
    }
    var deregAll = function (functions) {
        return functions.slice().forEach(function (fn) {
            typeof fn === 'function' && fn();
            removeFrom(functions, fn);
        });
    };
    function defaults(opts) {
        var defaultsList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            defaultsList[_i - 1] = arguments[_i];
        }
        var _defaultsList = defaultsList.concat({}).reverse();
        var defaultVals = extend.apply(null, _defaultsList);
        return extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));
    }
    var mergeR = function (memo, item) { return extend(memo, item); };
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n])
                break;
            path.push(first.path[n]);
        }
        return path;
    }
    function pick(obj, propNames) {
        var objCopy = {};
        for (var _prop in obj) {
            if (propNames.indexOf(_prop) !== -1) {
                objCopy[_prop] = obj[_prop];
            }
        }
        return objCopy;
    }
    function omit(obj, propNames) {
        return Object.keys(obj)
            .filter(not(inArray(propNames)))
            .reduce(function (acc, key) { return ((acc[key] = obj[key]), acc); }, {});
    }
    function pluck(collection, propName) {
        return map(collection, prop(propName));
    }
    function filter(collection, callback) {
        var arr = isArray(collection), result = arr ? [] : {};
        var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return (result[key] = x); };
        forEach(collection, function (item, i) {
            if (callback(item, i))
                accept(item, i);
        });
        return result;
    }
    function find(collection, callback) {
        var result;
        forEach(collection, function (item, i) {
            if (result)
                return;
            if (callback(item, i))
                result = item;
        });
        return result;
    }
    var mapObj = map;
    function map(collection, callback, target) {
        target = target || (isArray(collection) ? [] : {});
        forEach(collection, function (item, i) { return (target[i] = callback(item, i)); });
        return target;
    }
    var values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };
    var allTrueR = function (memo, elem) { return memo && elem; };
    var anyTrueR = function (memo, elem) { return memo || elem; };
    var unnestR = function (memo, elem) { return memo.concat(elem); };
    var flattenR = function (memo, elem) {
        return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);
    };
    function pushR(arr, obj) {
        arr.push(obj);
        return arr;
    }
    var uniqR = function (acc, token) { return (inArray(acc, token) ? acc : pushR(acc, token)); };
    var unnest = function (arr) { return arr.reduce(unnestR, []); };
    var flatten = function (arr) { return arr.reduce(flattenR, []); };
    var assertPredicate = assertFn;
    var assertMap = assertFn;
    function assertFn(predicateOrMap, errMsg) {
        if (errMsg === void 0) {
            errMsg = 'assert failure';
        }
        return function (obj) {
            var result = predicateOrMap(obj);
            if (!result) {
                throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);
            }
            return result;
        };
    }
    var pairs = function (obj) { return Object.keys(obj).map(function (key) { return [key, obj[key]]; }); };
    function arrayTuples() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0)
            return [];
        var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991);
        var result = [];
        var _loop_1 = function (i) {
            switch (args.length) {
                case 1:
                    result.push([args[0][i]]);
                    break;
                case 2:
                    result.push([args[0][i], args[1][i]]);
                    break;
                case 3:
                    result.push([args[0][i], args[1][i], args[2][i]]);
                    break;
                case 4:
                    result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                    break;
                default:
                    result.push(args.map(function (array) { return array[i]; }));
                    break;
            }
        };
        for (var i = 0; i < maxArrayLen; i++) {
            _loop_1(i);
        }
        return result;
    }
    function applyPairs(memo, keyValTuple) {
        var key, value;
        if (isArray(keyValTuple))
            key = keyValTuple[0], value = keyValTuple[1];
        if (!isString(key))
            throw new Error('invalid parameters to applyPairs');
        memo[key] = value;
        return memo;
    }
    function tail(arr) {
        return (arr.length && arr[arr.length - 1]) || undefined;
    }
    function copy(src, dest) {
        if (dest)
            Object.keys(dest).forEach(function (key) { return delete dest[key]; });
        if (!dest)
            dest = {};
        return extend(dest, src);
    }
    function _forEach(obj, cb, _this) {
        if (isArray(obj))
            return obj.forEach(cb, _this);
        Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
    }
    function _extend(toObj) {
        for (var i = 1; i < arguments.length; i++) {
            var obj = arguments[i];
            if (!obj)
                continue;
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; j++) {
                toObj[keys[j]] = obj[keys[j]];
            }
        }
        return toObj;
    }
    function _equals(o1, o2) {
        if (o1 === o2)
            return true;
        if (o1 === null || o2 === null)
            return false;
        if (o1 !== o1 && o2 !== o2)
            return true;
        var t1 = typeof o1, t2 = typeof o2;
        if (t1 !== t2 || t1 !== 'object')
            return false;
        var tup = [o1, o2];
        if (all(isArray)(tup))
            return _arraysEq(o1, o2);
        if (all(isDate)(tup))
            return o1.getTime() === o2.getTime();
        if (all(isRegExp)(tup))
            return o1.toString() === o2.toString();
        if (all(isFunction)(tup))
            return true;
        var predicates = [isFunction, isArray, isDate, isRegExp];
        if (predicates.map(any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
            return false;
        var keys = {};
        for (var key in o1) {
            if (!_equals(o1[key], o2[key]))
                return false;
            keys[key] = true;
        }
        for (var key in o2) {
            if (!keys[key])
                return false;
        }
        return true;
    }
    function _arraysEq(a1, a2) {
        if (a1.length !== a2.length)
            return false;
        return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
    }
    var silenceUncaughtInPromise = function (promise) { return promise.catch(function (e) { return 0; }) && promise; };
    var silentRejection = function (error) { return silenceUncaughtInPromise(services.$q.reject(error)); };
    var Queue = (function () {
        function Queue(_items, _limit) {
            if (_items === void 0) {
                _items = [];
            }
            if (_limit === void 0) {
                _limit = null;
            }
            this._items = _items;
            this._limit = _limit;
            this._evictListeners = [];
            this.onEvict = pushTo(this._evictListeners);
        }
        Queue.prototype.enqueue = function (item) {
            var items = this._items;
            items.push(item);
            if (this._limit && items.length > this._limit)
                this.evict();
            return item;
        };
        Queue.prototype.evict = function () {
            var item = this._items.shift();
            this._evictListeners.forEach(function (fn) { return fn(item); });
            return item;
        };
        Queue.prototype.dequeue = function () {
            if (this.size())
                return this._items.splice(0, 1)[0];
        };
        Queue.prototype.clear = function () {
            var current = this._items;
            this._items = [];
            return current;
        };
        Queue.prototype.size = function () {
            return this._items.length;
        };
        Queue.prototype.remove = function (item) {
            var idx = this._items.indexOf(item);
            return idx > -1 && this._items.splice(idx, 1)[0];
        };
        Queue.prototype.peekTail = function () {
            return this._items[this._items.length - 1];
        };
        Queue.prototype.peekHead = function () {
            if (this.size())
                return this._items[0];
        };
        return Queue;
    }());
    (function (RejectType) {
        RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
        RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
        RejectType[RejectType["INVALID"] = 4] = "INVALID";
        RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
        RejectType[RejectType["ERROR"] = 6] = "ERROR";
    })(exports.RejectType || (exports.RejectType = {}));
    var id = 0;
    var Rejection = (function () {
        function Rejection(type, message, detail) {
            this.$id = id++;
            this.type = type;
            this.message = message;
            this.detail = detail;
        }
        Rejection.isRejectionPromise = function (obj) {
            return obj && typeof obj.then === 'function' && is(Rejection)(obj._transitionRejection);
        };
        Rejection.superseded = function (detail, options) {
            var message = 'The transition has been superseded by a different transition';
            var rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);
            if (options && options.redirected) {
                rejection.redirected = true;
            }
            return rejection;
        };
        Rejection.redirected = function (detail) {
            return Rejection.superseded(detail, { redirected: true });
        };
        Rejection.invalid = function (detail) {
            var message = 'This transition is invalid';
            return new Rejection(exports.RejectType.INVALID, message, detail);
        };
        Rejection.ignored = function (detail) {
            var message = 'The transition was ignored';
            return new Rejection(exports.RejectType.IGNORED, message, detail);
        };
        Rejection.aborted = function (detail) {
            var message = 'The transition has been aborted';
            return new Rejection(exports.RejectType.ABORTED, message, detail);
        };
        Rejection.errored = function (detail) {
            var message = 'The transition errored';
            return new Rejection(exports.RejectType.ERROR, message, detail);
        };
        Rejection.normalize = function (detail) {
            return is(Rejection)(detail) ? detail : Rejection.errored(detail);
        };
        Rejection.prototype.toString = function () {
            var detailString = function (d) { return (d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d)); };
            var detail = detailString(this.detail);
            var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
            return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
        };
        Rejection.prototype.toPromise = function () {
            return extend(silentRejection(this), { _transitionRejection: this });
        };
        return Rejection;
    }());
    function uiViewString(uiview) {
        if (!uiview)
            return 'ui-view (defunct)';
        var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';
        return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
    }
    var viewConfigString = function (viewConfig) {
        var view = viewConfig.viewDecl;
        var state = view.$context.name || '(root)';
        return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
    };
    function normalizedCat(input) {
        return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];
    }
    var consoleLog = Function.prototype.bind.call(console.log, console);
    var consoletable = isFunction(console.table) ? console.table.bind(console) : consoleLog.bind(console);
    (function (Category) {
        Category[Category["RESOLVE"] = 0] = "RESOLVE";
        Category[Category["TRANSITION"] = 1] = "TRANSITION";
        Category[Category["HOOK"] = 2] = "HOOK";
        Category[Category["UIVIEW"] = 3] = "UIVIEW";
        Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
    })(exports.Category || (exports.Category = {}));
    var _tid = parse('$id');
    var _rid = parse('router.$id');
    var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
    var Trace = (function () {
        function Trace() {
            this._enabled = {};
            this.approximateDigests = 0;
        }
        Trace.prototype._set = function (enabled, categories) {
            var _this = this;
            if (!categories.length) {
                categories = Object.keys(exports.Category)
                    .map(function (k) { return parseInt(k, 10); })
                    .filter(function (k) { return !isNaN(k); })
                    .map(function (key) { return exports.Category[key]; });
            }
            categories.map(normalizedCat).forEach(function (category) { return (_this._enabled[category] = enabled); });
        };
        Trace.prototype.enable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(true, categories);
        };
        Trace.prototype.disable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(false, categories);
        };
        Trace.prototype.enabled = function (category) {
            return !!this._enabled[normalizedCat(category)];
        };
        Trace.prototype.traceTransitionStart = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            console.log(transLbl(trans) + ": Started  -> " + stringify(trans));
        };
        Trace.prototype.traceTransitionIgnored = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            console.log(transLbl(trans) + ": Ignored  <> " + stringify(trans));
        };
        Trace.prototype.traceHookInvocation = function (step, trans, options) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = functionToString(step.registeredHook.callback);
            console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + maxLength(200, name));
        };
        Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            console.log(transLbl(trans) + ":   <- Hook returned: " + maxLength(200, stringify(hookResult)));
        };
        Trace.prototype.traceResolvePath = function (path, when, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
        };
        Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + maxLength(200, stringify(resolvable.data)));
        };
        Trace.prototype.traceError = function (reason, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            console.log(transLbl(trans) + ": <- Rejected " + stringify(trans) + ", reason: " + reason);
        };
        Trace.prototype.traceSuccess = function (finalState, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            console.log(transLbl(trans) + ": <- Success  " + stringify(trans) + ", final state: " + finalState.name);
        };
        Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
            if (extra === void 0) {
                extra = '';
            }
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            console.log("ui-view: " + padString(30, event) + " " + uiViewString(viewData) + extra);
        };
        Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Updating', viewData, " with ViewConfig from context='" + context + "'");
        };
        Trace.prototype.traceUIViewFill = function (viewData, html) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Fill', viewData, " with: " + maxLength(200, html));
        };
        Trace.prototype.traceViewSync = function (pairs) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            var uivheader = 'uiview component fqn';
            var cfgheader = 'view config state (view name)';
            var mapping = pairs
                .map(function (_a) {
                var uiView = _a.uiView, viewConfig = _a.viewConfig;
                var uiv = uiView && uiView.fqn;
                var cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
                return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;
                var _b;
            })
                .sort(function (a, b) { return (a[uivheader] || '').localeCompare(b[uivheader] || ''); });
            consoletable(mapping);
        };
        Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
        };
        Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
        };
        return Trace;
    }());
    var trace = new Trace();
    (function (TransitionHookPhase) {
        TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
        TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
        TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
        TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
        TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
    })(exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));
    (function (TransitionHookScope) {
        TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
        TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
    })(exports.TransitionHookScope || (exports.TransitionHookScope = {}));
    var TargetState = (function () {
        function TargetState(_stateRegistry, _identifier, _params, _options) {
            this._stateRegistry = _stateRegistry;
            this._identifier = _identifier;
            this._identifier = _identifier;
            this._params = extend({}, _params || {});
            this._options = extend({}, _options || {});
            this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
        }
        TargetState.prototype.name = function () {
            return (this._definition && this._definition.name) || this._identifier;
        };
        TargetState.prototype.identifier = function () {
            return this._identifier;
        };
        TargetState.prototype.params = function () {
            return this._params;
        };
        TargetState.prototype.$state = function () {
            return this._definition;
        };
        TargetState.prototype.state = function () {
            return this._definition && this._definition.self;
        };
        TargetState.prototype.options = function () {
            return this._options;
        };
        TargetState.prototype.exists = function () {
            return !!(this._definition && this._definition.self);
        };
        TargetState.prototype.valid = function () {
            return !this.error();
        };
        TargetState.prototype.error = function () {
            var base = this.options().relative;
            if (!this._definition && !!base) {
                var stateName = base.name ? base.name : base;
                return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
            }
            if (!this._definition)
                return "No such state '" + this.name() + "'";
            if (!this._definition.self)
                return "State '" + this.name() + "' has an invalid definition";
        };
        TargetState.prototype.toString = function () {
            return "'" + this.name() + "'" + stringify(this.params());
        };
        TargetState.prototype.withState = function (state) {
            return new TargetState(this._stateRegistry, state, this._params, this._options);
        };
        TargetState.prototype.withParams = function (params, replace) {
            if (replace === void 0) {
                replace = false;
            }
            var newParams = replace ? params : extend({}, this._params, params);
            return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
        };
        TargetState.prototype.withOptions = function (options, replace) {
            if (replace === void 0) {
                replace = false;
            }
            var newOpts = replace ? options : extend({}, this._options, options);
            return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
        };
        TargetState.isDef = function (obj) { return obj && obj.state && (isString(obj.state) || isString(obj.state.name)); };
        return TargetState;
    }());
    var defaultOptions = {
        current: noop,
        transition: null,
        traceData: {},
        bind: null,
    };
    var TransitionHook = (function () {
        function TransitionHook(transition, stateContext, registeredHook, options) {
            var _this = this;
            this.transition = transition;
            this.stateContext = stateContext;
            this.registeredHook = registeredHook;
            this.options = options;
            this.isSuperseded = function () { return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive(); };
            this.options = defaults(options, defaultOptions);
            this.type = registeredHook.eventType;
        }
        TransitionHook.chain = function (hooks, waitFor) {
            var createHookChainR = function (prev, nextHook) { return prev.then(function () { return nextHook.invokeHook(); }); };
            return hooks.reduce(createHookChainR, waitFor || services.$q.when());
        };
        TransitionHook.invokeHooks = function (hooks, doneCallback) {
            for (var idx = 0; idx < hooks.length; idx++) {
                var hookResult = hooks[idx].invokeHook();
                if (isPromise(hookResult)) {
                    var remainingHooks = hooks.slice(idx + 1);
                    return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
                }
            }
            return doneCallback();
        };
        TransitionHook.runAllHooks = function (hooks) {
            hooks.forEach(function (hook) { return hook.invokeHook(); });
        };
        TransitionHook.prototype.logError = function (err) {
            this.transition.router.stateService.defaultErrorHandler()(err);
        };
        TransitionHook.prototype.invokeHook = function () {
            var _this = this;
            var hook = this.registeredHook;
            if (hook._deregistered)
                return;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            var options = this.options;
            trace.traceHookInvocation(this, this.transition, options);
            var invokeCallback = function () { return hook.callback.call(options.bind, _this.transition, _this.stateContext); };
            var normalizeErr = function (err) { return Rejection.normalize(err).toPromise(); };
            var handleError = function (err) { return hook.eventType.getErrorHandler(_this)(err); };
            var handleResult = function (result) { return hook.eventType.getResultHandler(_this)(result); };
            try {
                var result = invokeCallback();
                if (!this.type.synchronous && isPromise(result)) {
                    return result.catch(normalizeErr).then(handleResult, handleError);
                }
                else {
                    return handleResult(result);
                }
            }
            catch (err) {
                return handleError(Rejection.normalize(err));
            }
            finally {
                if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
                    hook.deregister();
                }
            }
        };
        TransitionHook.prototype.handleHookResult = function (result) {
            var _this = this;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            if (isPromise(result)) {
                return result.then(function (val$$1) { return _this.handleHookResult(val$$1); });
            }
            trace.traceHookResult(result, this.transition, this.options);
            if (result === false) {
                return Rejection.aborted('Hook aborted transition').toPromise();
            }
            var isTargetState = is(TargetState);
            if (isTargetState(result)) {
                return Rejection.redirected(result).toPromise();
            }
        };
        TransitionHook.prototype.getNotCurrentRejection = function () {
            var router = this.transition.router;
            if (router._disposed) {
                return Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
            }
            if (this.transition._aborted) {
                return Rejection.aborted().toPromise();
            }
            if (this.isSuperseded()) {
                return Rejection.superseded(this.options.current()).toPromise();
            }
        };
        TransitionHook.prototype.toString = function () {
            var _a = this, options = _a.options, registeredHook = _a.registeredHook;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = fnToString(registeredHook.callback);
            return event + " context: " + context + ", " + maxLength(200, name);
        };
        TransitionHook.HANDLE_RESULT = function (hook) {
            return function (result) {
                return hook.handleHookResult(result);
            };
        };
        TransitionHook.LOG_REJECTED_RESULT = function (hook) {
            return function (result) {
                isPromise(result) && result.catch(function (err) { return hook.logError(Rejection.normalize(err)); });
                return undefined;
            };
        };
        TransitionHook.LOG_ERROR = function (hook) { return function (error) { return hook.logError(error); }; };
        TransitionHook.REJECT_ERROR = function (hook) { return function (error) { return silentRejection(error); }; };
        TransitionHook.THROW_ERROR = function (hook) {
            return function (error) {
                throw error;
            };
        };
        return TransitionHook;
    }());
    function matchState(state, criterion) {
        var toMatch = isString(criterion) ? [criterion] : criterion;
        function matchGlobs(_state) {
            var globStrings = toMatch;
            for (var i = 0; i < globStrings.length; i++) {
                var glob = new Glob(globStrings[i]);
                if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                    return true;
                }
            }
            return false;
        }
        var matchFn = (isFunction(toMatch) ? toMatch : matchGlobs);
        return !!matchFn(state);
    }
    var RegisteredHook = (function () {
        function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
            if (options === void 0) {
                options = {};
            }
            this.tranSvc = tranSvc;
            this.eventType = eventType;
            this.callback = callback;
            this.matchCriteria = matchCriteria;
            this.removeHookFromRegistry = removeHookFromRegistry;
            this.invokeCount = 0;
            this._deregistered = false;
            this.priority = options.priority || 0;
            this.bind = options.bind || null;
            this.invokeLimit = options.invokeLimit;
        }
        RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {
            if (criterion === true)
                return nodes;
            var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });
            return matching.length ? matching : null;
        };
        RegisteredHook.prototype._getDefaultMatchCriteria = function () {
            return mapObj(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
        };
        RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {
            var _this = this;
            var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);
            var paths = values(this.tranSvc._pluginapi._getPathTypes());
            return paths.reduce(function (mn, pathtype) {
                var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE;
                var path = treeChanges[pathtype.name] || [];
                var nodes = isStateHook ? path : [tail(path)];
                mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);
                return mn;
            }, {});
        };
        RegisteredHook.prototype.matches = function (treeChanges) {
            var matches = this._getMatchingNodes(treeChanges);
            var allMatched = values(matches).every(identity);
            return allMatched ? matches : null;
        };
        RegisteredHook.prototype.deregister = function () {
            this.removeHookFromRegistry(this);
            this._deregistered = true;
        };
        return RegisteredHook;
    }());
    function makeEvent(registry, transitionService, eventType) {
        var _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});
        var hooks = (_registeredHooks[eventType.name] = []);
        var removeHookFn = removeFrom(hooks);
        registry[eventType.name] = hookRegistrationFn;
        function hookRegistrationFn(matchObject, callback, options) {
            if (options === void 0) {
                options = {};
            }
            var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
            hooks.push(registeredHook);
            return registeredHook.deregister.bind(registeredHook);
        }
        return hookRegistrationFn;
    }
    var HookBuilder = (function () {
        function HookBuilder(transition) {
            this.transition = transition;
        }
        HookBuilder.prototype.buildHooksForPhase = function (phase) {
            var _this = this;
            var $transitions = this.transition.router.transitionService;
            return $transitions._pluginapi
                ._getEvents(phase)
                .map(function (type) { return _this.buildHooks(type); })
                .reduce(unnestR, [])
                .filter(identity);
        };
        HookBuilder.prototype.buildHooks = function (hookType) {
            var transition = this.transition;
            var treeChanges = transition.treeChanges();
            var matchingHooks = this.getMatchingHooks(hookType, treeChanges);
            if (!matchingHooks)
                return [];
            var baseHookOptions = {
                transition: transition,
                current: transition.options().current,
            };
            var makeTransitionHooks = function (hook) {
                var matches = hook.matches(treeChanges);
                var matchingNodes = matches[hookType.criteriaMatchPath.name];
                return matchingNodes.map(function (node) {
                    var _options = extend({
                        bind: hook.bind,
                        traceData: { hookType: hookType.name, context: node },
                    }, baseHookOptions);
                    var state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null;
                    var transitionHook = new TransitionHook(transition, state, hook, _options);
                    return { hook: hook, node: node, transitionHook: transitionHook };
                });
            };
            return matchingHooks
                .map(makeTransitionHooks)
                .reduce(unnestR, [])
                .sort(tupleSort(hookType.reverseSort))
                .map(function (tuple) { return tuple.transitionHook; });
        };
        HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {
            var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE;
            var $transitions = this.transition.router.transitionService;
            var registries = isCreate ? [$transitions] : [this.transition, $transitions];
            return registries
                .map(function (reg) { return reg.getHooks(hookType.name); })
                .filter(assertPredicate(isArray, "broken event named: " + hookType.name))
                .reduce(unnestR, [])
                .filter(function (hook) { return hook.matches(treeChanges); });
        };
        return HookBuilder;
    }());
    function tupleSort(reverseDepthSort) {
        if (reverseDepthSort === void 0) {
            reverseDepthSort = false;
        }
        return function nodeDepthThenPriority(l, r) {
            var factor = reverseDepthSort ? -1 : 1;
            var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
            return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
        };
    }
    var ParamType = (function () {
        function ParamType(def) {
            this.pattern = /.*/;
            this.inherit = true;
            extend(this, def);
        }
        ParamType.prototype.is = function (val, key) {
            return true;
        };
        ParamType.prototype.encode = function (val, key) {
            return val;
        };
        ParamType.prototype.decode = function (val, key) {
            return val;
        };
        ParamType.prototype.equals = function (a, b) {
            return a == b;
        };
        ParamType.prototype.$subPattern = function () {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
        };
        ParamType.prototype.toString = function () {
            return "{ParamType:" + this.name + "}";
        };
        ParamType.prototype.$normalize = function (val) {
            return this.is(val) ? val : this.decode(val);
        };
        ParamType.prototype.$asArray = function (mode, isSearch) {
            if (!mode)
                return this;
            if (mode === 'auto' && !isSearch)
                throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode);
        };
        return ParamType;
    }());
    function ArrayType(type, mode) {
        var _this = this;
        function arrayWrap(val) {
            return isArray(val) ? val : isDefined(val) ? [val] : [];
        }
        function arrayUnwrap(val) {
            switch (val.length) {
                case 0:
                    return undefined;
                case 1:
                    return mode === 'auto' ? val[0] : val;
                default:
                    return val;
            }
        }
        function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
                if (isArray(val) && val.length === 0)
                    return val;
                var arr = arrayWrap(val);
                var result = map(arr, callback);
                return allTruthyMode === true ? filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
            };
        }
        function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
                var left = arrayWrap(val1), right = arrayWrap(val2);
                if (left.length !== right.length)
                    return false;
                for (var i = 0; i < left.length; i++) {
                    if (!callback(left[i], right[i]))
                        return false;
                }
                return true;
            };
        }
        ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
            var paramTypeFn = type[name].bind(type);
            var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
            _this[name] = wrapperFn(paramTypeFn);
        });
        extend(this, {
            dynamic: type.dynamic,
            name: type.name,
            pattern: type.pattern,
            inherit: type.inherit,
            is: arrayHandler(type.is.bind(type), true),
            $arrayMode: mode,
        });
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    var isShorthand = function (cfg) {
        return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;
    };
    (function (DefType) {
        DefType[DefType["PATH"] = 0] = "PATH";
        DefType[DefType["SEARCH"] = 1] = "SEARCH";
        DefType[DefType["CONFIG"] = 2] = "CONFIG";
    })(exports.DefType || (exports.DefType = {}));
    function unwrapShorthand(cfg) {
        cfg = (isShorthand(cfg) && { value: cfg }) || cfg;
        getStaticDefaultValue['__cacheable'] = true;
        function getStaticDefaultValue() {
            return cfg.value;
        }
        return extend(cfg, {
            $$fn: isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,
        });
    }
    function getType(cfg, urlType, location, id, paramTypes) {
        if (cfg.type && urlType && urlType.name !== 'string')
            throw new Error("Param '" + id + "' has two type configurations.");
        if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
            return paramTypes.type(cfg.type);
        if (urlType)
            return urlType;
        if (!cfg.type) {
            var type = location === exports.DefType.CONFIG
                ? 'any'
                : location === exports.DefType.PATH ? 'path' : location === exports.DefType.SEARCH ? 'query' : 'string';
            return paramTypes.type(type);
        }
        return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
    }
    function getSquashPolicy(config, isOptional, defaultPolicy) {
        var squash = config.squash;
        if (!isOptional || squash === false)
            return false;
        if (!isDefined(squash) || squash == null)
            return defaultPolicy;
        if (squash === true || isString(squash))
            return squash;
        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }
    function getReplace(config, arrayMode, isOptional, squash) {
        var defaultPolicy = [
            { from: '', to: isOptional || arrayMode ? undefined : '' },
            { from: null, to: isOptional || arrayMode ? undefined : '' },
        ];
        var replace = isArray(config.replace) ? config.replace : [];
        if (isString(squash))
            replace.push({ from: squash, to: undefined });
        var configuredKeys = map(replace, prop('from'));
        return filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
    }
    var Param = (function () {
        function Param(id, type, config, location, urlMatcherFactory) {
            config = unwrapShorthand(config);
            type = getType(config, type, location, id, urlMatcherFactory.paramTypes);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;
            var isOptional = config.value !== undefined || location === exports.DefType.SEARCH;
            var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
            var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;
            var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());
            var replace = getReplace(config, arrayMode, isOptional, squash);
            var inherit$$1 = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
            function getArrayMode() {
                var arrayDefaults = { array: location === exports.DefType.SEARCH ? 'auto' : false };
                var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit$$1, array: arrayMode, config: config });
        }
        Param.values = function (params, values$$1) {
            if (values$$1 === void 0) {
                values$$1 = {};
            }
            var paramValues = {};
            for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var param = params_1[_i];
                paramValues[param.id] = param.value(values$$1[param.id]);
            }
            return paramValues;
        };
        Param.changed = function (params, values1, values2) {
            if (values1 === void 0) {
                values1 = {};
            }
            if (values2 === void 0) {
                values2 = {};
            }
            return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
        };
        Param.equals = function (params, values1, values2) {
            if (values1 === void 0) {
                values1 = {};
            }
            if (values2 === void 0) {
                values2 = {};
            }
            return Param.changed(params, values1, values2).length === 0;
        };
        Param.validates = function (params, values$$1) {
            if (values$$1 === void 0) {
                values$$1 = {};
            }
            return params.map(function (param) { return param.validates(values$$1[param.id]); }).reduce(allTrueR, true);
        };
        Param.prototype.isDefaultValue = function (value) {
            return this.isOptional && this.type.equals(this.value(), value);
        };
        Param.prototype.value = function (value) {
            var _this = this;
            var getDefaultValue = function () {
                if (_this._defaultValueCache)
                    return _this._defaultValueCache.defaultValue;
                if (!services.$injector)
                    throw new Error('Injectable functions cannot be called at configuration time');
                var defaultValue = services.$injector.invoke(_this.config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                    throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                if (_this.config.$$fn['__cacheable']) {
                    _this._defaultValueCache = { defaultValue: defaultValue };
                }
                return defaultValue;
            };
            var replaceSpecialValues = function (val$$1) {
                for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                    var tuple = _a[_i];
                    if (tuple.from === val$$1)
                        return tuple.to;
                }
                return val$$1;
            };
            value = replaceSpecialValues(value);
            return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
        };
        Param.prototype.isSearch = function () {
            return this.location === exports.DefType.SEARCH;
        };
        Param.prototype.validates = function (value) {
            if ((isUndefined(value) || value === null) && this.isOptional)
                return true;
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized))
                return false;
            var encoded = this.type.encode(normalized);
            return !(isString(encoded) && !this.type.pattern.exec(encoded));
        };
        Param.prototype.toString = function () {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
        };
        return Param;
    }());
    var PathNode = (function () {
        function PathNode(stateOrNode) {
            if (stateOrNode instanceof PathNode) {
                var node = stateOrNode;
                this.state = node.state;
                this.paramSchema = node.paramSchema.slice();
                this.paramValues = extend({}, node.paramValues);
                this.resolvables = node.resolvables.slice();
                this.views = node.views && node.views.slice();
            }
            else {
                var state = stateOrNode;
                this.state = state;
                this.paramSchema = state.parameters({ inherit: false });
                this.paramValues = {};
                this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
            }
        }
        PathNode.prototype.clone = function () {
            return new PathNode(this);
        };
        PathNode.prototype.applyRawParams = function (params) {
            var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
            this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return applyPairs(memo, getParamVal(pDef)); }, {});
            return this;
        };
        PathNode.prototype.parameter = function (name) {
            return find(this.paramSchema, propEq('id', name));
        };
        PathNode.prototype.equals = function (node, paramsFn) {
            var diff = this.diff(node, paramsFn);
            return diff && diff.length === 0;
        };
        PathNode.prototype.diff = function (node, paramsFn) {
            if (this.state !== node.state)
                return false;
            var params = paramsFn ? paramsFn(this) : this.paramSchema;
            return Param.changed(params, this.paramValues, node.paramValues);
        };
        PathNode.clone = function (node) { return node.clone(); };
        return PathNode;
    }());
    var PathUtils = (function () {
        function PathUtils() {
        }
        PathUtils.makeTargetState = function (registry, path) {
            var state = tail(path).state;
            return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});
        };
        PathUtils.buildPath = function (targetState) {
            var toParams = targetState.params();
            return targetState.$state().path.map(function (state) { return new PathNode(state).applyRawParams(toParams); });
        };
        PathUtils.buildToPath = function (fromPath, targetState) {
            var toPath = PathUtils.buildPath(targetState);
            if (targetState.options().inherit) {
                return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
            }
            return toPath;
        };
        PathUtils.applyViewConfigs = function ($view, path, states) {
            path.filter(function (node) { return inArray(states, node.state); }).forEach(function (node) {
                var viewDecls = values(node.state.views || {});
                var subPath = PathUtils.subPath(path, function (n) { return n === node; });
                var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
                node.views = viewConfigs.reduce(unnestR, []);
            });
        };
        PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
            if (toKeys === void 0) {
                toKeys = [];
            }
            function nodeParamVals(path, state) {
                var node = find(path, propEq('state', state));
                return extend({}, node && node.paramValues);
            }
            var noInherit = fromPath
                .map(function (node) { return node.paramSchema; })
                .reduce(unnestR, [])
                .filter(function (param) { return !param.inherit; })
                .map(prop('id'));
            function makeInheritedParamsNode(toNode) {
                var toParamVals = extend({}, toNode && toNode.paramValues);
                var incomingParamVals = pick(toParamVals, toKeys);
                toParamVals = omit(toParamVals, toKeys);
                var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
                var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);
                return new PathNode(toNode.state).applyRawParams(ownParamVals);
            }
            return toPath.map(makeInheritedParamsNode);
        };
        PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
            var max = Math.min(fromPath.length, toPath.length);
            var keep = 0;
            var nodesMatch = function (node1, node2) { return node1.equals(node2, PathUtils.nonDynamicParams); };
            while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
                keep++;
            }
            function applyToParams(retainedNode, idx) {
                var cloned = retainedNode.clone();
                cloned.paramValues = toPath[idx].paramValues;
                return cloned;
            }
            var from, retained, exiting, entering, to;
            from = fromPath;
            retained = from.slice(0, keep);
            exiting = from.slice(keep);
            var retainedWithToParams = retained.map(applyToParams);
            entering = toPath.slice(keep);
            to = retainedWithToParams.concat(entering);
            return { from: from, to: to, retained: retained, retainedWithToParams: retainedWithToParams, exiting: exiting, entering: entering };
        };
        PathUtils.matching = function (pathA, pathB, paramsFn) {
            var done = false;
            var tuples = arrayTuples(pathA, pathB);
            return tuples.reduce(function (matching, _a) {
                var nodeA = _a[0], nodeB = _a[1];
                done = done || !nodeA.equals(nodeB, paramsFn);
                return done ? matching : matching.concat(nodeA);
            }, []);
        };
        PathUtils.equals = function (pathA, pathB, paramsFn) {
            return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
        };
        PathUtils.subPath = function (path, predicate) {
            var node = find(path, predicate);
            var elementIdx = path.indexOf(node);
            return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
        };
        PathUtils.nonDynamicParams = function (node) {
            return node.state.parameters({ inherit: false }).filter(function (param) { return !param.dynamic; });
        };
        PathUtils.paramValues = function (path) { return path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {}); };
        return PathUtils;
    }());
    var defaultResolvePolicy = {
        when: 'LAZY',
        async: 'WAIT',
    };
    var Resolvable = (function () {
        function Resolvable(arg1, resolveFn, deps, policy, data) {
            this.resolved = false;
            this.promise = undefined;
            if (arg1 instanceof Resolvable) {
                extend(this, arg1);
            }
            else if (isFunction(resolveFn)) {
                if (isNullOrUndefined(arg1))
                    throw new Error('new Resolvable(): token argument is required');
                if (!isFunction(resolveFn))
                    throw new Error('new Resolvable(): resolveFn argument must be a function');
                this.token = arg1;
                this.policy = policy;
                this.resolveFn = resolveFn;
                this.deps = deps || [];
                this.data = data;
                this.resolved = data !== undefined;
                this.promise = this.resolved ? services.$q.when(this.data) : undefined;
            }
            else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {
                var literal = arg1;
                return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
            }
        }
        Resolvable.prototype.getPolicy = function (state) {
            var thisPolicy = this.policy || {};
            var statePolicy = (state && state.resolvePolicy) || {};
            return {
                when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
                async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,
            };
        };
        Resolvable.prototype.resolve = function (resolveContext, trans) {
            var _this = this;
            var $q = services.$q;
            var getResolvableDependencies = function () {
                return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) { return resolvable.get(resolveContext, trans); }));
            };
            var invokeResolveFn = function (resolvedDeps) { return _this.resolveFn.apply(null, resolvedDeps); };
            var waitForRx = function (observable$) {
                var cached = observable$.cache(1);
                return cached
                    .take(1)
                    .toPromise()
                    .then(function () { return cached; });
            };
            var node = resolveContext.findNode(this);
            var state = node && node.state;
            var maybeWaitForRx = this.getPolicy(state).async === 'RXWAIT' ? waitForRx : identity;
            var applyResolvedValue = function (resolvedValue) {
                _this.data = resolvedValue;
                _this.resolved = true;
                _this.resolveFn = null;
                trace.traceResolvableResolved(_this, trans);
                return _this.data;
            };
            return (this.promise = $q
                .when()
                .then(getResolvableDependencies)
                .then(invokeResolveFn)
                .then(maybeWaitForRx)
                .then(applyResolvedValue));
        };
        Resolvable.prototype.get = function (resolveContext, trans) {
            return this.promise || this.resolve(resolveContext, trans);
        };
        Resolvable.prototype.toString = function () {
            return "Resolvable(token: " + stringify(this.token) + ", requires: [" + this.deps.map(stringify) + "])";
        };
        Resolvable.prototype.clone = function () {
            return new Resolvable(this);
        };
        Resolvable.fromData = function (token, data) { return new Resolvable(token, function () { return data; }, null, null, data); };
        return Resolvable;
    }());
    var resolvePolicies = {
        when: {
            LAZY: 'LAZY',
            EAGER: 'EAGER',
        },
        async: {
            WAIT: 'WAIT',
            NOWAIT: 'NOWAIT',
            RXWAIT: 'RXWAIT',
        },
    };
    var whens = resolvePolicies.when;
    var ALL_WHENS = [whens.EAGER, whens.LAZY];
    var EAGER_WHENS = [whens.EAGER];
    var NATIVE_INJECTOR_TOKEN = 'Native Injector';
    var ResolveContext = (function () {
        function ResolveContext(_path) {
            this._path = _path;
        }
        ResolveContext.prototype.getTokens = function () {
            return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(uniqR, []);
        };
        ResolveContext.prototype.getResolvable = function (token) {
            var matching = this._path
                .map(function (node) { return node.resolvables; })
                .reduce(unnestR, [])
                .filter(function (r) { return r.token === token; });
            return tail(matching);
        };
        ResolveContext.prototype.getPolicy = function (resolvable) {
            var node = this.findNode(resolvable);
            return resolvable.getPolicy(node.state);
        };
        ResolveContext.prototype.subContext = function (state) {
            return new ResolveContext(PathUtils.subPath(this._path, function (node) { return node.state === state; }));
        };
        ResolveContext.prototype.addResolvables = function (newResolvables, state) {
            var node = find(this._path, propEq('state', state));
            var keys = newResolvables.map(function (r) { return r.token; });
            node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
        };
        ResolveContext.prototype.resolvePath = function (when, trans) {
            var _this = this;
            if (when === void 0) {
                when = 'LAZY';
            }
            var whenOption = inArray(ALL_WHENS, when) ? when : 'LAZY';
            var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
            trace.traceResolvePath(this._path, when, trans);
            var matchesPolicy = function (acceptedVals, whenOrAsync) {
                return function (resolvable) {
                    return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
                };
            };
            var promises = this._path.reduce(function (acc, node) {
                var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
                var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
                var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));
                var subContext = _this.subContext(node.state);
                var getResult = function (r) {
                    return r
                        .get(subContext, trans)
                        .then(function (value) { return ({ token: r.token, value: value }); });
                };
                nowait.forEach(getResult);
                return acc.concat(wait.map(getResult));
            }, []);
            return services.$q.all(promises);
        };
        ResolveContext.prototype.injector = function () {
            return this._injector || (this._injector = new UIInjectorImpl(this));
        };
        ResolveContext.prototype.findNode = function (resolvable) {
            return find(this._path, function (node) { return inArray(node.resolvables, resolvable); });
        };
        ResolveContext.prototype.getDependencies = function (resolvable) {
            var _this = this;
            var node = this.findNode(resolvable);
            var subPath = PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
            var availableResolvables = subPath
                .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, [])
                .filter(function (res) { return res !== resolvable; });
            var getDependency = function (token) {
                var matching = availableResolvables.filter(function (r) { return r.token === token; });
                if (matching.length)
                    return tail(matching);
                var fromInjector = _this.injector().getNative(token);
                if (isUndefined(fromInjector)) {
                    throw new Error('Could not find Dependency Injection token: ' + stringify(token));
                }
                return new Resolvable(token, function () { return fromInjector; }, [], fromInjector);
            };
            return resolvable.deps.map(getDependency);
        };
        return ResolveContext;
    }());
    var UIInjectorImpl = (function () {
        function UIInjectorImpl(context) {
            this.context = context;
            this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;
        }
        UIInjectorImpl.prototype.get = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable) {
                if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                    return resolvable.get(this.context);
                }
                if (!resolvable.resolved) {
                    throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));
                }
                return resolvable.data;
            }
            return this.getNative(token);
        };
        UIInjectorImpl.prototype.getAsync = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable)
                return resolvable.get(this.context);
            return services.$q.when(this.native.get(token));
        };
        UIInjectorImpl.prototype.getNative = function (token) {
            return this.native && this.native.get(token);
        };
        return UIInjectorImpl;
    }());
    var stateSelf = prop('self');
    var Transition = (function () {
        function Transition(fromPath, targetState, router) {
            var _this = this;
            this._deferred = services.$q.defer();
            this.promise = this._deferred.promise;
            this._registeredHooks = {};
            this._hookBuilder = new HookBuilder(this);
            this.isActive = function () { return _this.router.globals.transition === _this; };
            this.router = router;
            this._targetState = targetState;
            if (!targetState.valid()) {
                throw new Error(targetState.error());
            }
            this._options = extend({ current: val(this) }, targetState.options());
            this.$id = router.transitionService._transitionCount++;
            var toPath = PathUtils.buildToPath(fromPath, targetState);
            this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
            this.createTransitionHookRegFns();
            var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);
            TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
            this.applyViewConfigs(router);
        }
        Transition.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.onError = function (criteria, callback, options) {
            return;
        };
        Transition.prototype.createTransitionHookRegFns = function () {
            var _this = this;
            this.router.transitionService._pluginapi
                ._getEvents()
                .filter(function (type) { return type.hookPhase !== exports.TransitionHookPhase.CREATE; })
                .forEach(function (type) { return makeEvent(_this, _this.router.transitionService, type); });
        };
        Transition.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        Transition.prototype.applyViewConfigs = function (router) {
            var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
            PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
        };
        Transition.prototype.$from = function () {
            return tail(this._treeChanges.from).state;
        };
        Transition.prototype.$to = function () {
            return tail(this._treeChanges.to).state;
        };
        Transition.prototype.from = function () {
            return this.$from().self;
        };
        Transition.prototype.to = function () {
            return this.$to().self;
        };
        Transition.prototype.targetState = function () {
            return this._targetState;
        };
        Transition.prototype.is = function (compare) {
            if (compare instanceof Transition) {
                return this.is({ to: compare.$to().name, from: compare.$from().name });
            }
            return !((compare.to && !matchState(this.$to(), compare.to)) ||
                (compare.from && !matchState(this.$from(), compare.from)));
        };
        Transition.prototype.params = function (pathname) {
            if (pathname === void 0) {
                pathname = 'to';
            }
            return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));
        };
        Transition.prototype.injector = function (state, pathName) {
            if (pathName === void 0) {
                pathName = 'to';
            }
            var path = this._treeChanges[pathName];
            if (state)
                path = PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
            return new ResolveContext(path).injector();
        };
        Transition.prototype.getResolveTokens = function (pathname) {
            if (pathname === void 0) {
                pathname = 'to';
            }
            return new ResolveContext(this._treeChanges[pathname]).getTokens();
        };
        Transition.prototype.addResolvable = function (resolvable, state) {
            if (state === void 0) {
                state = '';
            }
            resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);
            var stateName = typeof state === 'string' ? state : state.name;
            var topath = this._treeChanges.to;
            var targetNode = find(topath, function (node) { return node.state.name === stateName; });
            var resolveContext = new ResolveContext(topath);
            resolveContext.addResolvables([resolvable], targetNode.state);
        };
        Transition.prototype.redirectedFrom = function () {
            return this._options.redirectedFrom || null;
        };
        Transition.prototype.originalTransition = function () {
            var rf = this.redirectedFrom();
            return (rf && rf.originalTransition()) || this;
        };
        Transition.prototype.options = function () {
            return this._options;
        };
        Transition.prototype.entering = function () {
            return map(this._treeChanges.entering, prop('state')).map(stateSelf);
        };
        Transition.prototype.exiting = function () {
            return map(this._treeChanges.exiting, prop('state'))
                .map(stateSelf)
                .reverse();
        };
        Transition.prototype.retained = function () {
            return map(this._treeChanges.retained, prop('state')).map(stateSelf);
        };
        Transition.prototype.views = function (pathname, state) {
            if (pathname === void 0) {
                pathname = 'entering';
            }
            var path = this._treeChanges[pathname];
            path = !state ? path : path.filter(propEq('state', state));
            return path
                .map(prop('views'))
                .filter(identity)
                .reduce(unnestR, []);
        };
        Transition.prototype.treeChanges = function (pathname) {
            return pathname ? this._treeChanges[pathname] : this._treeChanges;
        };
        Transition.prototype.redirect = function (targetState) {
            var redirects = 1, trans = this;
            while ((trans = trans.redirectedFrom()) != null) {
                if (++redirects > 20)
                    throw new Error("Too many consecutive Transition redirects (20+)");
            }
            var redirectOpts = { redirectedFrom: this, source: 'redirect' };
            if (this.options().source === 'url' && targetState.options().location !== false) {
                redirectOpts.location = 'replace';
            }
            var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);
            targetState = targetState.withOptions(newOptions, true);
            var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
            var originalEnteringNodes = this._treeChanges.entering;
            var redirectEnteringNodes = newTransition._treeChanges.entering;
            var nodeIsReloading = function (reloadState) {
                return function (node) {
                    return reloadState && node.state.includes[reloadState.name];
                };
            };
            var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState)));
            matchingEnteringNodes.forEach(function (node, idx) {
                node.resolvables = originalEnteringNodes[idx].resolvables;
            });
            return newTransition;
        };
        Transition.prototype._changedParams = function () {
            var tc = this._treeChanges;
            if (this._options.reload)
                return undefined;
            if (tc.exiting.length || tc.entering.length)
                return undefined;
            if (tc.to.length !== tc.from.length)
                return undefined;
            var pathsDiffer = arrayTuples(tc.to, tc.from)
                .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
                .reduce(anyTrueR, false);
            if (pathsDiffer)
                return undefined;
            var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
            var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
            var tuples = arrayTuples(nodeSchemas, toValues, fromValues);
            return tuples.map(function (_a) {
                var schema = _a[0], toVals = _a[1], fromVals = _a[2];
                return Param.changed(schema, toVals, fromVals);
            }).reduce(unnestR, []);
        };
        Transition.prototype.dynamic = function () {
            var changes = this._changedParams();
            return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(anyTrueR, false);
        };
        Transition.prototype.ignored = function () {
            return !!this._ignoredReason();
        };
        Transition.prototype._ignoredReason = function () {
            var pending = this.router.globals.transition;
            var reloadState = this._options.reloadState;
            var same = function (pathA, pathB) {
                if (pathA.length !== pathB.length)
                    return false;
                var matching = PathUtils.matching(pathA, pathB);
                return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
            };
            var newTC = this.treeChanges();
            var pendTC = pending && pending.treeChanges();
            if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
                return 'SameAsPending';
            if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
                return 'SameAsCurrent';
        };
        Transition.prototype.run = function () {
            var _this = this;
            var runAllHooks = TransitionHook.runAllHooks;
            var getHooksFor = function (phase) { return _this._hookBuilder.buildHooksForPhase(phase); };
            var transitionSuccess = function () {
                trace.traceSuccess(_this.$to(), _this);
                _this.success = true;
                _this._deferred.resolve(_this.to());
                runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));
            };
            var transitionError = function (reason) {
                trace.traceError(reason, _this);
                _this.success = false;
                _this._deferred.reject(reason);
                _this._error = reason;
                runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));
            };
            var runTransition = function () {
                var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN);
                var done = function () { return services.$q.when(undefined); };
                return TransitionHook.invokeHooks(allRunHooks, done);
            };
            var startTransition = function () {
                var globals = _this.router.globals;
                globals.lastStartedTransitionId = _this.$id;
                globals.transition = _this;
                globals.transitionHistory.enqueue(_this);
                trace.traceTransitionStart(_this);
                return services.$q.when(undefined);
            };
            var allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);
            TransitionHook.invokeHooks(allBeforeHooks, startTransition)
                .then(runTransition)
                .then(transitionSuccess, transitionError);
            return this.promise;
        };
        Transition.prototype.valid = function () {
            return !this.error() || this.success !== undefined;
        };
        Transition.prototype.abort = function () {
            if (isUndefined(this.success)) {
                this._aborted = true;
            }
        };
        Transition.prototype.error = function () {
            var state = this.$to();
            if (state.self.abstract) {
                return Rejection.invalid("Cannot transition to abstract state '" + state.name + "'");
            }
            var paramDefs = state.parameters();
            var values$$1 = this.params();
            var invalidParams = paramDefs.filter(function (param) { return !param.validates(values$$1[param.id]); });
            if (invalidParams.length) {
                var invalidValues = invalidParams.map(function (param) { return "[" + param.id + ":" + stringify(values$$1[param.id]) + "]"; }).join(', ');
                var detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
                return Rejection.invalid(detail);
            }
            if (this.success === false)
                return this._error;
        };
        Transition.prototype.toString = function () {
            var fromStateOrName = this.from();
            var toStateOrName = this.to();
            var avoidEmptyHash = function (params) {
                return params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);
            };
            var id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))), toValid = this.valid() ? '' : '(X) ', to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = stringify(avoidEmptyHash(this.params()));
            return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
        };
        Transition.diToken = Transition;
        return Transition;
    }());
    function maxLength(max, str) {
        if (str.length <= max)
            return str;
        return str.substr(0, max - 3) + '...';
    }
    function padString(length, str) {
        while (str.length < length)
            str += ' ';
        return str;
    }
    function kebobString(camelCase) {
        return camelCase
            .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); })
            .replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
    }
    function functionToString(fn) {
        var fnStr = fnToString(fn);
        var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
        var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
        var fnName = fn['name'] || '';
        if (fnName && toStr.match(/function \(/)) {
            return 'function ' + fnName + toStr.substr(9);
        }
        return toStr;
    }
    function fnToString(fn) {
        var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;
        return (_fn && _fn.toString()) || 'undefined';
    }
    var stringifyPatternFn = null;
    var stringifyPattern = function (value) {
        var isRejection = Rejection.isRejectionPromise;
        stringifyPatternFn =
            stringifyPatternFn ||
                pattern([
                    [not(isDefined), val('undefined')],
                    [isNull, val('null')],
                    [isPromise, val('[Promise]')],
                    [isRejection, function (x) { return x._transitionRejection.toString(); }],
                    [is(Rejection), invoke('toString')],
                    [is(Transition), invoke('toString')],
                    [is(Resolvable), invoke('toString')],
                    [isInjectable, functionToString],
                    [val(true), identity],
                ]);
        return stringifyPatternFn(value);
    };
    function stringify(o) {
        var seen = [];
        function format(value) {
            if (isObject(value)) {
                if (seen.indexOf(value) !== -1)
                    return '[circular ref]';
                seen.push(value);
            }
            return stringifyPattern(value);
        }
        return JSON.stringify(o, function (key, value) { return format(value); }).replace(/\\"/g, '"');
    }
    var beforeAfterSubstr = function (char) {
        return function (str) {
            if (!str)
                return ['', ''];
            var idx = str.indexOf(char);
            if (idx === -1)
                return [str, ''];
            return [str.substr(0, idx), str.substr(idx + 1)];
        };
    };
    var hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');
    var stripLastPathElement = function (str) { return str.replace(/\/[^/]*$/, ''); };
    var splitHash = beforeAfterSubstr('#');
    var splitQuery = beforeAfterSubstr('?');
    var splitEqual = beforeAfterSubstr('=');
    var trimHashVal = function (str) { return (str ? str.replace(/^#/, '') : ''); };
    function splitOnDelim(delim) {
        var re = new RegExp('(' + delim + ')', 'g');
        return function (str) { return str.split(re).filter(identity); };
    }
    function joinNeighborsR(acc, x) {
        if (isString(tail(acc)) && isString(x))
            return acc.slice(0, -1).concat(tail(acc) + x);
        return pushR(acc, x);
    }
    var ParamTypes = (function () {
        function ParamTypes() {
            this.enqueue = true;
            this.typeQueue = [];
            this.defaultTypes = pick(ParamTypes.prototype, [
                'hash',
                'string',
                'query',
                'path',
                'int',
                'bool',
                'date',
                'json',
                'any',
            ]);
            var makeType = function (definition, name) { return new ParamType(extend({ name: name }, definition)); };
            this.types = inherit(map(this.defaultTypes, makeType), {});
        }
        ParamTypes.prototype.dispose = function () {
            this.types = {};
        };
        ParamTypes.prototype.type = function (name, definition, definitionFn) {
            if (!isDefined(definition))
                return this.types[name];
            if (this.types.hasOwnProperty(name))
                throw new Error("A type named '" + name + "' has already been defined.");
            this.types[name] = new ParamType(extend({ name: name }, definition));
            if (definitionFn) {
                this.typeQueue.push({ name: name, def: definitionFn });
                if (!this.enqueue)
                    this._flushTypeQueue();
            }
            return this;
        };
        ParamTypes.prototype._flushTypeQueue = function () {
            while (this.typeQueue.length) {
                var type = this.typeQueue.shift();
                if (type.pattern)
                    throw new Error("You cannot override a type's .pattern at runtime.");
                extend(this.types[type.name], services.$injector.invoke(type.def));
            }
        };
        return ParamTypes;
    }());
    function initDefaultTypes() {
        var makeDefaultType = function (def) {
            var valToString = function (val$$1) { return (val$$1 != null ? val$$1.toString() : val$$1); };
            var defaultTypeBase = {
                encode: valToString,
                decode: valToString,
                is: is(String),
                pattern: /.*/,
                equals: function (a, b) { return a == b; },
            };
            return extend({}, defaultTypeBase, def);
        };
        extend(ParamTypes.prototype, {
            string: makeDefaultType({}),
            path: makeDefaultType({
                pattern: /[^/]*/,
            }),
            query: makeDefaultType({}),
            hash: makeDefaultType({
                inherit: false,
            }),
            int: makeDefaultType({
                decode: function (val$$1) { return parseInt(val$$1, 10); },
                is: function (val$$1) {
                    return !isNullOrUndefined(val$$1) && this.decode(val$$1.toString()) === val$$1;
                },
                pattern: /-?\d+/,
            }),
            bool: makeDefaultType({
                encode: function (val$$1) { return (val$$1 && 1) || 0; },
                decode: function (val$$1) { return parseInt(val$$1, 10) !== 0; },
                is: is(Boolean),
                pattern: /0|1/,
            }),
            date: makeDefaultType({
                encode: function (val$$1) {
                    return !this.is(val$$1)
                        ? undefined
                        : [val$$1.getFullYear(), ('0' + (val$$1.getMonth() + 1)).slice(-2), ('0' + val$$1.getDate()).slice(-2)].join('-');
                },
                decode: function (val$$1) {
                    if (this.is(val$$1))
                        return val$$1;
                    var match = this.capture.exec(val$$1);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function (val$$1) { return val$$1 instanceof Date && !isNaN(val$$1.valueOf()); },
                equals: function (l, r) {
                    return ['getFullYear', 'getMonth', 'getDate'].reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
            }),
            json: makeDefaultType({
                encode: toJson,
                decode: fromJson,
                is: is(Object),
                equals: equals,
                pattern: /[^/]*/,
            }),
            any: makeDefaultType({
                encode: identity,
                decode: identity,
                is: function () { return true; },
                equals: equals,
            }),
        });
    }
    initDefaultTypes();
    var StateParams = (function () {
        function StateParams(params) {
            if (params === void 0) {
                params = {};
            }
            extend(this, params);
        }
        StateParams.prototype.$inherit = function (newParams, $current, $to) {
            var parentParams;
            var parents = ancestors($current, $to), inherited = {}, inheritList = [];
            for (var i in parents) {
                if (!parents[i] || !parents[i].params)
                    continue;
                parentParams = Object.keys(parents[i].params);
                if (!parentParams.length)
                    continue;
                for (var j in parentParams) {
                    if (inheritList.indexOf(parentParams[j]) >= 0)
                        continue;
                    inheritList.push(parentParams[j]);
                    inherited[parentParams[j]] = this[parentParams[j]];
                }
            }
            return extend({}, inherited, newParams);
        };
        return StateParams;
    }());
    var parseUrl = function (url) {
        if (!isString(url))
            return false;
        var root$$1 = url.charAt(0) === '^';
        return { val: root$$1 ? url.substring(1) : url, root: root$$1 };
    };
    function nameBuilder(state) {
        return state.name;
    }
    function selfBuilder(state) {
        state.self.$$state = function () { return state; };
        return state.self;
    }
    function dataBuilder(state) {
        if (state.parent && state.parent.data) {
            state.data = state.self.data = inherit(state.parent.data, state.data);
        }
        return state.data;
    }
    var getUrlBuilder = function ($urlMatcherFactoryProvider, root$$1) {
        return function urlBuilder(state) {
            var stateDec = state;
            if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
                stateDec.url += '{remainder:any}';
            }
            var parsed = parseUrl(stateDec.url), parent = state.parent;
            var url = !parsed
                ? stateDec.url
                : $urlMatcherFactoryProvider.compile(parsed.val, {
                    params: state.params || {},
                    paramMap: function (paramConfig, isSearch) {
                        if (stateDec.reloadOnSearch === false && isSearch)
                            paramConfig = extend(paramConfig || {}, { dynamic: true });
                        return paramConfig;
                    },
                });
            if (!url)
                return null;
            if (!$urlMatcherFactoryProvider.isMatcher(url))
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            return parsed && parsed.root ? url : ((parent && parent.navigable) || root$$1()).url.append(url);
        };
    };
    var getNavigableBuilder = function (isRoot) {
        return function navigableBuilder(state) {
            return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
        };
    };
    var getParamsBuilder = function (paramFactory) {
        return function paramsBuilder(state) {
            var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };
            var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
            var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));
            return urlParams
                .concat(nonUrlParams)
                .map(function (p) { return [p.id, p]; })
                .reduce(applyPairs, {});
        };
    };
    function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : [state];
    }
    function includesBuilder(state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        includes[state.name] = true;
        return includes;
    }
    function resolvablesBuilder(state) {
        var objects2Tuples = function (resolveObj, resolvePolicies) {
            return Object.keys(resolveObj || {}).map(function (token) {
                return ({
                    token: token,
                    val: resolveObj[token],
                    deps: undefined,
                    policy: resolvePolicies[token],
                });
            });
        };
        var annotate = function (fn) {
            var $injector = services.$injector;
            return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || 'deferred';
        };
        var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
        var isLikeNg2Provider = function (obj) {
            return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
        };
        var isTupleFromObj = function (obj) {
            return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));
        };
        var getToken = function (p) { return p.provide || p.token; };
        var literal2Resolvable = pattern([
            [prop('resolveFn'), function (p) { return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy); }],
            [prop('useFactory'), function (p) { return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy); }],
            [prop('useClass'), function (p) { return new Resolvable(getToken(p), function () { return new p.useClass(); }, [], p.policy); }],
            [prop('useValue'), function (p) { return new Resolvable(getToken(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
            [prop('useExisting'), function (p) { return new Resolvable(getToken(p), identity, [p.useExisting], p.policy); }],
        ]);
        var tuple2Resolvable = pattern([
            [pipe(prop('val'), isString), function (tuple) { return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy); }],
            [
                pipe(prop('val'), isArray),
                function (tuple) { return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); },
            ],
            [
                pipe(prop('val'), isFunction),
                function (tuple) { return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); },
            ],
        ]);
        var item2Resolvable = pattern([
            [is(Resolvable), function (r) { return r; }],
            [isResolveLiteral, literal2Resolvable],
            [isLikeNg2Provider, literal2Resolvable],
            [isTupleFromObj, tuple2Resolvable],
            [
                val(true),
                function (obj) {
                    throw new Error('Invalid resolve value: ' + stringify(obj));
                },
            ],
        ]);
        var decl = state.resolve;
        var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
        return items.map(item2Resolvable);
    }
    var StateBuilder = (function () {
        function StateBuilder(matcher, urlMatcherFactory) {
            this.matcher = matcher;
            var self = this;
            var root$$1 = function () { return matcher.find(''); };
            var isRoot = function (state) { return state.name === ''; };
            function parentBuilder(state) {
                if (isRoot(state))
                    return null;
                return matcher.find(self.parentName(state)) || root$$1();
            }
            this.builders = {
                name: [nameBuilder],
                self: [selfBuilder],
                parent: [parentBuilder],
                data: [dataBuilder],
                url: [getUrlBuilder(urlMatcherFactory, root$$1)],
                navigable: [getNavigableBuilder(isRoot)],
                params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
                views: [],
                path: [pathBuilder],
                includes: [includesBuilder],
                resolvables: [resolvablesBuilder],
            };
        }
        StateBuilder.prototype.builder = function (name, fn) {
            var builders = this.builders;
            var array = builders[name] || [];
            if (isString(name) && !isDefined(fn))
                return array.length > 1 ? array : array[0];
            if (!isString(name) || !isFunction(fn))
                return;
            builders[name] = array;
            builders[name].push(fn);
            return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
        };
        StateBuilder.prototype.build = function (state) {
            var _a = this, matcher = _a.matcher, builders = _a.builders;
            var parent = this.parentName(state);
            if (parent && !matcher.find(parent, undefined, false)) {
                return null;
            }
            for (var key in builders) {
                if (!builders.hasOwnProperty(key))
                    continue;
                var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, noop);
                state[key] = chain(state);
            }
            return state;
        };
        StateBuilder.prototype.parentName = function (state) {
            var name = state.name || '';
            var segments = name.split('.');
            var lastSegment = segments.pop();
            if (lastSegment === '**')
                segments.pop();
            if (segments.length) {
                if (state.parent) {
                    throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                }
                return segments.join('.');
            }
            if (!state.parent)
                return '';
            return isString(state.parent) ? state.parent : state.parent.name;
        };
        StateBuilder.prototype.name = function (state) {
            var name = state.name;
            if (name.indexOf('.') !== -1 || !state.parent)
                return name;
            var parentName = isString(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + '.' + name : name;
        };
        return StateBuilder;
    }());
    var StateMatcher = (function () {
        function StateMatcher(_states) {
            this._states = _states;
        }
        StateMatcher.prototype.isRelative = function (stateName) {
            stateName = stateName || '';
            return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
        };
        StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
            if (matchGlob === void 0) {
                matchGlob = true;
            }
            if (!stateOrName && stateOrName !== '')
                return undefined;
            var isStr = isString(stateOrName);
            var name = isStr ? stateOrName : stateOrName.name;
            if (this.isRelative(name))
                name = this.resolvePath(name, base);
            var state = this._states[name];
            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                return state;
            }
            else if (isStr && matchGlob) {
                var _states = values(this._states);
                var matches = _states.filter(function (_state) { return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name); });
                if (matches.length > 1) {
                    console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
                }
                return matches[0];
            }
            return undefined;
        };
        StateMatcher.prototype.resolvePath = function (name, base) {
            if (!base)
                throw new Error("No reference point given for path '" + name + "'");
            var baseState = this.find(base);
            var splitName = name.split('.');
            var pathLength = splitName.length;
            var i = 0, current = baseState;
            for (; i < pathLength; i++) {
                if (splitName[i] === '' && i === 0) {
                    current = baseState;
                    continue;
                }
                if (splitName[i] === '^') {
                    if (!current.parent)
                        throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                    current = current.parent;
                    continue;
                }
                break;
            }
            var relName = splitName.slice(i).join('.');
            return current.name + (current.name && relName ? '.' : '') + relName;
        };
        return StateMatcher;
    }());
    var StateQueueManager = (function () {
        function StateQueueManager($registry, $urlRouter, states, builder, listeners) {
            this.$registry = $registry;
            this.$urlRouter = $urlRouter;
            this.states = states;
            this.builder = builder;
            this.listeners = listeners;
            this.queue = [];
            this.matcher = $registry.matcher;
        }
        StateQueueManager.prototype.dispose = function () {
            this.queue = [];
        };
        StateQueueManager.prototype.register = function (stateDecl) {
            var queue = this.queue;
            var state = StateObject.create(stateDecl);
            var name = state.name;
            if (!isString(name))
                throw new Error('State must have a valid name');
            if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))
                throw new Error("State '" + name + "' is already defined");
            queue.push(state);
            this.flush();
            return state;
        };
        StateQueueManager.prototype.flush = function () {
            var _this = this;
            var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
            var registered = [], orphans = [], previousQueueLength = {};
            var getState = function (name) { return _this.states.hasOwnProperty(name) && _this.states[name]; };
            var notifyListeners = function () {
                if (registered.length) {
                    _this.listeners.forEach(function (listener) { return listener('registered', registered.map(function (s) { return s.self; })); });
                }
            };
            while (queue.length > 0) {
                var state = queue.shift();
                var name_1 = state.name;
                var result = builder.build(state);
                var orphanIdx = orphans.indexOf(state);
                if (result) {
                    var existingState = getState(name_1);
                    if (existingState && existingState.name === name_1) {
                        throw new Error("State '" + name_1 + "' is already defined");
                    }
                    var existingFutureState = getState(name_1 + '.**');
                    if (existingFutureState) {
                        this.$registry.deregister(existingFutureState);
                    }
                    states[name_1] = state;
                    this.attachRoute(state);
                    if (orphanIdx >= 0)
                        orphans.splice(orphanIdx, 1);
                    registered.push(state);
                    continue;
                }
                var prev = previousQueueLength[name_1];
                previousQueueLength[name_1] = queue.length;
                if (orphanIdx >= 0 && prev === queue.length) {
                    queue.push(state);
                    notifyListeners();
                    return states;
                }
                else if (orphanIdx < 0) {
                    orphans.push(state);
                }
                queue.push(state);
            }
            notifyListeners();
            return states;
        };
        StateQueueManager.prototype.attachRoute = function (state) {
            if (state.abstract || !state.url)
                return;
            this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));
        };
        return StateQueueManager;
    }());
    var StateRegistry = (function () {
        function StateRegistry(_router) {
            this._router = _router;
            this.states = {};
            this.listeners = [];
            this.matcher = new StateMatcher(this.states);
            this.builder = new StateBuilder(this.matcher, _router.urlMatcherFactory);
            this.stateQueue = new StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);
            this._registerRoot();
        }
        StateRegistry.prototype._registerRoot = function () {
            var rootStateDef = {
                name: '',
                url: '^',
                views: null,
                params: {
                    '#': { value: null, type: 'hash', dynamic: true },
                },
                abstract: true,
            };
            var _root = (this._root = this.stateQueue.register(rootStateDef));
            _root.navigable = null;
        };
        StateRegistry.prototype.dispose = function () {
            var _this = this;
            this.stateQueue.dispose();
            this.listeners = [];
            this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
        };
        StateRegistry.prototype.onStatesChanged = function (listener) {
            this.listeners.push(listener);
            return function deregisterListener() {
                removeFrom(this.listeners)(listener);
            }.bind(this);
        };
        StateRegistry.prototype.root = function () {
            return this._root;
        };
        StateRegistry.prototype.register = function (stateDefinition) {
            return this.stateQueue.register(stateDefinition);
        };
        StateRegistry.prototype._deregisterTree = function (state) {
            var _this = this;
            var all$$1 = this.get().map(function (s) { return s.$$state(); });
            var getChildren = function (states) {
                var _children = all$$1.filter(function (s) { return states.indexOf(s.parent) !== -1; });
                return _children.length === 0 ? _children : _children.concat(getChildren(_children));
            };
            var children = getChildren([state]);
            var deregistered = [state].concat(children).reverse();
            deregistered.forEach(function (_state) {
                var $ur = _this._router.urlRouter;
                $ur
                    .rules()
                    .filter(propEq('state', _state))
                    .forEach($ur.removeRule.bind($ur));
                delete _this.states[_state.name];
            });
            return deregistered;
        };
        StateRegistry.prototype.deregister = function (stateOrName) {
            var _state = this.get(stateOrName);
            if (!_state)
                throw new Error("Can't deregister state; not found: " + stateOrName);
            var deregisteredStates = this._deregisterTree(_state.$$state());
            this.listeners.forEach(function (listener) { return listener('deregistered', deregisteredStates.map(function (s) { return s.self; })); });
            return deregisteredStates;
        };
        StateRegistry.prototype.get = function (stateOrName, base) {
            var _this = this;
            if (arguments.length === 0)
                return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
            var found = this.matcher.find(stateOrName, base);
            return (found && found.self) || null;
        };
        StateRegistry.prototype.decorator = function (name, func) {
            return this.builder.builder(name, func);
        };
        return StateRegistry;
    }());
    function quoteRegExp(str, param) {
        var surroundPattern = ['', ''], result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
        if (!param)
            return result;
        switch (param.squash) {
            case false:
                surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
                break;
            case true:
                result = result.replace(/\/$/, '');
                surroundPattern = ['(?:/(', ')|/)?'];
                break;
            default:
                surroundPattern = ["(" + param.squash + "|", ')?'];
                break;
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
    }
    var memoizeTo = function (obj, _prop, fn) { return (obj[_prop] = obj[_prop] || fn()); };
    var splitOnSlash = splitOnDelim('/');
    var UrlMatcher = (function () {
        function UrlMatcher(pattern$$1, paramTypes, paramFactory, config) {
            var _this = this;
            this.config = config;
            this._cache = { path: [this] };
            this._children = [];
            this._params = [];
            this._segments = [];
            this._compiled = [];
            this.pattern = pattern$$1;
            this.config = defaults(this.config, {
                params: {},
                strict: true,
                caseInsensitive: false,
                paramMap: identity,
            });
            var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var patterns = [];
            var last = 0, matchArray;
            var checkParamErrors = function (id) {
                if (!UrlMatcher.nameValidator.test(id))
                    throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern$$1 + "'");
                if (find(_this._params, propEq('id', id)))
                    throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern$$1 + "'");
            };
            var matchDetails = function (m, isSearch) {
                var id = m[2] || m[3];
                var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\s\\S]*' : null);
                var makeRegexpType = function (str) {
                    return inherit(paramTypes.type(isSearch ? 'query' : 'path'), {
                        pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined),
                    });
                };
                return {
                    id: id,
                    regexp: regexp,
                    cfg: _this.config.params[id],
                    segment: pattern$$1.substring(last, m.index),
                    type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),
                };
            };
            var p, segment;
            while ((matchArray = placeholder.exec(pattern$$1))) {
                p = matchDetails(matchArray, false);
                if (p.segment.indexOf('?') >= 0)
                    break;
                checkParamErrors(p.id);
                this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
                this._segments.push(p.segment);
                patterns.push([p.segment, tail(this._params)]);
                last = placeholder.lastIndex;
            }
            segment = pattern$$1.substring(last);
            var i = segment.indexOf('?');
            if (i >= 0) {
                var search = segment.substring(i);
                segment = segment.substring(0, i);
                if (search.length > 0) {
                    last = 0;
                    while ((matchArray = searchPlaceholder.exec(search))) {
                        p = matchDetails(matchArray, true);
                        checkParamErrors(p.id);
                        this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                        last = placeholder.lastIndex;
                    }
                }
            }
            this._segments.push(segment);
            this._compiled = patterns.map(function (_pattern) { return quoteRegExp.apply(null, _pattern); }).concat(quoteRegExp(segment));
        }
        UrlMatcher.encodeDashes = function (str) {
            return encodeURIComponent(str).replace(/-/g, function (c) {
                return "%5C%" + c
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
            });
        };
        UrlMatcher.pathSegmentsAndParams = function (matcher) {
            var staticSegments = matcher._segments;
            var pathParams = matcher._params.filter(function (p) { return p.location === exports.DefType.PATH; });
            return arrayTuples(staticSegments, pathParams.concat(undefined))
                .reduce(unnestR, [])
                .filter(function (x) { return x !== '' && isDefined(x); });
        };
        UrlMatcher.queryParams = function (matcher) {
            return matcher._params.filter(function (p) { return p.location === exports.DefType.SEARCH; });
        };
        UrlMatcher.compare = function (a, b) {
            var segments = function (matcher) {
                return (matcher._cache.segments =
                    matcher._cache.segments ||
                        matcher._cache.path
                            .map(UrlMatcher.pathSegmentsAndParams)
                            .reduce(unnestR, [])
                            .reduce(joinNeighborsR, [])
                            .map(function (x) { return (isString(x) ? splitOnSlash(x) : x); })
                            .reduce(unnestR, []));
            };
            var weights = function (matcher) {
                return (matcher._cache.weights =
                    matcher._cache.weights ||
                        segments(matcher).map(function (segment) {
                            if (segment === '/')
                                return 1;
                            if (isString(segment))
                                return 2;
                            if (segment instanceof Param)
                                return 3;
                        }));
            };
            var padArrays = function (l, r, padVal) {
                var len = Math.max(l.length, r.length);
                while (l.length < len)
                    l.push(padVal);
                while (r.length < len)
                    r.push(padVal);
            };
            var weightsA = weights(a), weightsB = weights(b);
            padArrays(weightsA, weightsB, 0);
            var _pairs = arrayTuples(weightsA, weightsB);
            var cmp, i;
            for (i = 0; i < _pairs.length; i++) {
                cmp = _pairs[i][0] - _pairs[i][1];
                if (cmp !== 0)
                    return cmp;
            }
            return 0;
        };
        UrlMatcher.prototype.append = function (url) {
            this._children.push(url);
            url._cache = {
                path: this._cache.path.concat(url),
                parent: this,
                pattern: null,
            };
            return url;
        };
        UrlMatcher.prototype.isRoot = function () {
            return this._cache.path[0] === this;
        };
        UrlMatcher.prototype.toString = function () {
            return this.pattern;
        };
        UrlMatcher.prototype.exec = function (path, search, hash, options) {
            var _this = this;
            if (search === void 0) {
                search = {};
            }
            if (options === void 0) {
                options = {};
            }
            var match = memoizeTo(this._cache, 'pattern', function () {
                return new RegExp([
                    '^',
                    unnest(_this._cache.path.map(prop('_compiled'))).join(''),
                    _this.config.strict === false ? '/?' : '',
                    '$',
                ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
            }).exec(path);
            if (!match)
                return null;
            var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values$$1 = {};
            if (nPathSegments !== match.length - 1)
                throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
            function decodePathArray(paramVal) {
                var reverseString = function (str) {
                    return str
                        .split('')
                        .reverse()
                        .join('');
                };
                var unquoteDashes = function (str) { return str.replace(/\\-/g, '-'); };
                var split = reverseString(paramVal).split(/-(?!\\)/);
                var allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse();
            }
            for (var i = 0; i < nPathSegments; i++) {
                var param = pathParams[i];
                var value = match[i + 1];
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (value && param.array === true)
                    value = decodePathArray(value);
                if (isDefined(value))
                    value = param.type.decode(value);
                values$$1[param.id] = param.value(value);
            }
            searchParams.forEach(function (param) {
                var value = search[param.id];
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (isDefined(value))
                    value = param.type.decode(value);
                values$$1[param.id] = param.value(value);
            });
            if (hash)
                values$$1['#'] = hash;
            return values$$1;
        };
        UrlMatcher.prototype.parameters = function (opts) {
            if (opts === void 0) {
                opts = {};
            }
            if (opts.inherit === false)
                return this._params;
            return unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
        };
        UrlMatcher.prototype.parameter = function (id, opts) {
            var _this = this;
            if (opts === void 0) {
                opts = {};
            }
            var findParam = function () {
                for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                    var param = _a[_i];
                    if (param.id === id)
                        return param;
                }
            };
            var parent = this._cache.parent;
            return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
        };
        UrlMatcher.prototype.validates = function (params) {
            var validParamVal = function (param, val$$1) { return !param || param.validates(val$$1); };
            params = params || {};
            var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
            return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(allTrueR, true);
        };
        UrlMatcher.prototype.format = function (values$$1) {
            if (values$$1 === void 0) {
                values$$1 = {};
            }
            var urlMatchers = this._cache.path;
            var pathSegmentsAndParams = urlMatchers
                .map(UrlMatcher.pathSegmentsAndParams)
                .reduce(unnestR, [])
                .map(function (x) { return (isString(x) ? x : getDetails(x)); });
            var queryParams = urlMatchers
                .map(UrlMatcher.queryParams)
                .reduce(unnestR, [])
                .map(getDetails);
            var isInvalid = function (param) { return param.isValid === false; };
            if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
                return null;
            }
            function getDetails(param) {
                var value = param.value(values$$1[param.id]);
                var isValid = param.validates(value);
                var isDefaultValue = param.isDefaultValue(value);
                var squash = isDefaultValue ? param.squash : false;
                var encoded = param.type.encode(value);
                return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
            }
            var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
                if (isString(x))
                    return acc + x;
                var squash = x.squash, encoded = x.encoded, param = x.param;
                if (squash === true)
                    return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
                if (isString(squash))
                    return acc + squash;
                if (squash !== false)
                    return acc;
                if (encoded == null)
                    return acc;
                if (isArray(encoded))
                    return acc + map(encoded, UrlMatcher.encodeDashes).join('-');
                if (param.raw)
                    return acc + encoded;
                return acc + encodeURIComponent(encoded);
            }, '');
            var queryString = queryParams
                .map(function (paramDetails) {
                var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
                if (encoded == null || (isDefaultValue && squash !== false))
                    return;
                if (!isArray(encoded))
                    encoded = [encoded];
                if (encoded.length === 0)
                    return;
                if (!param.raw)
                    encoded = map(encoded, encodeURIComponent);
                return encoded.map(function (val$$1) { return param.id + "=" + val$$1; });
            })
                .filter(identity)
                .reduce(unnestR, [])
                .join('&');
            return pathString + (queryString ? "?" + queryString : '') + (values$$1['#'] ? '#' + values$$1['#'] : '');
        };
        UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
        return UrlMatcher;
    }());
    var UrlMatcherFactory = (function () {
        function UrlMatcherFactory() {
            var _this = this;
            this.paramTypes = new ParamTypes();
            this._isCaseInsensitive = false;
            this._isStrictMode = true;
            this._defaultSquashPolicy = false;
            this.paramFactory = {
                fromConfig: function (id, type, config) { return new Param(id, type, config, exports.DefType.CONFIG, _this); },
                fromPath: function (id, type, config) { return new Param(id, type, config, exports.DefType.PATH, _this); },
                fromSearch: function (id, type, config) { return new Param(id, type, config, exports.DefType.SEARCH, _this); },
            };
            this._getConfig = function (config) {
                return extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);
            };
            extend(this, { UrlMatcher: UrlMatcher, Param: Param });
        }
        UrlMatcherFactory.prototype.caseInsensitive = function (value) {
            return (this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive);
        };
        UrlMatcherFactory.prototype.strictMode = function (value) {
            return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);
        };
        UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {
            if (isDefined(value) && value !== true && value !== false && !isString(value))
                throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return (this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy);
        };
        UrlMatcherFactory.prototype.compile = function (pattern, config) {
            return new UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));
        };
        UrlMatcherFactory.prototype.isMatcher = function (object) {
            if (!isObject(object))
                return false;
            var result = true;
            forEach(UrlMatcher.prototype, function (val, name) {
                if (isFunction(val))
                    result = result && (isDefined(object[name]) && isFunction(object[name]));
            });
            return result;
        };
        UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {
            var type = this.paramTypes.type(name, definition, definitionFn);
            return !isDefined(definition) ? type : this;
        };
        UrlMatcherFactory.prototype.$get = function () {
            this.paramTypes.enqueue = false;
            this.paramTypes._flushTypeQueue();
            return this;
        };
        UrlMatcherFactory.prototype.dispose = function () {
            this.paramTypes.dispose();
        };
        return UrlMatcherFactory;
    }());
    var UrlRuleFactory = (function () {
        function UrlRuleFactory(router) {
            this.router = router;
        }
        UrlRuleFactory.prototype.compile = function (str) {
            return this.router.urlMatcherFactory.compile(str);
        };
        UrlRuleFactory.prototype.create = function (what, handler) {
            var _this = this;
            var makeRule = pattern([
                [isString, function (_what) { return makeRule(_this.compile(_what)); }],
                [is(UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
                [isState, function (_what) { return _this.fromState(_what, _this.router); }],
                [is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
                [isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
            ]);
            var rule = makeRule(what);
            if (!rule)
                throw new Error("invalid 'what' in when()");
            return rule;
        };
        UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
            var _handler = handler;
            if (isString(handler))
                handler = this.router.urlMatcherFactory.compile(handler);
            if (is(UrlMatcher)(handler))
                _handler = function (match) { return handler.format(match); };
            function matchUrlParamters(url) {
                var params = urlMatcher.exec(url.path, url.search, url.hash);
                return urlMatcher.validates(params) && params;
            }
            function matchPriority(params) {
                var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
                if (!optional.length)
                    return 0.000001;
                var matched = optional.filter(function (param) { return params[param.id]; });
                return matched.length / optional.length;
            }
            var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: 'URLMATCHER' };
            return extend(new BaseUrlRule(matchUrlParamters, _handler), details);
        };
        UrlRuleFactory.prototype.fromState = function (state, router) {
            var handler = function (match) {
                var $state = router.stateService;
                var globals = router.globals;
                if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                    $state.transitionTo(state, match, { inherit: true, source: 'url' });
                }
            };
            var details = { state: state, type: 'STATE' };
            return extend(this.fromUrlMatcher(state.url, handler), details);
        };
        UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
            if (regexp.global || regexp.sticky)
                throw new Error('Rule RegExp must not be global or sticky');
            var redirectUrlTo = function (match) {
                return handler.replace(/\$(\$|\d{1,2})/, function (m, what) { return match[what === '$' ? 0 : Number(what)]; });
            };
            var _handler = isString(handler) ? redirectUrlTo : handler;
            var matchParamsFromRegexp = function (url) { return regexp.exec(url.path); };
            var details = { regexp: regexp, type: 'REGEXP' };
            return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);
        };
        UrlRuleFactory.isUrlRule = function (obj) { return obj && ['type', 'match', 'handler'].every(function (key) { return isDefined(obj[key]); }); };
        return UrlRuleFactory;
    }());
    var BaseUrlRule = (function () {
        function BaseUrlRule(match, handler) {
            var _this = this;
            this.match = match;
            this.type = 'RAW';
            this.matchPriority = function (match) { return 0 - _this.$id; };
            this.handler = handler || identity;
        }
        return BaseUrlRule;
    }());
    function appendBasePath(url, isHtml5, absolute, baseHref) {
        if (baseHref === '/')
            return url;
        if (isHtml5)
            return stripLastPathElement(baseHref) + url;
        if (absolute)
            return baseHref.slice(1) + url;
        return url;
    }
    var prioritySort = function (a, b) { return (b.priority || 0) - (a.priority || 0); };
    var typeSort = function (a, b) {
        var weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
        return (weights[a.type] || 0) - (weights[b.type] || 0);
    };
    var urlMatcherSort = function (a, b) {
        return !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
    };
    var idSort = function (a, b) {
        var useMatchPriority = { STATE: true, URLMATCHER: true };
        var equal = useMatchPriority[a.type] && useMatchPriority[b.type];
        return equal ? 0 : (a.$id || 0) - (b.$id || 0);
    };
    var defaultRuleSortFn;
    defaultRuleSortFn = function (a, b) {
        var cmp = prioritySort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = typeSort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = urlMatcherSort(a, b);
        if (cmp !== 0)
            return cmp;
        return idSort(a, b);
    };
    var UrlRouter = (function () {
        function UrlRouter(router) {
            this._sortFn = defaultRuleSortFn;
            this._rules = [];
            this.interceptDeferred = false;
            this._id = 0;
            this._sorted = false;
            this._router = router;
            this.urlRuleFactory = new UrlRuleFactory(router);
            createProxyFunctions(val(UrlRouter.prototype), this, val(this));
        }
        UrlRouter.prototype.dispose = function () {
            this.listen(false);
            this._rules = [];
            delete this._otherwiseFn;
        };
        UrlRouter.prototype.sort = function (compareFn) {
            this._rules = this.stableSort(this._rules, (this._sortFn = compareFn || this._sortFn));
            this._sorted = true;
        };
        UrlRouter.prototype.ensureSorted = function () {
            this._sorted || this.sort();
        };
        UrlRouter.prototype.stableSort = function (arr, compareFn) {
            var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });
            arrOfWrapper.sort(function (wrapperA, wrapperB) {
                var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
                return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
            });
            return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });
        };
        UrlRouter.prototype.match = function (url) {
            var _this = this;
            this.ensureSorted();
            url = extend({ path: '', search: {}, hash: '' }, url);
            var rules = this.rules();
            if (this._otherwiseFn)
                rules.push(this._otherwiseFn);
            var checkRule = function (rule) {
                var match = rule.match(url, _this._router);
                return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
            };
            var best;
            for (var i = 0; i < rules.length; i++) {
                if (best && this._sortFn(rules[i], best.rule) !== 0)
                    break;
                var current = checkRule(rules[i]);
                best = !best || (current && current.weight > best.weight) ? current : best;
            }
            return best;
        };
        UrlRouter.prototype.sync = function (evt) {
            if (evt && evt.defaultPrevented)
                return;
            var router = this._router, $url = router.urlService, $state = router.stateService;
            var url = {
                path: $url.path(),
                search: $url.search(),
                hash: $url.hash(),
            };
            var best = this.match(url);
            var applyResult = pattern([
                [isString, function (newurl) { return $url.url(newurl, true); }],
                [TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],
                [is(TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],
            ]);
            applyResult(best && best.rule.handler(best.match, url, router));
        };
        UrlRouter.prototype.listen = function (enabled) {
            var _this = this;
            if (enabled === false) {
                this._stopFn && this._stopFn();
                delete this._stopFn;
            }
            else {
                return (this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); }));
            }
        };
        UrlRouter.prototype.update = function (read) {
            var $url = this._router.locationService;
            if (read) {
                this.location = $url.url();
                return;
            }
            if ($url.url() === this.location)
                return;
            $url.url(this.location, true);
        };
        UrlRouter.prototype.push = function (urlMatcher, params, options) {
            var replace = options && !!options.replace;
            this._router.urlService.url(urlMatcher.format(params || {}), replace);
        };
        UrlRouter.prototype.href = function (urlMatcher, params, options) {
            var url = urlMatcher.format(params);
            if (url == null)
                return null;
            options = options || { absolute: false };
            var cfg = this._router.urlService.config;
            var isHtml5 = cfg.html5Mode();
            if (!isHtml5 && url !== null) {
                url = '#' + cfg.hashPrefix() + url;
            }
            url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
            if (!options.absolute || !url) {
                return url;
            }
            var slash = !isHtml5 && url ? '/' : '';
            var cfgPort = cfg.port();
            var port = (cfgPort === 80 || cfgPort === 443 ? '' : ':' + cfgPort);
            return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
        };
        UrlRouter.prototype.rule = function (rule) {
            var _this = this;
            if (!UrlRuleFactory.isUrlRule(rule))
                throw new Error('invalid rule');
            rule.$id = this._id++;
            rule.priority = rule.priority || 0;
            this._rules.push(rule);
            this._sorted = false;
            return function () { return _this.removeRule(rule); };
        };
        UrlRouter.prototype.removeRule = function (rule) {
            removeFrom(this._rules, rule);
        };
        UrlRouter.prototype.rules = function () {
            this.ensureSorted();
            return this._rules.slice();
        };
        UrlRouter.prototype.otherwise = function (handler) {
            var handlerFn = getHandlerFn(handler);
            this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
            this._sorted = false;
        };
        UrlRouter.prototype.initial = function (handler) {
            var handlerFn = getHandlerFn(handler);
            var matchFn = function (urlParts, router) {
                return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
            };
            this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
        };
        UrlRouter.prototype.when = function (matcher, handler, options) {
            var rule = this.urlRuleFactory.create(matcher, handler);
            if (isDefined(options && options.priority))
                rule.priority = options.priority;
            this.rule(rule);
            return rule;
        };
        UrlRouter.prototype.deferIntercept = function (defer) {
            if (defer === undefined)
                defer = true;
            this.interceptDeferred = defer;
        };
        return UrlRouter;
    }());
    function getHandlerFn(handler) {
        if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {
            throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
        }
        return isFunction(handler) ? handler : val(handler);
    }
    var ViewService = (function () {
        function ViewService() {
            var _this = this;
            this._uiViews = [];
            this._viewConfigs = [];
            this._viewConfigFactories = {};
            this._listeners = [];
            this._pluginapi = {
                _rootViewContext: this._rootViewContext.bind(this),
                _viewConfigFactory: this._viewConfigFactory.bind(this),
                _registeredUIViews: function () { return _this._uiViews; },
                _activeViewConfigs: function () { return _this._viewConfigs; },
                _onSync: function (listener) {
                    _this._listeners.push(listener);
                    return function () { return removeFrom(_this._listeners, listener); };
                },
            };
        }
        ViewService.normalizeUIViewTarget = function (context, rawViewName) {
            if (rawViewName === void 0) {
                rawViewName = '';
            }
            var viewAtContext = rawViewName.split('@');
            var uiViewName = viewAtContext[0] || '$default';
            var uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : '^';
            var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
            if (relativeViewNameSugar) {
                uiViewContextAnchor = relativeViewNameSugar[1];
                uiViewName = relativeViewNameSugar[2];
            }
            if (uiViewName.charAt(0) === '!') {
                uiViewName = uiViewName.substr(1);
                uiViewContextAnchor = '';
            }
            var relativeMatch = /^(\^(?:\.\^)*)$/;
            if (relativeMatch.exec(uiViewContextAnchor)) {
                var anchorState = uiViewContextAnchor.split('.').reduce(function (anchor, x) { return anchor.parent; }, context);
                uiViewContextAnchor = anchorState.name;
            }
            else if (uiViewContextAnchor === '.') {
                uiViewContextAnchor = context.name;
            }
            return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
        };
        ViewService.prototype._rootViewContext = function (context) {
            return (this._rootContext = context || this._rootContext);
        };
        ViewService.prototype._viewConfigFactory = function (viewType, factory) {
            this._viewConfigFactories[viewType] = factory;
        };
        ViewService.prototype.createViewConfig = function (path, decl) {
            var cfgFactory = this._viewConfigFactories[decl.$type];
            if (!cfgFactory)
                throw new Error('ViewService: No view config factory registered for type ' + decl.$type);
            var cfgs = cfgFactory(path, decl);
            return isArray(cfgs) ? cfgs : [cfgs];
        };
        ViewService.prototype.deactivateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('<- Removing', viewConfig);
            removeFrom(this._viewConfigs, viewConfig);
        };
        ViewService.prototype.activateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('-> Registering', viewConfig);
            this._viewConfigs.push(viewConfig);
        };
        ViewService.prototype.sync = function () {
            var _this = this;
            var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(applyPairs, {});
            function uiViewDepth(uiView) {
                var stateDepth = function (context) { return (context && context.parent ? stateDepth(context.parent) + 1 : 1); };
                return uiView.fqn.split('.').length * 10000 + stateDepth(uiView.creationContext);
            }
            function viewConfigDepth(config) {
                var context = config.viewDecl.$context, count = 0;
                while (++count && context.parent)
                    context = context.parent;
                return count;
            }
            var depthCompare = curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
            var matchingConfigPair = function (uiView) {
                var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                if (matchingConfigs.length > 1) {
                    matchingConfigs.sort(depthCompare(viewConfigDepth, -1));
                }
                return { uiView: uiView, viewConfig: matchingConfigs[0] };
            };
            var configureUIView = function (tuple) {
                if (_this._uiViews.indexOf(tuple.uiView) !== -1)
                    tuple.uiView.configUpdated(tuple.viewConfig);
            };
            var uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);
            var matchedViewConfigs = uiViewTuples.map(function (tuple) { return tuple.viewConfig; });
            var unmatchedConfigTuples = this._viewConfigs
                .filter(function (config) { return !inArray(matchedViewConfigs, config); })
                .map(function (viewConfig) { return ({ uiView: undefined, viewConfig: viewConfig }); });
            uiViewTuples.forEach(configureUIView);
            var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
            this._listeners.forEach(function (cb) { return cb(allTuples); });
            trace.traceViewSync(allTuples);
        };
        ViewService.prototype.registerUIView = function (uiView) {
            trace.traceViewServiceUIViewEvent('-> Registering', uiView);
            var uiViews = this._uiViews;
            var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };
            if (uiViews.filter(fqnAndTypeMatches).length)
                trace.traceViewServiceUIViewEvent('!!!! duplicate uiView named:', uiView);
            uiViews.push(uiView);
            this.sync();
            return function () {
                var idx = uiViews.indexOf(uiView);
                if (idx === -1) {
                    trace.traceViewServiceUIViewEvent('Tried removing non-registered uiView', uiView);
                    return;
                }
                trace.traceViewServiceUIViewEvent('<- Deregistering', uiView);
                removeFrom(uiViews)(uiView);
            };
        };
        ViewService.prototype.available = function () {
            return this._uiViews.map(prop('fqn'));
        };
        ViewService.prototype.active = function () {
            return this._uiViews.filter(prop('$config')).map(prop('name'));
        };
        ViewService.matches = function (uiViewsByFqn, uiView) {
            return function (viewConfig) {
                if (uiView.$type !== viewConfig.viewDecl.$type)
                    return false;
                var vc = viewConfig.viewDecl;
                var vcSegments = vc.$uiViewName.split('.');
                var uivSegments = uiView.fqn.split('.');
                if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
                    return false;
                var negOffset = 1 - vcSegments.length || undefined;
                var fqnToFirstSegment = uivSegments.slice(0, negOffset).join('.');
                var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
                return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
            };
        };
        return ViewService;
    }());
    var UIRouterGlobals = (function () {
        function UIRouterGlobals() {
            this.params = new StateParams();
            this.lastStartedTransitionId = -1;
            this.transitionHistory = new Queue([], 1);
            this.successfulTransitions = new Queue([], 1);
        }
        UIRouterGlobals.prototype.dispose = function () {
            this.transitionHistory.clear();
            this.successfulTransitions.clear();
            this.transition = null;
        };
        return UIRouterGlobals;
    }());
    var makeStub = function (keys) {
        return keys.reduce(function (acc, key) { return ((acc[key] = notImplemented(key)), acc); }, { dispose: noop });
    };
    var locationServicesFns = ['url', 'path', 'search', 'hash', 'onChange'];
    var locationConfigFns = ['port', 'protocol', 'host', 'baseHref', 'html5Mode', 'hashPrefix'];
    var umfFns = ['type', 'caseInsensitive', 'strictMode', 'defaultSquashPolicy'];
    var rulesFns = ['sort', 'when', 'initial', 'otherwise', 'rules', 'rule', 'removeRule'];
    var syncFns = ['deferIntercept', 'listen', 'sync', 'match'];
    var UrlService = (function () {
        function UrlService(router, lateBind) {
            if (lateBind === void 0) {
                lateBind = true;
            }
            this.router = router;
            this.rules = {};
            this.config = {};
            var locationServices = function () { return router.locationService; };
            createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);
            var locationConfig = function () { return router.locationConfig; };
            createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);
            var umf = function () { return router.urlMatcherFactory; };
            createProxyFunctions(umf, this.config, umf, umfFns);
            var urlRouter = function () { return router.urlRouter; };
            createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);
            createProxyFunctions(urlRouter, this, urlRouter, syncFns);
        }
        UrlService.prototype.url = function (newurl, replace, state) {
            return;
        };
        UrlService.prototype.path = function () {
            return;
        };
        UrlService.prototype.search = function () {
            return;
        };
        UrlService.prototype.hash = function () {
            return;
        };
        UrlService.prototype.onChange = function (callback) {
            return;
        };
        UrlService.prototype.parts = function () {
            return { path: this.path(), search: this.search(), hash: this.hash() };
        };
        UrlService.prototype.dispose = function () { };
        UrlService.prototype.sync = function (evt) {
            return;
        };
        UrlService.prototype.listen = function (enabled) {
            return;
        };
        UrlService.prototype.deferIntercept = function (defer) {
            return;
        };
        UrlService.prototype.match = function (urlParts) {
            return;
        };
        UrlService.locationServiceStub = makeStub(locationServicesFns);
        UrlService.locationConfigStub = makeStub(locationConfigFns);
        return UrlService;
    }());
    var _routerInstance = 0;
    var UIRouter = (function () {
        function UIRouter(locationService, locationConfig) {
            if (locationService === void 0) {
                locationService = UrlService.locationServiceStub;
            }
            if (locationConfig === void 0) {
                locationConfig = UrlService.locationConfigStub;
            }
            this.locationService = locationService;
            this.locationConfig = locationConfig;
            this.$id = _routerInstance++;
            this._disposed = false;
            this._disposables = [];
            this.trace = trace;
            this.viewService = new ViewService();
            this.globals = new UIRouterGlobals();
            this.transitionService = new TransitionService(this);
            this.urlMatcherFactory = new UrlMatcherFactory();
            this.urlRouter = new UrlRouter(this);
            this.stateRegistry = new StateRegistry(this);
            this.stateService = new StateService(this);
            this.urlService = new UrlService(this);
            this._plugins = {};
            this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
            this.globals.$current = this.stateRegistry.root();
            this.globals.current = this.globals.$current.self;
            this.disposable(this.globals);
            this.disposable(this.stateService);
            this.disposable(this.stateRegistry);
            this.disposable(this.transitionService);
            this.disposable(this.urlRouter);
            this.disposable(locationService);
            this.disposable(locationConfig);
        }
        UIRouter.prototype.disposable = function (disposable) {
            this._disposables.push(disposable);
        };
        UIRouter.prototype.dispose = function (disposable) {
            var _this = this;
            if (disposable && isFunction(disposable.dispose)) {
                disposable.dispose(this);
                return undefined;
            }
            this._disposed = true;
            this._disposables.slice().forEach(function (d) {
                try {
                    typeof d.dispose === 'function' && d.dispose(_this);
                    removeFrom(_this._disposables, d);
                }
                catch (ignored) { }
            });
        };
        UIRouter.prototype.plugin = function (plugin, options) {
            if (options === void 0) {
                options = {};
            }
            var pluginInstance = new plugin(this, options);
            if (!pluginInstance.name)
                throw new Error('Required property `name` missing on plugin: ' + pluginInstance);
            this._disposables.push(pluginInstance);
            return (this._plugins[pluginInstance.name] = pluginInstance);
        };
        UIRouter.prototype.getPlugin = function (pluginName) {
            return pluginName ? this._plugins[pluginName] : values(this._plugins);
        };
        return UIRouter;
    }());
    function addCoreResolvables(trans) {
        trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');
        trans.addResolvable(Resolvable.fromData(Transition, trans), '');
        trans.addResolvable(Resolvable.fromData('$transition$', trans), '');
        trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');
        trans.entering().forEach(function (state) {
            trans.addResolvable(Resolvable.fromData('$state$', state), state);
        });
    }
    var registerAddCoreResolvables = function (transitionService) {
        return transitionService.onCreate({}, addCoreResolvables);
    };
    var TRANSITION_TOKENS = ['$transition$', Transition];
    var isTransition = inArray(TRANSITION_TOKENS);
    var treeChangesCleanup = function (trans) {
        var nodes = values(trans.treeChanges())
            .reduce(unnestR, [])
            .reduce(uniqR, []);
        var replaceTransitionWithNull = function (r) {
            return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;
        };
        nodes.forEach(function (node) {
            node.resolvables = node.resolvables.map(replaceTransitionWithNull);
        });
    };
    var redirectToHook = function (trans) {
        var redirect = trans.to().redirectTo;
        if (!redirect)
            return;
        var $state = trans.router.stateService;
        function handleResult(result) {
            if (!result)
                return;
            if (result instanceof TargetState)
                return result;
            if (isString(result))
                return $state.target(result, trans.params(), trans.options());
            if (result['state'] || result['params'])
                return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
        }
        if (isFunction(redirect)) {
            return services.$q.when(redirect(trans)).then(handleResult);
        }
        return handleResult(redirect);
    };
    var registerRedirectToHook = function (transitionService) {
        return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
    };
    function makeEnterExitRetainHook(hookName) {
        return function (transition, state) {
            var _state = state.$$state();
            var hookFn = _state[hookName];
            return hookFn(transition, state);
        };
    }
    var onExitHook = makeEnterExitRetainHook('onExit');
    var registerOnExitHook = function (transitionService) {
        return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
    };
    var onRetainHook = makeEnterExitRetainHook('onRetain');
    var registerOnRetainHook = function (transitionService) {
        return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
    };
    var onEnterHook = makeEnterExitRetainHook('onEnter');
    var registerOnEnterHook = function (transitionService) {
        return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
    };
    var RESOLVE_HOOK_PRIORITY = 1000;
    var eagerResolvePath = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);
    };
    var registerEagerResolvePath = function (transitionService) {
        return transitionService.onStart({}, eagerResolvePath, { priority: RESOLVE_HOOK_PRIORITY });
    };
    var lazyResolveState = function (trans, state) {
        return new ResolveContext(trans.treeChanges().to)
            .subContext(state.$$state())
            .resolvePath('LAZY', trans)
            .then(noop);
    };
    var registerLazyResolveState = function (transitionService) {
        return transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: RESOLVE_HOOK_PRIORITY });
    };
    var resolveRemaining = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);
    };
    var registerResolveRemaining = function (transitionService) {
        return transitionService.onFinish({}, resolveRemaining, { priority: RESOLVE_HOOK_PRIORITY });
    };
    var loadEnteringViews = function (transition) {
        var $q = services.$q;
        var enteringViews = transition.views('entering');
        if (!enteringViews.length)
            return;
        return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(noop);
    };
    var registerLoadEnteringViews = function (transitionService) {
        return transitionService.onFinish({}, loadEnteringViews);
    };
    var activateViews = function (transition) {
        var enteringViews = transition.views('entering');
        var exitingViews = transition.views('exiting');
        if (!enteringViews.length && !exitingViews.length)
            return;
        var $view = transition.router.viewService;
        exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
        enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
        $view.sync();
    };
    var registerActivateViews = function (transitionService) {
        return transitionService.onSuccess({}, activateViews);
    };
    var updateGlobalState = function (trans) {
        var globals = trans.router.globals;
        var transitionSuccessful = function () {
            globals.successfulTransitions.enqueue(trans);
            globals.$current = trans.$to();
            globals.current = globals.$current.self;
            copy(trans.params(), globals.params);
        };
        var clearCurrentTransition = function () {
            if (globals.transition === trans)
                globals.transition = null;
        };
        trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
        trans.promise.then(clearCurrentTransition, clearCurrentTransition);
    };
    var registerUpdateGlobalState = function (transitionService) {
        return transitionService.onCreate({}, updateGlobalState);
    };
    var updateUrl = function (transition) {
        var options = transition.options();
        var $state = transition.router.stateService;
        var $urlRouter = transition.router.urlRouter;
        if (options.source !== 'url' && options.location && $state.$current.navigable) {
            var urlOptions = { replace: options.location === 'replace' };
            $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
        }
        $urlRouter.update(true);
    };
    var registerUpdateUrl = function (transitionService) {
        return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
    };
    var lazyLoadHook = function (transition) {
        var router = transition.router;
        function retryTransition() {
            if (transition.originalTransition().options().source !== 'url') {
                var orig = transition.targetState();
                return router.stateService.target(orig.identifier(), orig.params(), orig.options());
            }
            var $url = router.urlService;
            var result = $url.match($url.parts());
            var rule = result && result.rule;
            if (rule && rule.type === 'STATE') {
                var state = rule.state;
                var params = result.match;
                return router.stateService.target(state, params, transition.options());
            }
            router.urlService.sync();
        }
        var promises = transition
            .entering()
            .filter(function (state) { return !!state.$$state().lazyLoad; })
            .map(function (state) { return lazyLoadState(transition, state); });
        return services.$q.all(promises).then(retryTransition);
    };
    var registerLazyLoadHook = function (transitionService) {
        return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
    };
    function lazyLoadState(transition, state) {
        var lazyLoadFn = state.$$state().lazyLoad;
        var promise = lazyLoadFn['_promise'];
        if (!promise) {
            var success = function (result) {
                delete state.lazyLoad;
                delete state.$$state().lazyLoad;
                delete lazyLoadFn['_promise'];
                return result;
            };
            var error = function (err) {
                delete lazyLoadFn['_promise'];
                return services.$q.reject(err);
            };
            promise = lazyLoadFn['_promise'] = services.$q
                .when(lazyLoadFn(transition, state))
                .then(updateStateRegistry)
                .then(success, error);
        }
        function updateStateRegistry(result) {
            if (result && Array.isArray(result.states)) {
                result.states.forEach(function (_state) { return transition.router.stateRegistry.register(_state); });
            }
            return result;
        }
        return promise;
    }
    var TransitionEventType = (function () {
        function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) {
                reverseSort = false;
            }
            if (getResultHandler === void 0) {
                getResultHandler = TransitionHook.HANDLE_RESULT;
            }
            if (getErrorHandler === void 0) {
                getErrorHandler = TransitionHook.REJECT_ERROR;
            }
            if (synchronous === void 0) {
                synchronous = false;
            }
            this.name = name;
            this.hookPhase = hookPhase;
            this.hookOrder = hookOrder;
            this.criteriaMatchPath = criteriaMatchPath;
            this.reverseSort = reverseSort;
            this.getResultHandler = getResultHandler;
            this.getErrorHandler = getErrorHandler;
            this.synchronous = synchronous;
        }
        return TransitionEventType;
    }());
    function ignoredHook(trans) {
        var ignoredReason = trans._ignoredReason();
        if (!ignoredReason)
            return;
        trace.traceTransitionIgnored(trans);
        var pending = trans.router.globals.transition;
        if (ignoredReason === 'SameAsCurrent' && pending) {
            pending.abort();
        }
        return Rejection.ignored().toPromise();
    }
    var registerIgnoredTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
    };
    function invalidTransitionHook(trans) {
        if (!trans.valid()) {
            throw new Error(trans.error().toString());
        }
    }
    var registerInvalidTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
    };
    var defaultTransOpts = {
        location: true,
        relative: null,
        inherit: false,
        notify: true,
        reload: false,
        custom: {},
        current: function () { return null; },
        source: 'unknown',
    };
    var TransitionService = (function () {
        function TransitionService(_router) {
            this._transitionCount = 0;
            this._eventTypes = [];
            this._registeredHooks = {};
            this._criteriaPaths = {};
            this._router = _router;
            this.$view = _router.viewService;
            this._deregisterHookFns = {};
            this._pluginapi = createProxyFunctions(val(this), {}, val(this), [
                '_definePathType',
                '_defineEvent',
                '_getPathTypes',
                '_getEvents',
                'getHooks',
            ]);
            this._defineCorePaths();
            this._defineCoreEvents();
            this._registerCoreTransitionHooks();
            _router.globals.successfulTransitions.onEvict(treeChangesCleanup);
        }
        TransitionService.prototype.onCreate = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.onError = function (criteria, callback, options) {
            return;
        };
        TransitionService.prototype.dispose = function (router) {
            values(this._registeredHooks).forEach(function (hooksArray) {
                return hooksArray.forEach(function (hook) {
                    hook._deregistered = true;
                    removeFrom(hooksArray, hook);
                });
            });
        };
        TransitionService.prototype.create = function (fromPath, targetState) {
            return new Transition(fromPath, targetState, this._router);
        };
        TransitionService.prototype._defineCoreEvents = function () {
            var Phase = exports.TransitionHookPhase;
            var TH = TransitionHook;
            var paths = this._criteriaPaths;
            var NORMAL_SORT = false, REVERSE_SORT = true;
            var SYNCHRONOUS = true;
            this._defineEvent('onCreate', Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
            this._defineEvent('onBefore', Phase.BEFORE, 0, paths.to);
            this._defineEvent('onStart', Phase.RUN, 0, paths.to);
            this._defineEvent('onExit', Phase.RUN, 100, paths.exiting, REVERSE_SORT);
            this._defineEvent('onRetain', Phase.RUN, 200, paths.retained);
            this._defineEvent('onEnter', Phase.RUN, 300, paths.entering);
            this._defineEvent('onFinish', Phase.RUN, 400, paths.to);
            this._defineEvent('onSuccess', Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
            this._defineEvent('onError', Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        };
        TransitionService.prototype._defineCorePaths = function () {
            var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;
            this._definePathType('to', TRANSITION);
            this._definePathType('from', TRANSITION);
            this._definePathType('exiting', STATE);
            this._definePathType('retained', STATE);
            this._definePathType('entering', STATE);
        };
        TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) {
                reverseSort = false;
            }
            if (getResultHandler === void 0) {
                getResultHandler = TransitionHook.HANDLE_RESULT;
            }
            if (getErrorHandler === void 0) {
                getErrorHandler = TransitionHook.REJECT_ERROR;
            }
            if (synchronous === void 0) {
                synchronous = false;
            }
            var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
            this._eventTypes.push(eventType);
            makeEvent(this, this, eventType);
        };
        TransitionService.prototype._getEvents = function (phase) {
            var transitionHookTypes = isDefined(phase)
                ? this._eventTypes.filter(function (type) { return type.hookPhase === phase; })
                : this._eventTypes.slice();
            return transitionHookTypes.sort(function (l, r) {
                var cmpByPhase = l.hookPhase - r.hookPhase;
                return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
            });
        };
        TransitionService.prototype._definePathType = function (name, hookScope) {
            this._criteriaPaths[name] = { name: name, scope: hookScope };
        };
        TransitionService.prototype._getPathTypes = function () {
            return this._criteriaPaths;
        };
        TransitionService.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        TransitionService.prototype._registerCoreTransitionHooks = function () {
            var fns = this._deregisterHookFns;
            fns.addCoreResolves = registerAddCoreResolvables(this);
            fns.ignored = registerIgnoredTransitionHook(this);
            fns.invalid = registerInvalidTransitionHook(this);
            fns.redirectTo = registerRedirectToHook(this);
            fns.onExit = registerOnExitHook(this);
            fns.onRetain = registerOnRetainHook(this);
            fns.onEnter = registerOnEnterHook(this);
            fns.eagerResolve = registerEagerResolvePath(this);
            fns.lazyResolve = registerLazyResolveState(this);
            fns.resolveAll = registerResolveRemaining(this);
            fns.loadViews = registerLoadEnteringViews(this);
            fns.activateViews = registerActivateViews(this);
            fns.updateGlobals = registerUpdateGlobalState(this);
            fns.updateUrl = registerUpdateUrl(this);
            fns.lazyLoad = registerLazyLoadHook(this);
        };
        return TransitionService;
    }());
    var StateService = (function () {
        function StateService(router) {
            this.router = router;
            this.invalidCallbacks = [];
            this._defaultErrorHandler = function $defaultErrorHandler($error$) {
                if ($error$ instanceof Error && $error$.stack) {
                    console.error($error$);
                    console.error($error$.stack);
                }
                else if ($error$ instanceof Rejection) {
                    console.error($error$.toString());
                    if ($error$.detail && $error$.detail.stack)
                        console.error($error$.detail.stack);
                }
                else {
                    console.error($error$);
                }
            };
            var getters = ['current', '$current', 'params', 'transition'];
            var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));
            createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);
        }
        Object.defineProperty(StateService.prototype, "transition", {
            get: function () {
                return this.router.globals.transition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "params", {
            get: function () {
                return this.router.globals.params;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "current", {
            get: function () {
                return this.router.globals.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "$current", {
            get: function () {
                return this.router.globals.$current;
            },
            enumerable: true,
            configurable: true
        });
        StateService.prototype.dispose = function () {
            this.defaultErrorHandler(noop);
            this.invalidCallbacks = [];
        };
        StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
            var _this = this;
            var fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath);
            var globals = this.router.globals;
            var latestThing = function () { return globals.transitionHistory.peekTail(); };
            var latest = latestThing();
            var callbackQueue = new Queue(this.invalidCallbacks.slice());
            var injector = new ResolveContext(fromPath).injector();
            var checkForRedirect = function (result) {
                if (!(result instanceof TargetState)) {
                    return;
                }
                var target = result;
                target = _this.target(target.identifier(), target.params(), target.options());
                if (!target.valid()) {
                    return Rejection.invalid(target.error()).toPromise();
                }
                if (latestThing() !== latest) {
                    return Rejection.superseded().toPromise();
                }
                return _this.transitionTo(target.identifier(), target.params(), target.options());
            };
            function invokeNextCallback() {
                var nextCallback = callbackQueue.dequeue();
                if (nextCallback === undefined)
                    return Rejection.invalid(toState.error()).toPromise();
                var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));
                return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
            }
            return invokeNextCallback();
        };
        StateService.prototype.onInvalid = function (callback) {
            this.invalidCallbacks.push(callback);
            return function deregisterListener() {
                removeFrom(this.invalidCallbacks)(callback);
            }.bind(this);
        };
        StateService.prototype.reload = function (reloadState) {
            return this.transitionTo(this.current, this.params, {
                reload: isDefined(reloadState) ? reloadState : true,
                inherit: false,
                notify: false,
            });
        };
        StateService.prototype.go = function (to, params, options) {
            var defautGoOpts = { relative: this.$current, inherit: true };
            var transOpts = defaults(options, defautGoOpts, defaultTransOpts);
            return this.transitionTo(to, params, transOpts);
        };
        StateService.prototype.target = function (identifier, params, options) {
            if (options === void 0) {
                options = {};
            }
            if (isObject(options.reload) && !options.reload.name)
                throw new Error('Invalid reload state object');
            var reg = this.router.stateRegistry;
            options.reloadState =
                options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
            if (options.reload && !options.reloadState)
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
            return new TargetState(this.router.stateRegistry, identifier, params, options);
        };
        StateService.prototype.getCurrentPath = function () {
            var _this = this;
            var globals = this.router.globals;
            var latestSuccess = globals.successfulTransitions.peekTail();
            var rootPath = function () { return [new PathNode(_this.router.stateRegistry.root())]; };
            return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
        };
        StateService.prototype.transitionTo = function (to, toParams, options) {
            var _this = this;
            if (toParams === void 0) {
                toParams = {};
            }
            if (options === void 0) {
                options = {};
            }
            var router = this.router;
            var globals = router.globals;
            options = defaults(options, defaultTransOpts);
            var getCurrent = function () { return globals.transition; };
            options = extend(options, { current: getCurrent });
            var ref = this.target(to, toParams, options);
            var currentPath = this.getCurrentPath();
            if (!ref.exists())
                return this._handleInvalidTargetState(currentPath, ref);
            if (!ref.valid())
                return silentRejection(ref.error());
            var rejectedTransitionHandler = function (trans) {
                return function (error) {
                    if (error instanceof Rejection) {
                        var isLatest = router.globals.lastStartedTransitionId === trans.$id;
                        if (error.type === exports.RejectType.IGNORED) {
                            isLatest && router.urlRouter.update();
                            return services.$q.when(globals.current);
                        }
                        var detail = error.detail;
                        if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {
                            var redirect = trans.redirect(detail);
                            return redirect.run().catch(rejectedTransitionHandler(redirect));
                        }
                        if (error.type === exports.RejectType.ABORTED) {
                            isLatest && router.urlRouter.update();
                            return services.$q.reject(error);
                        }
                    }
                    var errorHandler = _this.defaultErrorHandler();
                    errorHandler(error);
                    return services.$q.reject(error);
                };
            };
            var transition = this.router.transitionService.create(currentPath, ref);
            var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
            silenceUncaughtInPromise(transitionToPromise);
            return extend(transitionToPromise, { transition: transition });
        };
        StateService.prototype.is = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return undefined;
            if (this.$current !== state)
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        StateService.prototype.includes = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var glob = isString(stateOrName) && Glob.fromString(stateOrName);
            if (glob) {
                if (!glob.matches(this.$current.name))
                    return false;
                stateOrName = this.$current.name;
            }
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
            if (!isDefined(state))
                return undefined;
            if (!isDefined(include[state.name]))
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        StateService.prototype.href = function (stateOrName, params, options) {
            var defaultHrefOpts = {
                lossy: true,
                inherit: true,
                absolute: false,
                relative: this.$current,
            };
            options = defaults(options, defaultHrefOpts);
            params = params || {};
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return null;
            if (options.inherit)
                params = this.params.$inherit(params, this.$current, state);
            var nav = state && options.lossy ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
                return null;
            }
            return this.router.urlRouter.href(nav.url, params, {
                absolute: options.absolute,
            });
        };
        StateService.prototype.defaultErrorHandler = function (handler) {
            return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
        };
        StateService.prototype.get = function (stateOrName, base) {
            var reg = this.router.stateRegistry;
            if (arguments.length === 0)
                return reg.get();
            return reg.get(stateOrName, base || this.$current);
        };
        StateService.prototype.lazyLoad = function (stateOrName, transition) {
            var state = this.get(stateOrName);
            if (!state || !state.lazyLoad)
                throw new Error('Can not lazy load ' + stateOrName);
            var currentPath = this.getCurrentPath();
            var target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
            transition = transition || this.router.transitionService.create(currentPath, target);
            return lazyLoadState(transition, state);
        };
        return StateService;
    }());
    var $q = {
        when: function (val$$1) { return new Promise(function (resolve, reject) { return resolve(val$$1); }); },
        reject: function (val$$1) {
            return new Promise(function (resolve, reject) {
                reject(val$$1);
            });
        },
        defer: function () {
            var deferred = {};
            deferred.promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            return deferred;
        },
        all: function (promises) {
            if (isArray(promises)) {
                return Promise.all(promises);
            }
            if (isObject(promises)) {
                var chain = Object.keys(promises).map(function (key) { return promises[key].then(function (val$$1) { return ({ key: key, val: val$$1 }); }); });
                return $q.all(chain).then(function (values$$1) {
                    return values$$1.reduce(function (acc, tuple) {
                        acc[tuple.key] = tuple.val;
                        return acc;
                    }, {});
                });
            }
        },
    };
    var globals = {};
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var ARGUMENT_NAMES = /([^\s,]+)/g;
    var $injector = {
        get: function (name) { return globals[name]; },
        has: function (name) { return $injector.get(name) != null; },
        invoke: function (fn, context, locals) {
            var all$$1 = extend({}, globals, locals || {});
            var params = $injector.annotate(fn);
            var ensureExist = assertPredicate(function (key) { return all$$1.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
            var args = params.filter(ensureExist).map(function (x) { return all$$1[x]; });
            if (isFunction(fn))
                return fn.apply(context, args);
            else
                return fn.slice(-1)[0].apply(context, args);
        },
        annotate: function (fn) {
            if (!isInjectable(fn))
                throw new Error("Not an injectable function: " + fn);
            if (fn && fn.$inject)
                return fn.$inject;
            if (isArray(fn))
                return fn.slice(0, -1);
            var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
            var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
            return result || [];
        },
    };
    var keyValsToObjectR = function (accum, _a) {
        var key = _a[0], val$$1 = _a[1];
        if (!accum.hasOwnProperty(key)) {
            accum[key] = val$$1;
        }
        else if (isArray(accum[key])) {
            accum[key].push(val$$1);
        }
        else {
            accum[key] = [accum[key], val$$1];
        }
        return accum;
    };
    var getParams = function (queryString) {
        return queryString
            .split('&')
            .filter(identity)
            .map(splitEqual)
            .reduce(keyValsToObjectR, {});
    };
    function parseUrl$1(url) {
        var orEmptyString = function (x) { return x || ''; };
        var _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
        var _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
        return { path: path, search: search, hash: hash, url: url };
    }
    var buildUrl = function (loc) {
        var path = loc.path();
        var searchObject = loc.search();
        var hash = loc.hash();
        var search = Object.keys(searchObject)
            .map(function (key) {
            var param = searchObject[key];
            var vals = isArray(param) ? param : [param];
            return vals.map(function (val$$1) { return key + '=' + val$$1; });
        })
            .reduce(unnestR, [])
            .join('&');
        return path + (search ? '?' + search : '') + (hash ? '#' + hash : '');
    };
    function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
        return function (uiRouter) {
            var service = (uiRouter.locationService = new serviceClass(uiRouter));
            var configuration = (uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5));
            function dispose(router) {
                router.dispose(service);
                router.dispose(configuration);
            }
            return { name: name, service: service, configuration: configuration, dispose: dispose };
        };
    }
    var BaseLocationServices = (function () {
        function BaseLocationServices(router, fireAfterUpdate) {
            var _this = this;
            this.fireAfterUpdate = fireAfterUpdate;
            this._listeners = [];
            this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
            this.hash = function () { return parseUrl$1(_this._get()).hash; };
            this.path = function () { return parseUrl$1(_this._get()).path; };
            this.search = function () { return getParams(parseUrl$1(_this._get()).search); };
            this._location = root.location;
            this._history = root.history;
        }
        BaseLocationServices.prototype.url = function (url, replace) {
            if (replace === void 0) {
                replace = true;
            }
            if (isDefined(url) && url !== this._get()) {
                this._set(null, null, url, replace);
                if (this.fireAfterUpdate) {
                    this._listeners.forEach(function (cb) { return cb({ url: url }); });
                }
            }
            return buildUrl(this);
        };
        BaseLocationServices.prototype.onChange = function (cb) {
            var _this = this;
            this._listeners.push(cb);
            return function () { return removeFrom(_this._listeners, cb); };
        };
        BaseLocationServices.prototype.dispose = function (router) {
            deregAll(this._listeners);
        };
        return BaseLocationServices;
    }());
    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var HashLocationService = (function (_super) {
        __extends(HashLocationService, _super);
        function HashLocationService(router) {
            var _this = _super.call(this, router, false) || this;
            root.addEventListener('hashchange', _this._listener, false);
            return _this;
        }
        HashLocationService.prototype._get = function () {
            return trimHashVal(this._location.hash);
        };
        HashLocationService.prototype._set = function (state, title, url, replace) {
            this._location.hash = url;
        };
        HashLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('hashchange', this._listener);
        };
        return HashLocationService;
    }(BaseLocationServices));
    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MemoryLocationService = (function (_super) {
        __extends$1(MemoryLocationService, _super);
        function MemoryLocationService(router) {
            return _super.call(this, router, true) || this;
        }
        MemoryLocationService.prototype._get = function () {
            return this._url;
        };
        MemoryLocationService.prototype._set = function (state, title, url, replace) {
            this._url = url;
        };
        return MemoryLocationService;
    }(BaseLocationServices));
    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PushStateLocationService = (function (_super) {
        __extends$2(PushStateLocationService, _super);
        function PushStateLocationService(router) {
            var _this = _super.call(this, router, true) || this;
            _this._config = router.urlService.config;
            root.addEventListener('popstate', _this._listener, false);
            return _this;
        }
        PushStateLocationService.prototype._getBasePrefix = function () {
            return stripLastPathElement(this._config.baseHref());
        };
        PushStateLocationService.prototype._get = function () {
            var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
            search = splitQuery(search)[1];
            hash = splitHash(hash)[1];
            var basePrefix = this._getBasePrefix();
            var exactBaseHrefMatch = pathname === this._config.baseHref();
            var startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
            pathname = exactBaseHrefMatch ? '/' : startsWithBase ? pathname.substring(basePrefix.length) : pathname;
            return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');
        };
        PushStateLocationService.prototype._set = function (state, title, url, replace) {
            var basePrefix = this._getBasePrefix();
            var slash = url && url[0] !== '/' ? '/' : '';
            var fullUrl = url === '' || url === '/' ? this._config.baseHref() : basePrefix + slash + url;
            if (replace) {
                this._history.replaceState(state, title, fullUrl);
            }
            else {
                this._history.pushState(state, title, fullUrl);
            }
        };
        PushStateLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('popstate', this._listener);
        };
        return PushStateLocationService;
    }(BaseLocationServices));
    var MemoryLocationConfig = (function () {
        function MemoryLocationConfig() {
            var _this = this;
            this.dispose = noop;
            this._baseHref = '';
            this._port = 80;
            this._protocol = 'http';
            this._host = 'localhost';
            this._hashPrefix = '';
            this.port = function () { return _this._port; };
            this.protocol = function () { return _this._protocol; };
            this.host = function () { return _this._host; };
            this.baseHref = function () { return _this._baseHref; };
            this.html5Mode = function () { return false; };
            this.hashPrefix = function (newval) { return (isDefined(newval) ? (_this._hashPrefix = newval) : _this._hashPrefix); };
        }
        return MemoryLocationConfig;
    }());
    var BrowserLocationConfig = (function () {
        function BrowserLocationConfig(router, _isHtml5) {
            if (_isHtml5 === void 0) {
                _isHtml5 = false;
            }
            this._isHtml5 = _isHtml5;
            this._baseHref = undefined;
            this._hashPrefix = '';
        }
        BrowserLocationConfig.prototype.port = function () {
            if (location.port) {
                return Number(location.port);
            }
            return this.protocol() === 'https' ? 443 : 80;
        };
        BrowserLocationConfig.prototype.protocol = function () {
            return location.protocol.replace(/:/g, '');
        };
        BrowserLocationConfig.prototype.host = function () {
            return location.hostname;
        };
        BrowserLocationConfig.prototype.html5Mode = function () {
            return this._isHtml5;
        };
        BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
            return isDefined(newprefix) ? (this._hashPrefix = newprefix) : this._hashPrefix;
        };
        BrowserLocationConfig.prototype.baseHref = function (href) {
            return isDefined(href)
                ? (this._baseHref = href)
                : isDefined(this._baseHref) ? this._baseHref : this.applyDocumentBaseHref();
        };
        BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {
            var baseTag = document.getElementsByTagName('base')[0];
            return (this._baseHref = baseTag ? baseTag.href.substr(location.origin.length) : location.pathname || '/');
        };
        BrowserLocationConfig.prototype.dispose = function () { };
        return BrowserLocationConfig;
    }());
    function servicesPlugin(router) {
        services.$injector = $injector;
        services.$q = $q;
        return { name: 'vanilla.services', $q: $q, $injector: $injector, dispose: function () { return null; } };
    }
    var hashLocationPlugin = locationPluginFactory('vanilla.hashBangLocation', false, HashLocationService, BrowserLocationConfig);
    var pushStateLocationPlugin = locationPluginFactory('vanilla.pushStateLocation', true, PushStateLocationService, BrowserLocationConfig);
    var memoryLocationPlugin = locationPluginFactory('vanilla.memoryLocation', false, MemoryLocationService, MemoryLocationConfig);
    var UIRouterPluginBase = (function () {
        function UIRouterPluginBase() {
        }
        UIRouterPluginBase.prototype.dispose = function (router) { };
        return UIRouterPluginBase;
    }());
    var index = Object.freeze({
        root: root,
        fromJson: fromJson,
        toJson: toJson,
        forEach: forEach,
        extend: extend,
        equals: equals,
        identity: identity,
        noop: noop,
        createProxyFunctions: createProxyFunctions,
        inherit: inherit,
        inArray: inArray,
        _inArray: _inArray,
        removeFrom: removeFrom,
        _removeFrom: _removeFrom,
        pushTo: pushTo,
        _pushTo: _pushTo,
        deregAll: deregAll,
        defaults: defaults,
        mergeR: mergeR,
        ancestors: ancestors,
        pick: pick,
        omit: omit,
        pluck: pluck,
        filter: filter,
        find: find,
        mapObj: mapObj,
        map: map,
        values: values,
        allTrueR: allTrueR,
        anyTrueR: anyTrueR,
        unnestR: unnestR,
        flattenR: flattenR,
        pushR: pushR,
        uniqR: uniqR,
        unnest: unnest,
        flatten: flatten,
        assertPredicate: assertPredicate,
        assertMap: assertMap,
        assertFn: assertFn,
        pairs: pairs,
        arrayTuples: arrayTuples,
        applyPairs: applyPairs,
        tail: tail,
        copy: copy,
        _extend: _extend,
        silenceUncaughtInPromise: silenceUncaughtInPromise,
        silentRejection: silentRejection,
        notImplemented: notImplemented,
        services: services,
        Glob: Glob,
        curry: curry,
        compose: compose,
        pipe: pipe,
        prop: prop,
        propEq: propEq,
        parse: parse,
        not: not,
        and: and,
        or: or,
        all: all,
        any: any,
        is: is,
        eq: eq,
        val: val,
        invoke: invoke,
        pattern: pattern,
        isUndefined: isUndefined,
        isDefined: isDefined,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isFunction: isFunction,
        isNumber: isNumber,
        isString: isString,
        isObject: isObject,
        isArray: isArray,
        isDate: isDate,
        isRegExp: isRegExp,
        isState: isState,
        isInjectable: isInjectable,
        isPromise: isPromise,
        Queue: Queue,
        maxLength: maxLength,
        padString: padString,
        kebobString: kebobString,
        functionToString: functionToString,
        fnToString: fnToString,
        stringify: stringify,
        beforeAfterSubstr: beforeAfterSubstr,
        hostRegex: hostRegex,
        stripLastPathElement: stripLastPathElement,
        splitHash: splitHash,
        splitQuery: splitQuery,
        splitEqual: splitEqual,
        trimHashVal: trimHashVal,
        splitOnDelim: splitOnDelim,
        joinNeighborsR: joinNeighborsR,
        get Category() { return exports.Category; },
        Trace: Trace,
        trace: trace,
        get DefType() { return exports.DefType; },
        Param: Param,
        ParamTypes: ParamTypes,
        StateParams: StateParams,
        ParamType: ParamType,
        PathNode: PathNode,
        PathUtils: PathUtils,
        resolvePolicies: resolvePolicies,
        defaultResolvePolicy: defaultResolvePolicy,
        Resolvable: Resolvable,
        NATIVE_INJECTOR_TOKEN: NATIVE_INJECTOR_TOKEN,
        ResolveContext: ResolveContext,
        resolvablesBuilder: resolvablesBuilder,
        StateBuilder: StateBuilder,
        StateObject: StateObject,
        StateMatcher: StateMatcher,
        StateQueueManager: StateQueueManager,
        StateRegistry: StateRegistry,
        StateService: StateService,
        TargetState: TargetState,
        get TransitionHookPhase() { return exports.TransitionHookPhase; },
        get TransitionHookScope() { return exports.TransitionHookScope; },
        HookBuilder: HookBuilder,
        matchState: matchState,
        RegisteredHook: RegisteredHook,
        makeEvent: makeEvent,
        get RejectType() { return exports.RejectType; },
        Rejection: Rejection,
        Transition: Transition,
        TransitionHook: TransitionHook,
        TransitionEventType: TransitionEventType,
        defaultTransOpts: defaultTransOpts,
        TransitionService: TransitionService,
        UrlMatcher: UrlMatcher,
        UrlMatcherFactory: UrlMatcherFactory,
        UrlRouter: UrlRouter,
        UrlRuleFactory: UrlRuleFactory,
        BaseUrlRule: BaseUrlRule,
        UrlService: UrlService,
        ViewService: ViewService,
        UIRouterGlobals: UIRouterGlobals,
        UIRouter: UIRouter,
        $q: $q,
        $injector: $injector,
        BaseLocationServices: BaseLocationServices,
        HashLocationService: HashLocationService,
        MemoryLocationService: MemoryLocationService,
        PushStateLocationService: PushStateLocationService,
        MemoryLocationConfig: MemoryLocationConfig,
        BrowserLocationConfig: BrowserLocationConfig,
        keyValsToObjectR: keyValsToObjectR,
        getParams: getParams,
        parseUrl: parseUrl$1,
        buildUrl: buildUrl,
        locationPluginFactory: locationPluginFactory,
        servicesPlugin: servicesPlugin,
        hashLocationPlugin: hashLocationPlugin,
        pushStateLocationPlugin: pushStateLocationPlugin,
        memoryLocationPlugin: memoryLocationPlugin,
        UIRouterPluginBase: UIRouterPluginBase
    });
    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function (path, view) {
            templateFactory = templateFactory || services.$injector.get('$templateFactory');
            return [new Ng1ViewConfig(path, view, templateFactory)];
        };
    }
    var hasAnyKey = function (keys, obj) { return keys.reduce(function (acc, key) { return acc || isDefined(obj[key]); }, false); };
    function ng1ViewsBuilder(state) {
        if (!state.parent)
            return {};
        var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
            throw new Error("State '" + state.name + "' has a 'views' object. " +
                "It cannot also have \"view properties\" at the state level.  " +
                "Move the following properties into a view (in the 'views' object): " +
                (" " + allViewKeys.filter(function (key) { return isDefined(state[key]); }).join(', ')));
        }
        var views = {}, viewsObject = state.views || { $default: pick(state, allViewKeys) };
        forEach(viewsObject, function (config, name) {
            name = name || '$default';
            if (isString(config))
                config = { component: config };
            config = extend({}, config);
            if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
                throw new Error("Cannot combine: " + compKeys.join('|') + " with: " + nonCompKeys.join('|') + " in stateview: '" + name + "@" + state.name + "'");
            }
            config.resolveAs = config.resolveAs || '$resolve';
            config.$type = 'ng1';
            config.$context = state;
            config.$name = name;
            var normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName;
            config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
            views[name] = config;
        });
        return views;
    }
    var id$1 = 0;
    var Ng1ViewConfig = (function () {
        function Ng1ViewConfig(path, viewDecl, factory) {
            var _this = this;
            this.path = path;
            this.viewDecl = viewDecl;
            this.factory = factory;
            this.$id = id$1++;
            this.loaded = false;
            this.getTemplate = function (uiView, context) {
                return _this.component
                    ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings)
                    : _this.template;
            };
        }
        Ng1ViewConfig.prototype.load = function () {
            var _this = this;
            var $q$$1 = services.$q;
            var context = new ResolveContext(this.path);
            var params = this.path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});
            var promises = {
                template: $q$$1.when(this.factory.fromConfig(this.viewDecl, params, context)),
                controller: $q$$1.when(this.getController(context)),
            };
            return $q$$1.all(promises).then(function (results) {
                trace.traceViewServiceEvent('Loaded', _this);
                _this.controller = results.controller;
                extend(_this, results.template);
                return _this;
            });
        };
        Ng1ViewConfig.prototype.getController = function (context) {
            var provider = this.viewDecl.controllerProvider;
            if (!isInjectable(provider))
                return this.viewDecl.controller;
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        return Ng1ViewConfig;
    }());
    var TemplateFactory = (function () {
        function TemplateFactory() {
            var _this = this;
            this._useHttp = ng.version.minor < 3;
            this.$get = [
                '$http',
                '$templateCache',
                '$injector',
                function ($http, $templateCache, $injector$$1) {
                    _this.$templateRequest = $injector$$1.has && $injector$$1.has('$templateRequest') && $injector$$1.get('$templateRequest');
                    _this.$http = $http;
                    _this.$templateCache = $templateCache;
                    return _this;
                },
            ];
        }
        TemplateFactory.prototype.useHttpService = function (value) {
            this._useHttp = value;
        };
        TemplateFactory.prototype.fromConfig = function (config, params, context) {
            var defaultTemplate = '<ui-view></ui-view>';
            var asTemplate = function (result) { return services.$q.when(result).then(function (str) { return ({ template: str }); }); };
            var asComponent = function (result) { return services.$q.when(result).then(function (str) { return ({ component: str }); }); };
            return isDefined(config.template)
                ? asTemplate(this.fromString(config.template, params))
                : isDefined(config.templateUrl)
                    ? asTemplate(this.fromUrl(config.templateUrl, params))
                    : isDefined(config.templateProvider)
                        ? asTemplate(this.fromProvider(config.templateProvider, params, context))
                        : isDefined(config.component)
                            ? asComponent(config.component)
                            : isDefined(config.componentProvider)
                                ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))
                                : asTemplate(defaultTemplate);
        };
        TemplateFactory.prototype.fromString = function (template, params) {
            return isFunction(template) ? template(params) : template;
        };
        TemplateFactory.prototype.fromUrl = function (url, params) {
            if (isFunction(url))
                url = url(params);
            if (url == null)
                return null;
            if (this._useHttp) {
                return this.$http
                    .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })
                    .then(function (response) {
                    return response.data;
                });
            }
            return this.$templateRequest(url);
        };
        TemplateFactory.prototype.fromProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {
            bindings = bindings || {};
            var prefix = ng.version.minor >= 3 ? '::' : '';
            var kebob = function (camelCase) {
                var kebobed = kebobString(camelCase);
                return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
            };
            var attributeTpl = function (input) {
                var name = input.name, type = input.type;
                var attrName = kebob(name);
                if (uiView.attr(attrName) && !bindings[name])
                    return attrName + "='" + uiView.attr(attrName) + "'";
                var resolveName = bindings[name] || name;
                if (type === '@')
                    return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                if (type === '&') {
                    var res = context.getResolvable(resolveName);
                    var fn = res && res.data;
                    var args = (fn && services.$injector.annotate(fn)) || [];
                    var arrayIdxStr = isArray(fn) ? "[" + (fn.length - 1) + "]" : '';
                    return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(',') + ")'";
                }
                return attrName + "='" + prefix + "$resolve." + resolveName + "'";
            };
            var attrs = getComponentBindings(component)
                .map(attributeTpl)
                .join(' ');
            var kebobName = kebob(component);
            return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
        };
        return TemplateFactory;
    }());
    function getComponentBindings(name) {
        var cmpDefs = services.$injector.get(name + 'Directive');
        if (!cmpDefs || !cmpDefs.length)
            throw new Error("Unable to find component named '" + name + "'");
        return cmpDefs.map(getBindings).reduce(unnestR, []);
    }
    var getBindings = function (def) {
        if (isObject(def.bindToController))
            return scopeBindings(def.bindToController);
        return scopeBindings(def.scope);
    };
    var scopeBindings = function (bindingsObj) {
        return Object.keys(bindingsObj || {})
            .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })
            .filter(function (tuple) { return isDefined(tuple) && isArray(tuple[1]); })
            .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); });
    };
    var StateProvider = (function () {
        function StateProvider(stateRegistry, stateService) {
            this.stateRegistry = stateRegistry;
            this.stateService = stateService;
            createProxyFunctions(val(StateProvider.prototype), this, val(this));
        }
        StateProvider.prototype.decorator = function (name, func) {
            return this.stateRegistry.decorator(name, func) || this;
        };
        StateProvider.prototype.state = function (name, definition) {
            if (isObject(name)) {
                definition = name;
            }
            else {
                definition.name = name;
            }
            this.stateRegistry.register(definition);
            return this;
        };
        StateProvider.prototype.onInvalid = function (callback) {
            return this.stateService.onInvalid(callback);
        };
        return StateProvider;
    }());
    var getStateHookBuilder = function (hookName) {
        return function stateHookBuilder(stateObject, parentFn) {
            var hook = stateObject[hookName];
            var pathname = hookName === 'onExit' ? 'from' : 'to';
            function decoratedNg1Hook(trans, state) {
                var resolveContext = new ResolveContext(trans.treeChanges(pathname));
                var subContext = resolveContext.subContext(state.$$state());
                var locals = extend(getLocals(subContext), { $state$: state, $transition$: trans });
                return services.$injector.invoke(hook, this, locals);
            }
            return hook ? decoratedNg1Hook : undefined;
        };
    };
    var Ng1LocationServices = (function () {
        function Ng1LocationServices($locationProvider) {
            this._urlListeners = [];
            this.$locationProvider = $locationProvider;
            var _lp = val($locationProvider);
            createProxyFunctions(_lp, this, _lp, ['hashPrefix']);
        }
        Ng1LocationServices.monkeyPatchPathParameterType = function (router) {
            var pathType = router.urlMatcherFactory.type('path');
            pathType.encode = function (x) {
                return x != null ? x.toString().replace(/(~|\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;
            };
            pathType.decode = function (x) {
                return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;
            };
        };
        Ng1LocationServices.prototype.dispose = function () { };
        Ng1LocationServices.prototype.onChange = function (callback) {
            var _this = this;
            this._urlListeners.push(callback);
            return function () { return removeFrom(_this._urlListeners)(callback); };
        };
        Ng1LocationServices.prototype.html5Mode = function () {
            var html5Mode = this.$locationProvider.html5Mode();
            html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode;
            return html5Mode && this.$sniffer.history;
        };
        Ng1LocationServices.prototype.url = function (newUrl, replace, state) {
            if (replace === void 0) {
                replace = false;
            }
            if (isDefined(newUrl))
                this.$location.url(newUrl);
            if (replace)
                this.$location.replace();
            if (state)
                this.$location.state(state);
            return this.$location.url();
        };
        Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {
            var _this = this;
            this.$location = $location;
            this.$sniffer = $sniffer;
            $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });
            var _loc = val($location);
            var _browser = val($browser);
            createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);
            createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);
            createProxyFunctions(_browser, this, _browser, ['baseHref']);
        };
        return Ng1LocationServices;
    }());
    var UrlRouterProvider = (function () {
        function UrlRouterProvider(router) {
            this._router = router;
            this._urlRouter = router.urlRouter;
        }
        UrlRouterProvider.injectableHandler = function (router, handler) {
            return function (match) { return services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params }); };
        };
        UrlRouterProvider.prototype.$get = function () {
            var urlRouter = this._urlRouter;
            urlRouter.update(true);
            if (!urlRouter.interceptDeferred)
                urlRouter.listen();
            return urlRouter;
        };
        UrlRouterProvider.prototype.rule = function (ruleFn) {
            var _this = this;
            if (!isFunction(ruleFn))
                throw new Error("'rule' must be a function");
            var match = function () { return ruleFn(services.$injector, _this._router.locationService); };
            var rule = new BaseUrlRule(match, identity);
            this._urlRouter.rule(rule);
            return this;
        };
        UrlRouterProvider.prototype.otherwise = function (rule) {
            var _this = this;
            var urlRouter = this._urlRouter;
            if (isString(rule)) {
                urlRouter.otherwise(rule);
            }
            else if (isFunction(rule)) {
                urlRouter.otherwise(function () { return rule(services.$injector, _this._router.locationService); });
            }
            else {
                throw new Error("'rule' must be a string or function");
            }
            return this;
        };
        UrlRouterProvider.prototype.when = function (what, handler) {
            if (isArray(handler) || isFunction(handler)) {
                handler = UrlRouterProvider.injectableHandler(this._router, handler);
            }
            this._urlRouter.when(what, handler);
            return this;
        };
        UrlRouterProvider.prototype.deferIntercept = function (defer) {
            this._urlRouter.deferIntercept(defer);
        };
        return UrlRouterProvider;
    }());
    ng.module('ui.router.angular1', []);
    var mod_init = ng.module('ui.router.init', []);
    var mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);
    var mod_rtr = ng.module('ui.router.router', ['ui.router.util']);
    var mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
    var mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
    var mod_cmpt = ng.module('ui.router.compat', ['ui.router']);
    var router = null;
    $uiRouterProvider.$inject = ['$locationProvider'];
    function $uiRouterProvider($locationProvider) {
        router = this.router = new UIRouter();
        router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);
        router.stateRegistry.decorator('views', ng1ViewsBuilder);
        router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));
        router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));
        router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));
        router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());
        var ng1LocationService = (router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider));
        Ng1LocationServices.monkeyPatchPathParameterType(router);
        router['router'] = router;
        router['$get'] = $get;
        $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];
        function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {
            ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);
            delete router['router'];
            delete router['$get'];
            return router;
        }
        return router;
    }
    var getProviderFor = function (serviceName) {
        return [
            '$uiRouterProvider',
            function ($urp) {
                var service = $urp.router[serviceName];
                service['$get'] = function () { return service; };
                return service;
            },
        ];
    };
    runBlock.$inject = ['$injector', '$q', '$uiRouter'];
    function runBlock($injector$$1, $q$$1, $uiRouter) {
        services.$injector = $injector$$1;
        services.$q = $q$$1;
        $uiRouter.stateRegistry
            .get()
            .map(function (x) { return x.$$state().resolvables; })
            .reduce(unnestR, [])
            .filter(function (x) { return x.deps === 'deferred'; })
            .forEach(function (resolvable) { return (resolvable.deps = $injector$$1.annotate(resolvable.resolveFn, $injector$$1.strictDi)); });
    }
    var getUrlRouterProvider = function (uiRouter) { return (uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter)); };
    var getStateProvider = function () { return extend(router.stateProvider, { $get: function () { return router.stateService; } }); };
    watchDigests.$inject = ['$rootScope'];
    function watchDigests($rootScope) {
        $rootScope.$watch(function () {
            trace.approximateDigests++;
        });
    }
    mod_init.provider('$uiRouter', $uiRouterProvider);
    mod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);
    mod_util.provider('$urlService', getProviderFor('urlService'));
    mod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);
    mod_util.provider('$templateFactory', function () { return new TemplateFactory(); });
    mod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));
    mod_state.provider('$uiRouterGlobals', getProviderFor('globals'));
    mod_state.provider('$transitions', getProviderFor('transitionService'));
    mod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);
    mod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);
    mod_main.factory('$view', function () { return router.viewService; });
    mod_main.service('$trace', function () { return trace; });
    mod_main.run(watchDigests);
    mod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);
    mod_state.run(['$state', function ($state) { }]);
    mod_rtr.run(['$urlRouter', function ($urlRouter) { }]);
    mod_init.run(runBlock);
    var getLocals = function (ctx) {
        var tokens = ctx.getTokens().filter(isString);
        var tuples = tokens.map(function (key) {
            var resolvable = ctx.getResolvable(key);
            var waitPolicy = ctx.getPolicy(resolvable).async;
            return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];
        });
        return tuples.reduce(applyPairs, {});
    };
    function parseStateRef(ref) {
        var parsed;
        var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly)
            ref = '(' + paramsOnly[1] + ')';
        parsed = ref.replace(/\n/g, ' ').match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
        return { state: parsed[1] || null, paramExpr: parsed[3] || null };
    }
    function stateContext(el) {
        var $uiView = el.parent().inheritedData('$uiView');
        var path = parse('$cfg.path')($uiView);
        return path ? tail(path).state.name : undefined;
    }
    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name;
        var uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {});
        var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };
    }
    function getTypeInfo(el) {
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === 'FORM';
        return {
            attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
            isAnchor: el.prop('tagName').toUpperCase() === 'A',
            clickable: !isForm,
        };
    }
    function clickHook(el, $state, $timeout, type, getDef) {
        return function (e) {
            var button = e.which || e.button, target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                var transition_1 = $timeout(function () {
                    $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                });
                e.preventDefault();
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function () {
                    if (ignorePreventDefaultCount_1-- <= 0)
                        $timeout.cancel(transition_1);
                };
            }
        };
    }
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: true,
            source: 'sref',
        };
    }
    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        if (uiStateOpts) {
            events = uiStateOpts.events;
        }
        if (!isArray(events)) {
            events = ['click'];
        }
        var on = element.on ? 'on' : 'bind';
        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn);
        }
        scope.$on('$destroy', function () {
            var off = element.off ? 'off' : 'unbind';
            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn);
            }
        });
    }
    var uiSrefDirective;
    uiSrefDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var ref = parseStateRef(attrs.uiSref);
                    rawDef.uiState = ref.state;
                    rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function (val$$1) {
                            rawDef.uiStateParams = extend({}, val$$1);
                            update();
                        }, true);
                        rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr));
                    }
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    var uiStateDirective;
    uiStateDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDynamicDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];
                    var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return ((acc[attr] = noop), acc); }, {});
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    inputAttrs.forEach(function (field) {
                        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                        attrs.$observe(field, function (expr) {
                            watchDeregFns[field]();
                            watchDeregFns[field] = scope.$watch(expr, function (newval) {
                                rawDef[field] = newval;
                                update();
                            }, true);
                        });
                    });
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    var uiSrefActiveDirective;
    uiSrefActiveDirective = [
        '$state',
        '$stateParams',
        '$interpolate',
        '$uiRouter',
        function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$element',
                    '$attrs',
                    function ($scope, $element, $attrs) {
                        var states = [];
                        var activeEqClass;
                        var uiSrefActive;
                        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                        try {
                            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                        }
                        catch (e) {
                        }
                        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                        setStatesFromDefinitionObject(uiSrefActive);
                        this.$$addStateInfo = function (newState, newParams) {
                            if (isObject(uiSrefActive) && states.length > 0) {
                                return;
                            }
                            var deregister = addState(newState, newParams, uiSrefActive);
                            update();
                            return deregister;
                        };
                        function updateAfterTransition(trans) {
                            trans.promise.then(update, noop);
                        }
                        $scope.$on('$destroy', setupEventListeners());
                        if ($uiRouter.globals.transition) {
                            updateAfterTransition($uiRouter.globals.transition);
                        }
                        function setupEventListeners() {
                            var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged);
                            var deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition);
                            var deregisterStateChangeSuccessListener = $scope.$on('$stateChangeSuccess', update);
                            return function cleanUp() {
                                deregisterStatesChangedListener();
                                deregisterOnStartListener();
                                deregisterStateChangeSuccessListener();
                            };
                        }
                        function handleStatesChanged() {
                            setStatesFromDefinitionObject(uiSrefActive);
                        }
                        function setStatesFromDefinitionObject(statesDefinition) {
                            if (isObject(statesDefinition)) {
                                states = [];
                                forEach(statesDefinition, function (stateOrName, activeClass) {
                                    var addStateForClass = function (stateOrName, activeClass) {
                                        var ref = parseStateRef(stateOrName);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    };
                                    if (isString(stateOrName)) {
                                        addStateForClass(stateOrName, activeClass);
                                    }
                                    else if (isArray(stateOrName)) {
                                        forEach(stateOrName, function (stateOrName) {
                                            addStateForClass(stateOrName, activeClass);
                                        });
                                    }
                                });
                            }
                        }
                        function addState(stateName, stateParams, activeClass) {
                            var state = $state.get(stateName, stateContext($element));
                            var stateInfo = {
                                state: state || { name: stateName },
                                params: stateParams,
                                activeClass: activeClass,
                            };
                            states.push(stateInfo);
                            return function removeState() {
                                removeFrom(states)(stateInfo);
                            };
                        }
                        function update() {
                            var splitClasses = function (str) { return str.split(/\s/).filter(identity); };
                            var getClasses = function (stateList) {
                                return stateList
                                    .map(function (x) { return x.activeClass; })
                                    .map(splitClasses)
                                    .reduce(unnestR, []);
                            };
                            var allClasses = getClasses(states)
                                .concat(splitClasses(activeEqClass))
                                .reduce(uniqR, []);
                            var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));
                            var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;
                            var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                            var addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);
                            var removeClasses = allClasses.filter(function (cls) { return !inArray(addClasses, cls); });
                            $scope.$evalAsync(function () {
                                addClasses.forEach(function (className) { return $element.addClass(className); });
                                removeClasses.forEach(function (className) { return $element.removeClass(className); });
                            });
                        }
                        update();
                    },
                ],
            };
        },
    ];
    ng
        .module('ui.router.state')
        .directive('uiSref', uiSrefDirective)
        .directive('uiSrefActive', uiSrefActiveDirective)
        .directive('uiSrefActiveEq', uiSrefActiveDirective)
        .directive('uiState', uiStateDirective);
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
        var isFilter = function (state, params, options) {
            return $state.is(state, params, options);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state, params, options) {
            return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    ng
        .module('ui.router.state')
        .filter('isState', $IsStateFilter)
        .filter('includedByState', $IncludedByStateFilter);
    var uiView;
    uiView = [
        '$view',
        '$animate',
        '$uiViewScroll',
        '$interpolate',
        '$q',
        function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q$$1) {
            function getRenderer(attrs, scope) {
                return {
                    enter: function (element, target, cb) {
                        if (ng.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        }
                        else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function (element, cb) {
                        if (ng.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        }
                        else {
                            $animate.leave(element, cb);
                        }
                    },
                };
            }
            function configsEqual(config1, config2) {
                return config1 === config2;
            }
            var rootData = {
                $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
                $uiView: {},
            };
            var directive = {
                count: 0,
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                compile: function (tElement, tAttrs, $transclude) {
                    return function (scope, $element, attrs) {
                        var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';
                        var previousEl, currentEl, currentScope, viewConfig, unregister;
                        var activeUIView = {
                            $type: 'ng1',
                            id: directive.count++,
                            name: name,
                            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,
                            config: null,
                            configUpdated: configUpdatedCallback,
                            get creationContext() {
                                var fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);
                                var fromParentTag = parse('$uiView.creationContext')(inherited);
                                return fromParentTagConfig || fromParentTag;
                            },
                        };
                        trace.traceUIViewEvent('Linking', activeUIView);
                        function configUpdatedCallback(config) {
                            if (config && !(config instanceof Ng1ViewConfig))
                                return;
                            if (configsEqual(viewConfig, config))
                                return;
                            trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                            viewConfig = config;
                            updateView(config);
                        }
                        $element.data('$uiView', { $uiView: activeUIView });
                        updateView();
                        unregister = $view.registerUIView(activeUIView);
                        scope.$on('$destroy', function () {
                            trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);
                            unregister();
                        });
                        function cleanupLastView() {
                            if (previousEl) {
                                trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));
                                previousEl.remove();
                                previousEl = null;
                            }
                            if (currentScope) {
                                trace.traceUIViewEvent('Destroying scope', activeUIView);
                                currentScope.$destroy();
                                currentScope = null;
                            }
                            if (currentEl) {
                                var _viewData_1 = currentEl.data('$uiViewAnim');
                                trace.traceUIViewEvent('Animate out', _viewData_1);
                                renderer.leave(currentEl, function () {
                                    _viewData_1.$$animLeave.resolve();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                                currentEl = null;
                            }
                        }
                        function updateView(config) {
                            var newScope = scope.$new();
                            var animEnter = $q$$1.defer(), animLeave = $q$$1.defer();
                            var $uiViewData = {
                                $cfg: config,
                                $uiView: activeUIView,
                            };
                            var $uiViewAnim = {
                                $animEnter: animEnter.promise,
                                $animLeave: animLeave.promise,
                                $$animLeave: animLeave,
                            };
                            newScope.$emit('$viewContentLoading', name);
                            var cloned = $transclude(newScope, function (clone) {
                                clone.data('$uiViewAnim', $uiViewAnim);
                                clone.data('$uiView', $uiViewData);
                                renderer.enter(clone, $element, function onUIViewEnter() {
                                    animEnter.resolve();
                                    if (currentScope)
                                        currentScope.$emit('$viewContentAnimationEnded');
                                    if ((isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = cloned;
                            currentScope = newScope;
                            currentScope.$emit('$viewContentLoaded', config || viewConfig);
                            currentScope.$eval(onloadExp);
                        }
                    };
                },
            };
            return directive;
        },
    ];
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];
    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q$$1, $timeout) {
        var getControllerAs = parse('viewDecl.controllerAs');
        var getResolveAs = parse('viewDecl.resolveAs');
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function (tElement) {
                var initial = tElement.html();
                tElement.empty();
                return function (scope, $element) {
                    var data = $element.data('$uiView');
                    if (!data) {
                        $element.html(initial);
                        $compile($element.contents())(scope);
                        return;
                    }
                    var cfg = data.$cfg || { viewDecl: {}, getTemplate: noop };
                    var resolveCtx = cfg.path && new ResolveContext(cfg.path);
                    $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                    trace.traceUIViewFill(data.$uiView, $element.html());
                    var link = $compile($element.contents());
                    var controller = cfg.controller;
                    var controllerAs = getControllerAs(cfg);
                    var resolveAs = getResolveAs(cfg);
                    var locals = resolveCtx && getLocals(resolveCtx);
                    scope[resolveAs] = locals;
                    if (controller) {
                        var controllerInstance = $controller(controller, extend({}, locals, { $scope: scope, $element: $element }));
                        if (controllerAs) {
                            scope[controllerAs] = controllerInstance;
                            scope[controllerAs][resolveAs] = locals;
                        }
                        $element.data('$ngControllerController', controllerInstance);
                        $element.children().data('$ngControllerController', controllerInstance);
                        registerControllerCallbacks($q$$1, $transitions, controllerInstance, scope, cfg);
                    }
                    if (isString(cfg.viewDecl.component)) {
                        var cmp_1 = cfg.viewDecl.component;
                        var kebobName = kebobString(cmp_1);
                        var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", 'i');
                        var getComponentController = function () {
                            var directiveEl = [].slice
                                .call($element[0].children)
                                .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });
                            return directiveEl && ng.element(directiveEl).data("$" + cmp_1 + "Controller");
                        };
                        var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {
                            if (!ctrlInstance)
                                return;
                            registerControllerCallbacks($q$$1, $transitions, ctrlInstance, scope, cfg);
                            deregisterWatch_1();
                        });
                    }
                    link(scope);
                };
            },
        };
    }
    var hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';
    var _uiCanExitId = 0;
    function registerControllerCallbacks($q$$1, $transitions, controllerInstance, $scope, cfg) {
        if (isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {
            controllerInstance.$onInit();
        }
        var viewState = tail(cfg.path).state.self;
        var hookOptions = { bind: controllerInstance };
        if (isFunction(controllerInstance.uiOnParamsChanged)) {
            var resolveContext = new ResolveContext(cfg.path);
            var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;
            var paramsUpdated = function ($transition$) {
                if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)
                    return;
                var toParams = $transition$.params('to');
                var fromParams = $transition$.params('from');
                var getNodeSchema = function (node) { return node.paramSchema; };
                var toSchema = $transition$
                    .treeChanges('to')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                var fromSchema = $transition$
                    .treeChanges('from')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                var changedToParams = toSchema.filter(function (param) {
                    var idx = fromSchema.indexOf(param);
                    return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                });
                if (changedToParams.length) {
                    var changedKeys_1 = changedToParams.map(function (x) { return x.id; });
                    var newValues = filter(toParams, function (val$$1, key) { return changedKeys_1.indexOf(key) !== -1; });
                    controllerInstance.uiOnParamsChanged(newValues, $transition$);
                }
            };
            $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));
        }
        if (isFunction(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++;
            var cacheProp_1 = '_uiCanExitIds';
            var prevTruthyAnswer_1 = function (trans) {
                return !!trans && ((trans[cacheProp_1] && trans[cacheProp_1][id_1] === true) || prevTruthyAnswer_1(trans.redirectedFrom()));
            };
            var wrappedHook = function (trans) {
                var promise;
                var ids = (trans[cacheProp_1] = trans[cacheProp_1] || {});
                if (!prevTruthyAnswer_1(trans)) {
                    promise = $q$$1.when(controllerInstance.uiCanExit(trans));
                    promise.then(function (val$$1) { return (ids[id_1] = val$$1 !== false); });
                }
                return promise;
            };
            var criteria = { exiting: viewState.name };
            $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));
        }
    }
    ng.module('ui.router.state').directive('uiView', uiView);
    ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function () {
            useAnchorScroll = true;
        };
        this.$get = [
            '$anchorScroll',
            '$timeout',
            function ($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }
                return function ($element) {
                    return $timeout(function () {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            },
        ];
    }
    ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
    var index$1 = 'ui.router';
    exports.default = index$1;
    exports.core = index;
    exports.watchDigests = watchDigests;
    exports.getLocals = getLocals;
    exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
    exports.ng1ViewsBuilder = ng1ViewsBuilder;
    exports.Ng1ViewConfig = Ng1ViewConfig;
    exports.StateProvider = StateProvider;
    exports.UrlRouterProvider = UrlRouterProvider;
    exports.root = root;
    exports.fromJson = fromJson;
    exports.toJson = toJson;
    exports.forEach = forEach;
    exports.extend = extend;
    exports.equals = equals;
    exports.identity = identity;
    exports.noop = noop;
    exports.createProxyFunctions = createProxyFunctions;
    exports.inherit = inherit;
    exports.inArray = inArray;
    exports._inArray = _inArray;
    exports.removeFrom = removeFrom;
    exports._removeFrom = _removeFrom;
    exports.pushTo = pushTo;
    exports._pushTo = _pushTo;
    exports.deregAll = deregAll;
    exports.defaults = defaults;
    exports.mergeR = mergeR;
    exports.ancestors = ancestors;
    exports.pick = pick;
    exports.omit = omit;
    exports.pluck = pluck;
    exports.filter = filter;
    exports.find = find;
    exports.mapObj = mapObj;
    exports.map = map;
    exports.values = values;
    exports.allTrueR = allTrueR;
    exports.anyTrueR = anyTrueR;
    exports.unnestR = unnestR;
    exports.flattenR = flattenR;
    exports.pushR = pushR;
    exports.uniqR = uniqR;
    exports.unnest = unnest;
    exports.flatten = flatten;
    exports.assertPredicate = assertPredicate;
    exports.assertMap = assertMap;
    exports.assertFn = assertFn;
    exports.pairs = pairs;
    exports.arrayTuples = arrayTuples;
    exports.applyPairs = applyPairs;
    exports.tail = tail;
    exports.copy = copy;
    exports._extend = _extend;
    exports.silenceUncaughtInPromise = silenceUncaughtInPromise;
    exports.silentRejection = silentRejection;
    exports.notImplemented = notImplemented;
    exports.services = services;
    exports.Glob = Glob;
    exports.curry = curry;
    exports.compose = compose;
    exports.pipe = pipe;
    exports.prop = prop;
    exports.propEq = propEq;
    exports.parse = parse;
    exports.not = not;
    exports.and = and;
    exports.or = or;
    exports.all = all;
    exports.any = any;
    exports.is = is;
    exports.eq = eq;
    exports.val = val;
    exports.invoke = invoke;
    exports.pattern = pattern;
    exports.isUndefined = isUndefined;
    exports.isDefined = isDefined;
    exports.isNull = isNull;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isFunction = isFunction;
    exports.isNumber = isNumber;
    exports.isString = isString;
    exports.isObject = isObject;
    exports.isArray = isArray;
    exports.isDate = isDate;
    exports.isRegExp = isRegExp;
    exports.isState = isState;
    exports.isInjectable = isInjectable;
    exports.isPromise = isPromise;
    exports.Queue = Queue;
    exports.maxLength = maxLength;
    exports.padString = padString;
    exports.kebobString = kebobString;
    exports.functionToString = functionToString;
    exports.fnToString = fnToString;
    exports.stringify = stringify;
    exports.beforeAfterSubstr = beforeAfterSubstr;
    exports.hostRegex = hostRegex;
    exports.stripLastPathElement = stripLastPathElement;
    exports.splitHash = splitHash;
    exports.splitQuery = splitQuery;
    exports.splitEqual = splitEqual;
    exports.trimHashVal = trimHashVal;
    exports.splitOnDelim = splitOnDelim;
    exports.joinNeighborsR = joinNeighborsR;
    exports.Trace = Trace;
    exports.trace = trace;
    exports.Param = Param;
    exports.ParamTypes = ParamTypes;
    exports.StateParams = StateParams;
    exports.ParamType = ParamType;
    exports.PathNode = PathNode;
    exports.PathUtils = PathUtils;
    exports.resolvePolicies = resolvePolicies;
    exports.defaultResolvePolicy = defaultResolvePolicy;
    exports.Resolvable = Resolvable;
    exports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN;
    exports.ResolveContext = ResolveContext;
    exports.resolvablesBuilder = resolvablesBuilder;
    exports.StateBuilder = StateBuilder;
    exports.StateObject = StateObject;
    exports.StateMatcher = StateMatcher;
    exports.StateQueueManager = StateQueueManager;
    exports.StateRegistry = StateRegistry;
    exports.StateService = StateService;
    exports.TargetState = TargetState;
    exports.HookBuilder = HookBuilder;
    exports.matchState = matchState;
    exports.RegisteredHook = RegisteredHook;
    exports.makeEvent = makeEvent;
    exports.Rejection = Rejection;
    exports.Transition = Transition;
    exports.TransitionHook = TransitionHook;
    exports.TransitionEventType = TransitionEventType;
    exports.defaultTransOpts = defaultTransOpts;
    exports.TransitionService = TransitionService;
    exports.UrlMatcher = UrlMatcher;
    exports.UrlMatcherFactory = UrlMatcherFactory;
    exports.UrlRouter = UrlRouter;
    exports.UrlRuleFactory = UrlRuleFactory;
    exports.BaseUrlRule = BaseUrlRule;
    exports.UrlService = UrlService;
    exports.ViewService = ViewService;
    exports.UIRouterGlobals = UIRouterGlobals;
    exports.UIRouter = UIRouter;
    exports.$q = $q;
    exports.$injector = $injector;
    exports.BaseLocationServices = BaseLocationServices;
    exports.HashLocationService = HashLocationService;
    exports.MemoryLocationService = MemoryLocationService;
    exports.PushStateLocationService = PushStateLocationService;
    exports.MemoryLocationConfig = MemoryLocationConfig;
    exports.BrowserLocationConfig = BrowserLocationConfig;
    exports.keyValsToObjectR = keyValsToObjectR;
    exports.getParams = getParams;
    exports.parseUrl = parseUrl$1;
    exports.buildUrl = buildUrl;
    exports.locationPluginFactory = locationPluginFactory;
    exports.servicesPlugin = servicesPlugin;
    exports.hashLocationPlugin = hashLocationPlugin;
    exports.pushStateLocationPlugin = pushStateLocationPlugin;
    exports.memoryLocationPlugin = memoryLocationPlugin;
    exports.UIRouterPluginBase = UIRouterPluginBase;
    Object.defineProperty(exports, '__esModule', { value: true });
})));
!function (a, b, c) {
    "use strict";
    function d() { this.$get = ["$$sanitizeUri", function (a) { return function (b) { "undefined" != typeof arguments[1] && (arguments[1].version = "taSanitize"); var c = []; return g(b, l(c, function (b, c) { return !/^unsafe/.test(a(b, c)); })), c.join(""); }; }]; }
    function e(a) { var c = [], d = l(c, b.noop); return d.chars(a), c.join(""); }
    function f(a) { var b, c = {}, d = a.split(","); for (b = 0; b < d.length; b++)
        c[d[b]] = !0; return c; }
    function g(a, c) {
        function d(a, d, f, g) { if (d = b.lowercase(d), D[d])
            for (; k.last() && E[k.last()];)
                e("", k.last()); C[d] && k.last() == d && e("", d), g = z[d] || !!g, g || k.push(d); var i = {}; f.replace(p, function (a, b, c, d, e) { var f = c || d || e || ""; i[b] = h(f); }), c.start && c.start(d, i, g); }
        function e(a, d) {
            var e, f = 0;
            if (d = b.lowercase(d))
                for (f = k.length - 1; f >= 0 && k[f] != d; f--)
                    ;
            if (f >= 0) {
                for (e = k.length - 1; e >= f; e--)
                    c.end && c.end(k[e]);
                k.length = f;
            }
        }
        "string" != typeof a && (a = null === a || "undefined" == typeof a ? "" : "" + a);
        var f, g, i, j, k = [], l = a;
        for (k.last = function () { return k[k.length - 1]; }; a;) {
            if (j = "", g = !0, k.last() && G[k.last()])
                a = a.replace(new RegExp("([^]*)<\\s*\\/\\s*" + k.last() + "[^>]*>", "i"), function (a, b) { return b = b.replace(s, "$1").replace(v, "$1"), c.chars && c.chars(h(b)), ""; }), e("", k.last());
            else {
                if (y.test(a)) {
                    if (i = a.match(y)) {
                        i[0];
                        c.whitespace && c.whitespace(i[0]), a = a.replace(i[0], ""), g = !1;
                    }
                }
                else
                    t.test(a) ? (i = a.match(t), i && (c.comment && c.comment(i[1]), a = a.replace(i[0], ""), g = !1)) : u.test(a) ? (i = a.match(u), i && (a = a.replace(i[0], ""), g = !1)) : r.test(a) ? (i = a.match(o), i && (a = a.substring(i[0].length), i[0].replace(o, e), g = !1)) : q.test(a) && (i = a.match(n), i ? (i[4] && (a = a.substring(i[0].length), i[0].replace(n, d)), g = !1) : (j += "<", a = a.substring(1)));
                g && (f = a.indexOf("<"), j += f < 0 ? a : a.substring(0, f), a = f < 0 ? "" : a.substring(f), c.chars && c.chars(h(j)));
            }
            if (a == l)
                throw m("badparse", "The sanitizer was unable to parse the following block of html: {0}", a);
            l = a;
        }
        e();
    }
    function h(a) {
        if (!a)
            return "";
        var b = N.exec(a), c = b[1], d = b[3], e = b[2];
        return e && (M.innerHTML = e.replace(/</g, "&lt;"), e = "textContent" in M ? M.textContent : M.innerText), c + e + d;
    }
    function i(a) {
        return a.replace(/&/g, "&amp;").replace(w, function (a) { var b = a.charCodeAt(0), c = a.charCodeAt(1); return "&#" + (1024 * (b - 55296) + (c - 56320) + 65536) + ";"; }).replace(x, function (a) {
            var b = a.charCodeAt(0);
            return b <= 159 || 173 == b || b >= 1536 && b <= 1540 || 1807 == b || 6068 == b || 6069 == b || b >= 8204 && b <= 8207 || b >= 8232 && b <= 8239 || b >= 8288 && b <= 8303 || 65279 == b || b >= 65520 && b <= 65535 ? "&#" + b + ";" : a;
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function j(a) {
        var c = "", d = a.split(";");
        return b.forEach(d, function (a) {
            var d = a.split(":");
            if (2 == d.length) {
                var e = O(b.lowercase(d[0])), a = O(b.lowercase(d[1]));
                (("color" === e || "background-color" === e) && (a.match(/^rgb\([0-9%,\. ]*\)$/i) || a.match(/^rgba\([0-9%,\. ]*\)$/i) || a.match(/^hsl\([0-9%,\. ]*\)$/i) || a.match(/^hsla\([0-9%,\. ]*\)$/i) || a.match(/^#[0-9a-f]{3,6}$/i) || a.match(/^[a-z]*$/i)) || "text-align" === e && ("left" === a || "right" === a || "center" === a || "justify" === a) || "text-decoration" === e && ("underline" === a || "line-through" === a) || "font-weight" === e && "bold" === a || "font-style" === e && "italic" === a || "float" === e && ("left" === a || "right" === a || "none" === a) || "vertical-align" === e && ("baseline" === a || "sub" === a || "super" === a || "test-top" === a || "text-bottom" === a || "middle" === a || "top" === a || "bottom" === a || a.match(/[0-9]*(px|em)/) || a.match(/[0-9]+?%/)) || "font-size" === e && ("xx-small" === a || "x-small" === a || "small" === a || "medium" === a || "large" === a || "x-large" === a || "xx-large" === a || "larger" === a || "smaller" === a || a.match(/[0-9]*\.?[0-9]*(px|em|rem|mm|q|cm|in|pt|pc|%)/)) || ("width" === e || "height" === e) && a.match(/[0-9\.]*(px|em|rem|%)/) ||
                    "direction" === e && a.match(/^ltr|rtl|initial|inherit$/)) && (c += e + ": " + a + ";");
            }
        }), c;
    }
    function k(a, b, c, d) {
        return !("img" !== a || !b["ta-insert-video"] || "ta-insert-video" !== c && "allowfullscreen" !== c && "frameborder" !== c && ("contenteditable" !== c || "false" !== d));
    }
    function l(a, c) { var d = !1, e = b.bind(a, a.push); return { start: function (a, f, g) { a = b.lowercase(a), !d && G[a] && (d = a), d || H[a] !== !0 || (e("<"), e(a), b.forEach(f, function (d, g) { var h = b.lowercase(g), l = "img" === a && "src" === h || "background" === h; ("style" === h && "" !== (d = j(d)) || k(a, f, h, d) || L[h] === !0 && (I[h] !== !0 || c(d, l))) && (e(" "), e(g), e('="'), e(i(d)), e('"')); }), e(g ? "/>" : ">")); }, comment: function (a) { e(a); }, whitespace: function (a) { e(i(a)); }, end: function (a) { a = b.lowercase(a), d || H[a] !== !0 || (e("</"), e(a), e(">")), a == d && (d = !1); }, chars: function (a) { d || e(i(a)); } }; }
    var m = b.$$minErr("$sanitize"), n = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, o = /^<\/\s*([\w:-]+)[^>]*>/, p = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, q = /^</, r = /^<\//, s = /<!--(.*?)-->/g, t = /(^<!--.*?-->)/, u = /<!DOCTYPE([^>]*?)>/i, v = /<!\[CDATA\[(.*?)]]>/g, w = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, x = /([^\#-~| |!])/g, y = /^(\s+)/, z = f("area,br,col,hr,img,wbr,input"), A = f("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), B = f("rp,rt"), C = b.extend({}, B, A), D = b.extend({}, A, f("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), E = b.extend({}, B, f("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), F = f("animate,animateColor,animateMotion,animateTransform,circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,stop,svg,switch,text,title,tspan,use"), G = f("script,style"), H = b.extend({}, z, D, E, C, F), I = f("background,cite,href,longdesc,src,usemap,xlink:href"), J = f("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,id,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width"), K = f("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan"), L = b.extend({}, I, K, J), M = document.createElement("pre"), N = /^(\s*)([\s\S]*?)(\s*)$/, O = function () {
        return String.prototype.trim ? function (a) { return b.isString(a) ? a.trim() : a; } : function (a) { return b.isString(a) ? a.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : a; };
    }();
    b.module("ngSanitize", []).provider("$sanitize", d),
        b.module("ngSanitize").filter("linky", ["$sanitize", function (a) {
                var c = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/, d = /^mailto:/;
                return function (f, g) {
                    function h(a) { a && n.push(e(a)); }
                    function i(a, c) { n.push("<a "), b.isDefined(g) && n.push('target="', g, '" '), n.push('href="', a.replace(/"/g, "&quot;"), '">'), h(c), n.push("</a>"); }
                    if (!f)
                        return f;
                    for (var j, k, l, m = f, n = []; j = m.match(c);)
                        k = j[0],
                            j[2] || j[4] || (k = (j[3] ? "http://" : "mailto:") + k), l = j.index, h(m.substr(0, l)), i(k, j[0].replace(d, "")), m = m.substring(l + j[0].length);
                    return h(m), a(n.join(""));
                };
            }]);
}(window, window.angular);
!function (a, b) {
    "function" == typeof define && define.amd ?
        define("textAngular", ["rangy", "rangy/lib/rangy-selectionsaverestore"], function (c, d) { return a["textAngular.name"] = b(c, d); }) : "object" == typeof exports ?
        module.exports = b(require("rangy"), require("rangy/lib/rangy-selectionsaverestore")) : a.textAngular = b(rangy);
}(this, function (a) {
    function b(a) { try {
        return 0 !== angular.element(a).length;
    }
    catch (a) {
        return !1;
    } }
    function c(a, c) { if (!a || "" === a || e.hasOwnProperty(a))
        throw "textAngular Error: A unique name is required for a Tool Definition"; if (c.display && ("" === c.display || !b(c.display)) || !c.display && !c.buttontext && !c.iconclass)
        throw 'textAngular Error: Tool Definition for "' + a + '" does not have a valid display/iconclass/buttontext value'; e[a] = c; }
    function d(a) {
        var b = document.createElement("DIV");
        b.innerHTML = a;
        var c = b.textContent || b.innerText || "";
        return c.replace("​", ""), c = c.trim();
    }
    var e = {};
    angular.module("textAngularSetup", []).constant("taRegisterTool", c).value("taTools", e).value("taOptions", {
        forceTextAngularSanitize: !0,
        keyMappings: [], toolbar: [["h1", "h2", "h3", "h4", "h5", "h6", "p", "pre", "quote"], ["bold", "italics", "underline", "strikeThrough", "ul", "ol", "redo", "undo", "clear"], ["justifyLeft", "justifyCenter", "justifyRight", "justifyFull", "indent", "outdent"], ["html", "insertImage", "insertLink", "insertVideo", "wordcount", "charcount"]], classes: { focussed: "focussed", toolbar: "btn-toolbar", toolbarGroup: "btn-group", toolbarButton: "btn btn-default", toolbarButtonActive: "active", disabled: "disabled", textEditor: "form-control", htmlEditor: "form-control" }, defaultTagAttributes: { a: { target: "" } }, setup: {
            textEditorSetup: function (a) { },
            htmlEditorSetup: function (a) { }
        }, defaultFileDropHandler: function (a, b) { var c = new FileReader; return "image" === a.type.substring(0, 5) && (c.onload = function () { "" !== c.result && b("insertImage", c.result, !0); }, c.readAsDataURL(a), !0); }
    }).value("taSelectableElements", ["a", "img"]).value("taCustomRenderers", [{
            selector: "img", customAttribute: "ta-insert-video", renderLogic: function (a) {
                var b = angular.element("<iframe></iframe>"), c = a.prop("attributes");
                angular.forEach(c, function (a) { b.attr(a.name, a.value); }), b.attr("src", b.attr("ta-insert-video")), a.replaceWith(b);
            }
        }]).value("taTranslations", {
        html: { tooltip: "Toggle html / Rich Text" },
        heading: { tooltip: "Heading " }, p: { tooltip: "Paragraph" }, pre: { tooltip: "Preformatted text" }, ul: { tooltip: "Unordered List" }, ol: { tooltip: "Ordered List" }, quote: { tooltip: "Quote/unquote selection or paragraph" }, undo: { tooltip: "Undo" }, redo: { tooltip: "Redo" }, bold: { tooltip: "Bold" }, italic: { tooltip: "Italic" }, underline: { tooltip: "Underline" }, strikeThrough: { tooltip: "Strikethrough" }, justifyLeft: { tooltip: "Align text left" }, justifyRight: { tooltip: "Align text right" }, justifyFull: { tooltip: "Justify text" }, justifyCenter: { tooltip: "Center" }, indent: { tooltip: "Increase indent" }, outdent: { tooltip: "Decrease indent" }, clear: { tooltip: "Clear formatting" }, insertImage: { dialogPrompt: "Please enter an image URL to insert", tooltip: "Insert image", hotkey: "the - possibly language dependent hotkey ... for some future implementation" }, insertVideo: { tooltip: "Insert video", dialogPrompt: "Please enter a youtube URL to embed" }, insertLink: { tooltip: "Insert / edit link", dialogPrompt: "Please enter a URL to insert" }, editLink: { reLinkButton: { tooltip: "Relink" }, unLinkButton: { tooltip: "Unlink" }, targetToggle: { buttontext: "Open in New Window" } }, wordcount: { tooltip: "Display words Count" }, charcount: { tooltip: "Display characters Count" }
    }).factory("taToolFunctions", ["$window", "taTranslations", function (a, b) {
            return { imgOnSelectAction: function (a, b, c) {
                    var d = function () { c.updateTaBindtaTextElement(), c.hidePopover(); };
                    a.preventDefault(), c.displayElements.popover.css("width", "375px");
                    var e = c.displayElements.popoverContainer;
                    e.empty();
                    var f = angular.element('<div class="btn-group" style="padding-right: 6px;">'), g = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">100% </button>');
                    g.on("click", function (a) { a.preventDefault(), b.css({ width: "100%", height: "" }), d(); });
                    var h = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">50% </button>');
                    h.on("click", function (a) { a.preventDefault(), b.css({ width: "50%", height: "" }), d(); });
                    var i = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">25% </button>');
                    i.on("click", function (a) { a.preventDefault(), b.css({ width: "25%", height: "" }), d(); });
                    var j = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">Reset</button>');
                    j.on("click", function (a) { a.preventDefault(), b.css({ width: "", height: "" }), d(); }), f.append(g), f.append(h), f.append(i), f.append(j), e.append(f), f = angular.element('<div class="btn-group" style="padding-right: 6px;">');
                    var k = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-left"></i></button>');
                    k.on("click", function (a) {
                        a.preventDefault(),
                            b.css("float", "left"),
                            b.css("cssFloat", "left"),
                            b.css("styleFloat", "left"), d();
                    });
                    var l = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-right"></i></button>');
                    l.on("click", function (a) {
                        a.preventDefault(),
                            b.css("float", "right"),
                            b.css("cssFloat", "right"),
                            b.css("styleFloat", "right"), d();
                    });
                    var m = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-justify"></i></button>');
                    m.on("click", function (a) {
                        a.preventDefault(),
                            b.css("float", ""),
                            b.css("cssFloat", ""),
                            b.css("styleFloat", ""), d();
                    }), f.append(k), f.append(m), f.append(l), e.append(f), f = angular.element('<div class="btn-group">');
                    var n = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-trash-o"></i></button>');
                    n.on("click", function (a) { a.preventDefault(), b.remove(), d(); }), f.append(n), e.append(f), c.showPopover(b), c.showResizeOverlay(b);
                }, aOnSelectAction: function (c, d, e) {
                    c.preventDefault(), e.displayElements.popover.css("width", "436px");
                    var f = e.displayElements.popoverContainer;
                    f.empty(), f.css("line-height", "28px");
                    var g = angular.element('<a href="' + d.attr("href") + '" target="_blank">' + d.attr("href") + "</a>");
                    g.css({ display: "inline-block", "max-width": "200px", overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap", "vertical-align": "middle" }), f.append(g);
                    var h = angular.element('<div class="btn-group pull-right">'), i = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="' + b.editLink.reLinkButton.tooltip + '"><i class="fa fa-edit icon-edit"></i></button>');
                    i.on("click", function (c) { c.preventDefault(); var f = a.prompt(b.insertLink.dialogPrompt, d.attr("href")); f && "" !== f && "http://" !== f && (d.attr("href", f), e.updateTaBindtaTextElement()), e.hidePopover(); }), h.append(i);
                    var j = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="' + b.editLink.unLinkButton.tooltip + '"><i class="fa fa-unlink icon-unlink"></i></button>');
                    j.on("click", function (a) { a.preventDefault(), d.replaceWith(d.contents()), e.updateTaBindtaTextElement(), e.hidePopover(); }), h.append(j);
                    var k = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on">' + b.editLink.targetToggle.buttontext + "</button>");
                    "_blank" === d.attr("target") && k.addClass("active"), k.on("click", function (a) { a.preventDefault(), d.attr("target", "_blank" === d.attr("target") ? "" : "_blank"), k.toggleClass("active"), e.updateTaBindtaTextElement(); }), h.append(k), f.append(h), e.showPopover(d);
                }, extractYoutubeVideoId: function (a) { var b = /(?:youtube(?:-nocookie)?\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/i, c = a.match(b); return c && c[1] || null; } };
        }]).run(["taRegisterTool", "$window", "taTranslations", "taSelection", "taToolFunctions", "$sanitize", "taOptions", "$log", function (a, b, c, d, e, f, g, h) {
            var i = {};
            if (f("", i), g.forceTextAngularSanitize === !0 && "taSanitize" !== i.version)
                throw angular.$$minErr("textAngular")("textAngularSetup", "The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?");
            a("html", { iconclass: "fa fa-code", tooltiptext: c.html.tooltip, action: function () { this.$editor().switchView(); }, activeState: function () { return this.$editor().showHtml; } });
            var j = function (a) { return function () { return this.$editor().queryFormatBlockState(a); }; }, k = function () { return this.$editor().wrapSelection("formatBlock", "<" + this.name.toUpperCase() + ">"); };
            angular.forEach(["h1", "h2", "h3", "h4", "h5", "h6"], function (b) { a(b.toLowerCase(), { buttontext: b.toUpperCase(), tooltiptext: c.heading.tooltip + b.charAt(1), action: k, activeState: j(b.toLowerCase()) }); }), a("p", { buttontext: "P", tooltiptext: c.p.tooltip, action: function () { return this.$editor().wrapSelection("formatBlock", "<P>"); }, activeState: function () { return this.$editor().queryFormatBlockState("p"); } }),
                a("pre", { buttontext: "pre", tooltiptext: c.pre.tooltip, action: function () { return this.$editor().wrapSelection("formatBlock", "<PRE>"); }, activeState: function () { return this.$editor().queryFormatBlockState("pre"); } }), a("ul", { iconclass: "fa fa-list-ul", tooltiptext: c.ul.tooltip, action: function () { return this.$editor().wrapSelection("insertUnorderedList", null); }, activeState: function () { return this.$editor().queryCommandState("insertUnorderedList"); } }), a("ol", { iconclass: "fa fa-list-ol", tooltiptext: c.ol.tooltip, action: function () { return this.$editor().wrapSelection("insertOrderedList", null); }, activeState: function () { return this.$editor().queryCommandState("insertOrderedList"); } }), a("quote", { iconclass: "fa fa-quote-right", tooltiptext: c.quote.tooltip, action: function () { return this.$editor().wrapSelection("formatBlock", "<BLOCKQUOTE>"); }, activeState: function () { return this.$editor().queryFormatBlockState("blockquote"); } }), a("undo", { iconclass: "fa fa-undo", tooltiptext: c.undo.tooltip, action: function () { return this.$editor().wrapSelection("undo", null); } }), a("redo", { iconclass: "fa fa-repeat", tooltiptext: c.redo.tooltip, action: function () { return this.$editor().wrapSelection("redo", null); } }), a("bold", { iconclass: "fa fa-bold", tooltiptext: c.bold.tooltip, action: function () { return this.$editor().wrapSelection("bold", null); }, activeState: function () { return this.$editor().queryCommandState("bold"); }, commandKeyCode: 98 }), a("justifyLeft", { iconclass: "fa fa-align-left", tooltiptext: c.justifyLeft.tooltip, action: function () { return this.$editor().wrapSelection("justifyLeft", null); }, activeState: function (a) {
                    if (a && "#document" === a.nodeName)
                        return !1;
                    var b = !1;
                    if (a)
                        try {
                            b = "left" === a.css("text-align") || "left" === a.attr("align") || "right" !== a.css("text-align") && "center" !== a.css("text-align") && "justify" !== a.css("text-align") && !this.$editor().queryCommandState("justifyRight") && !this.$editor().queryCommandState("justifyCenter") && !this.$editor().queryCommandState("justifyFull");
                        }
                        catch (a) {
                            b = !1;
                        }
                    return b = b || this.$editor().queryCommandState("justifyLeft");
                } }), a("justifyRight", { iconclass: "fa fa-align-right", tooltiptext: c.justifyRight.tooltip, action: function () { return this.$editor().wrapSelection("justifyRight", null); }, activeState: function (a) {
                    if (a && "#document" === a.nodeName)
                        return !1;
                    var b = !1;
                    if (a)
                        try {
                            b = "right" === a.css("text-align");
                        }
                        catch (a) {
                            b = !1;
                        }
                    return b = b || this.$editor().queryCommandState("justifyRight");
                } }), a("justifyFull", { iconclass: "fa fa-align-justify", tooltiptext: c.justifyFull.tooltip, action: function () { return this.$editor().wrapSelection("justifyFull", null); }, activeState: function (a) {
                    var b = !1;
                    if (a)
                        try {
                            b = "justify" === a.css("text-align");
                        }
                        catch (a) {
                            b = !1;
                        }
                    return b = b || this.$editor().queryCommandState("justifyFull");
                } }), a("justifyCenter", { iconclass: "fa fa-align-center", tooltiptext: c.justifyCenter.tooltip, action: function () { return this.$editor().wrapSelection("justifyCenter", null); }, activeState: function (a) {
                    if (a && "#document" === a.nodeName)
                        return !1;
                    var b = !1;
                    if (a)
                        try {
                            b = "center" === a.css("text-align");
                        }
                        catch (a) {
                            b = !1;
                        }
                    return b = b || this.$editor().queryCommandState("justifyCenter");
                } }), a("indent", { iconclass: "fa fa-indent", tooltiptext: c.indent.tooltip, action: function () { return this.$editor().wrapSelection("indent", null); }, activeState: function () { return this.$editor().queryFormatBlockState("blockquote"); }, commandKeyCode: "TabKey" }), a("outdent", { iconclass: "fa fa-outdent", tooltiptext: c.outdent.tooltip, action: function () { return this.$editor().wrapSelection("outdent", null); }, activeState: function () { return !1; }, commandKeyCode: "ShiftTabKey" }), a("italics", { iconclass: "fa fa-italic", tooltiptext: c.italic.tooltip, action: function () { return this.$editor().wrapSelection("italic", null); }, activeState: function () { return this.$editor().queryCommandState("italic"); }, commandKeyCode: 105 }), a("underline", { iconclass: "fa fa-underline", tooltiptext: c.underline.tooltip, action: function () { return this.$editor().wrapSelection("underline", null); }, activeState: function () { return this.$editor().queryCommandState("underline"); }, commandKeyCode: 117 }), a("strikeThrough", { iconclass: "fa fa-strikethrough", tooltiptext: c.strikeThrough.tooltip, action: function () { return this.$editor().wrapSelection("strikeThrough", null); }, activeState: function () { return document.queryCommandState("strikeThrough"); } }), a("clear", { iconclass: "fa fa-ban", tooltiptext: c.clear.tooltip, action: function (a, b) {
                    var c;
                    this.$editor().wrapSelection("removeFormat", null);
                    var e = angular.element(d.getSelectionElement());
                    c = d.getAllSelectedElements();
                    var f = function (a, b) { a = angular.element(a); var c = b; return b || (c = a), angular.forEach(a.children(), function (a) { if ("ul" === a.tagName.toLowerCase() || "ol" === a.tagName.toLowerCase())
                        c = f(a, c);
                    else {
                        var b = angular.element("<p></p>");
                        b.html(angular.element(a).html()), c.after(b), c = b;
                    } }), a.remove(), c; };
                    angular.forEach(c, function (a) {
                        "ul" !== a.nodeName.toLowerCase() && "ol" !== a.nodeName.toLowerCase() ||
                            f(a);
                    }), angular.forEach(e.find("ul"), f), angular.forEach(e.find("ol"), f);
                    var g = this.$editor(), h = function (a) {
                        a = angular.element(a),
                            a[0] !== g.displayElements.text[0] && a.removeAttr("class"), angular.forEach(a.children(), h);
                    };
                    angular.forEach(e, h),
                        e[0] && "li" !== e[0].tagName.toLowerCase() && "ol" !== e[0].tagName.toLowerCase() && "ul" !== e[0].tagName.toLowerCase() && "true" !== e[0].getAttribute("contenteditable") && this.$editor().wrapSelection("formatBlock", "default"), b();
                } });
            var l = function (a) { return a.toLowerCase().indexOf("javascript") !== -1; };
            a("insertImage", { iconclass: "fa fa-picture-o", tooltiptext: c.insertImage.tooltip, action: function () {
                    var a;
                    if (a = b.prompt(c.insertImage.dialogPrompt, "http://"), a && "" !== a && "http://" !== a && !l(a)) {
                        d.getSelectionElement().tagName && "a" === d.getSelectionElement().tagName.toLowerCase() &&
                            d.setSelectionAfterElement(d.getSelectionElement());
                        var e = '<img src="' + a + '">';
                        return this.$editor().wrapSelection("insertHTML", e, !0);
                    }
                }, onElementSelect: { element: "img", action: e.imgOnSelectAction } }), a("insertVideo", { iconclass: "fa fa-youtube-play", tooltiptext: c.insertVideo.tooltip, action: function () {
                    var a;
                    if (a = b.prompt(c.insertVideo.dialogPrompt, "https://"), !l(a) && a && "" !== a && "https://" !== a && (videoId = e.extractYoutubeVideoId(a), videoId)) {
                        var f = "https://www.youtube.com/embed/" + videoId, g = '<img class="ta-insert-video" src="https://img.youtube.com/vi/' + videoId + '/hqdefault.jpg" ta-insert-video="' + f + '" contenteditable="false" allowfullscreen="true" frameborder="0" />';
                        return d.getSelectionElement().tagName && "a" === d.getSelectionElement().tagName.toLowerCase() && d.setSelectionAfterElement(d.getSelectionElement()), this.$editor().wrapSelection("insertHTML", g, !0);
                    }
                }, onElementSelect: { element: "img", onlyWithAttrs: ["ta-insert-video"], action: e.imgOnSelectAction } }), a("insertLink", { tooltiptext: c.insertLink.tooltip, iconclass: "fa fa-link", action: function () {
                    var a;
                    if (a = d.getSelectionElement().tagName && "a" === d.getSelectionElement().tagName.toLowerCase() ? b.prompt(c.insertLink.dialogPrompt, d.getSelectionElement().href) : b.prompt(c.insertLink.dialogPrompt, "http://"), a && "" !== a && "http://" !== a && !l(a))
                        return this.$editor().wrapSelection("createLink", a, !0);
                }, activeState: function (a) { return !!a && "A" === a[0].tagName; }, onElementSelect: { element: "a", action: e.aOnSelectAction } }), a("wordcount", { display: '<div id="toolbarWC" style="display:block; min-width:100px;">Words: <span ng-bind="wordcount"></span></div>', disabled: !0, wordcount: 0, activeState: function () {
                    var a = this.$editor().displayElements.text, b = a[0].innerHTML || "", c = 0;
                    return "" !== b.replace(/\s*<[^>]*?>\s*/g, "") && "" !== b.trim() && (c = b.replace(/<\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi, "").replace(/(<[^>]*?>\s*<[^>]*?>)/gi, " ").replace(/(<[^>]*?>)/gi, "").replace(/\s+/gi, " ").match(/\S+/g).length), this.wordcount = c, this.$editor().wordcount = c, !1;
                } }), a("charcount", { display: '<div id="toolbarCC" style="display:block; min-width:120px;">Characters: <span ng-bind="charcount"></span></div>', disabled: !0, charcount: 0, activeState: function () {
                    var a = this.$editor().displayElements.text, b = a[0].innerText || a[0].textContent, c = b.replace(/(\r\n|\n|\r)/gm, "").replace(/^\s+/g, " ").replace(/\s+$/g, " ").length;
                    return this.charcount = c, this.$editor().charcount = c, !1;
                } });
        }]);
    var f = "v1.5.16", g = { ie: function () { for (var a, b = 3, c = document.createElement("div"), d = c.getElementsByTagName("i"); c.innerHTML = "<!--[if gt IE " + ++b + "]><i></i><![endif]-->", d[0];)
            ; return b > 4 ? b : a; }(), webkit: /AppleWebKit\/([\d.]+)/i.test(navigator.userAgent), isFirefox: navigator.userAgent.toLowerCase().indexOf("firefox") > -1 }, h = h || {};
    h.now = function () { return h.now || h.mozNow || h.msNow || h.oNow || h.webkitNow || function () { return (new Date).getTime(); }; }();
    var i = /^(address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i, j = /^(ul|li|ol)$/i, k = /^(#text|span|address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;
    String.prototype.trim || (String.prototype.trim = function () { return this.replace(/^\s+|\s+$/g, ""); });
    var l, m, n, o, p, q;
    if (g.ie > 8 || void 0 === g.ie) {
        for (var r = document.styleSheets, s = 0; s < r.length; s++)
            if ((0 === r[s].media.length || r[s].media.mediaText.match(/(all|screen)/gi)) && r[s].href && r[s].href.match(/textangular\.(min\.|)css/gi)) {
                l = r[s];
                break;
            }
        l || (l = function () {
            var a = document.createElement("style");
            return g.webkit && a.appendChild(document.createTextNode("")), document.getElementsByTagName("head")[0].appendChild(a), a.sheet;
        }()),
            m = function (a, b) { return o(l, a, b); }, o = function (a, b, c) {
            var d, e;
            return a.cssRules ? d = Math.max(a.cssRules.length - 1, 0) : a.rules && (d = Math.max(a.rules.length - 1, 0)), a.insertRule ? a.insertRule(b + "{" + c + "}", d) : a.addRule(b, c, d), l.rules ? e = l.rules[d] : l.cssRules && (e = l.cssRules[d]), e;
        }, q = function (a, b) {
            var c, d;
            for (c = 0; c < b.length; c++)
                if (b[c].cssText === a.cssText) {
                    d = c;
                    break;
                }
            return d;
        }, n = function (a) { p(l, a); },
            p = function (a, b) { var c = a.cssRules || a.rules; if (c && 0 !== c.length) {
                var d = q(b, c);
                a.removeRule ? a.removeRule(d) : a.deleteRule(d);
            } };
    }
    angular.module("textAngular.factories", []).factory("taBrowserTag", [function () {
            return function (a) {
                return a ? "" === a ? void 0 === g.ie ? "div" : g.ie <= 8 ? "P" : "p" : g.ie <= 8 ? a.toUpperCase() : a : g.ie <= 8 ? "P" : "p";
            };
        }]).factory("taApplyCustomRenderers", ["taCustomRenderers", "taDOM", function (a, b) {
            return function (c) {
                var d = angular.element("<div></div>");
                return d[0].innerHTML = c, angular.forEach(a, function (a) {
                    var c = [];
                    a.selector && "" !== a.selector ? c = d.find(a.selector) : a.customAttribute && "" !== a.customAttribute && (c = b.getByAttribute(d, a.customAttribute)),
                        angular.forEach(c, function (b) { b = angular.element(b), a.selector && "" !== a.selector && a.customAttribute && "" !== a.customAttribute ? void 0 !== b.attr(a.customAttribute) && a.renderLogic(b) : a.renderLogic(b); });
                }), d[0].innerHTML;
            };
        }]).factory("taFixChrome", function () {
        var a = function (a, b) {
            if (!a || !angular.isString(a) || a.length <= 0)
                return a;
            for (var c, d, e, f = /style\s?=\s?(["'])(?:(?=(\\?))\2.)*?\1/gi, g = /<span class="Apple-converted-space">([^<]+)<\/span>/gi, h = "", i = 0; c = g.exec(a);)
                e = c[1], e = e.replace(/&nbsp;/gi, " "), h += a.substring(i, c.index) + e, i = c.index + c[0].length;
            if (i && (h += a.substring(i), a = h, h = "", i = 0), !b) {
                for (; c = f.exec(a);)
                    h += a.substring(i, c.index - 1), d = c[0],
                        c = /font-family: inherit;|line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;|color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);|background-color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);/gi.exec(d), c ? (d = d.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;|( |)color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);|( |)background-color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);/gi, ""),
                        d.length > 8 && (h += " " + d)) : h += " " + d, i = f.lastIndex;
                h += a.substring(i);
            }
            if (i > 0) {
                var j = h.replace(/<span\s?>(.*?)<\/span>(<br(\/|)>|)/gi, "$1");
                return j;
            }
            return a;
        };
        return a;
    }).factory("taSanitize", ["$sanitize", function (a) {
            function b(a, b) {
                for (var c, d = 0, e = 0, f = /<[^>]*>/gi; c = f.exec(a);)
                    if (e = c.index, "/" === c[0].substr(1, 1)) {
                        if (0 === d)
                            break;
                        d--;
                    }
                    else
                        d++;
                return b + a.substring(0, e) + angular.element(b)[0].outerHTML.substring(b.length) + a.substring(e);
            }
            function c(a) {
                if (!a || !angular.isString(a) || a.length <= 0)
                    return a;
                for (var d, f, g, h, i, k, l = /<([^>\/]+?)style=("([^"]+)"|'([^']+)')([^>]*)>/gi, m = "", n = "", o = 0; f = l.exec(a);) {
                    h = f[3] || f[4];
                    var p = new RegExp(j, "i");
                    if (angular.isString(h) && p.test(h)) {
                        i = "";
                        for (var q = new RegExp(j, "ig"); g = q.exec(h);)
                            for (d = 0; d < e.length; d++)
                                g[2 * d + 2] && (i += "<" + e[d].tag + ">");
                        k = c(a.substring(o, f.index)),
                            n += m.length > 0 ? b(k, m) : k,
                            h = h.replace(new RegExp(j, "ig"), ""),
                            n += "<" + f[1].trim(), h.length > 0 && (n += ' style="' + h + '"'), n += f[5] + ">",
                            o = f.index + f[0].length, m = i;
                    }
                }
                return n += m.length > 0 ? b(a.substring(o), m) : a.substring(o);
            }
            function d(a) {
                if (!a || !angular.isString(a) || a.length <= 0)
                    return a;
                for (var b, c = /<([^>\/]+?)align=("([^"]+)"|'([^']+)')([^>]*)>/gi, d = "", e = 0; b = c.exec(a);) {
                    d += a.substring(e, b.index),
                        e = b.index + b[0].length;
                    var f = "<" + b[1] + b[5];
                    /style=("([^"]+)"|'([^']+)')/gi.test(f) ?
                        f = f.replace(/style=("([^"]+)"|'([^']+)')/i, 'style="$2$3 text-align:' + (b[3] || b[4]) + ';"') :
                        f += ' style="text-align:' + (b[3] || b[4]) + ';"', f += ">",
                        d += f;
                }
                return d + a.substring(e);
            }
            for (var e = [{ property: "font-weight", values: ["bold"], tag: "b" }, { property: "font-style", values: ["italic"], tag: "i" }], f = [], g = 0; g < e.length; g++) {
                for (var h = "(" + e[g].property + ":\\s*(", i = 0; i < e[g].values.length; i++)
                    i > 0 && (h += "|"), h += e[g].values[i];
                h += ");)", f.push(h);
            }
            var j = "(" + f.join("|") + ")", k = new RegExp(/<span id="selectionBoundary_\d+_\d+" class="rangySelectionBoundary">[^<>]+?<\/span>/gi), l = new RegExp(/<span class="rangySelectionBoundary" id="selectionBoundary_\d+_\d+">[^<>]+?<\/span>/gi), m = new RegExp(/<span id="selectionBoundary_\d+_\d+" class="rangySelectionBoundary">[^<>]+?<\/span>/gi);
            return function (b, e, f) {
                if (!f)
                    try {
                        b = c(b);
                    }
                    catch (a) { }
                if (b = d(b))
                    try {
                        b = b.replace(k, ""), b = b.replace(l, ""), b = b.replace(k, ""), b = b.replace(m, "");
                    }
                    catch (a) { }
                var g;
                try {
                    g = a(b),
                        f && (g = b);
                }
                catch (a) {
                    g = e || "";
                }
                var h, i = g.match(/(<pre[^>]*>.*?<\/pre[^>]*>)/gi), j = g.replace(/(&#(9|10);)*/gi, ""), n = /<pre[^>]*>.*?<\/pre[^>]*>/gi, o = 0, p = 0;
                for (g = ""; null !== (h = n.exec(j)) && o < i.length;)
                    g += j.substring(p, h.index) + i[o], p = h.index + h[0].length, o++;
                return g + j.substring(p);
            };
        }]).factory("taToolExecuteAction", ["$q", "$log", function (a, b) {
            return function (c) {
                void 0 !== c && (this.$editor = function () { return c; });
                var d, e = a.defer(), f = e.promise, g = this.$editor();
                try {
                    d = this.action(e, g.startAction()),
                        f.finally(function () { g.endAction.call(g); });
                }
                catch (a) {
                    b.error(a);
                }
                (d || void 0 === d) &&
                    e.resolve();
            };
        }]), angular.module("textAngular.DOM", ["textAngular.factories"]).factory("taExecCommand", ["taSelection", "taBrowserTag", "$document", function (b, c, d) {
            var e = function (a, c) { var d, e, f = a.find("li"); for (e = f.length - 1; e >= 0; e--)
                d = angular.element("<" + c + ">" + f[e].innerHTML + "</" + c + ">"), a.after(d); a.remove(), b.setSelectionToElementEnd(d[0]); }, f = function (a, d, e, f, g) {
                var h, i, j, k, l, m = a.find("li");
                for (i = 0; i < m.length; i++)
                    if (m[i].outerHTML === d[0].outerHTML) {
                        l = i, i > 0 && (j = m[i - 1]), i + 1 < m.length && (k = m[i + 1]);
                        break;
                    }
                var n = "";
                if (f ? n += "<" + g + ">" + d[0].innerHTML + "</" + g + ">" : (n += "<" + c(e) + ">", n += "<li>" + d[0].innerHTML + "</li>", n += "</" + c(e) + ">"), h = angular.element(n), !j)
                    return d.remove(), a.after(angular.element(a[0].outerHTML)), a.after(h), a.remove(), void b.setSelectionToElementEnd(h[0]);
                if (k) {
                    var o = (a.parent(), ""), p = a[0].nodeName.toLowerCase();
                    for (o += "<" + p + ">", i = 0; i < l; i++)
                        o += "<li>" + m[i].innerHTML + "</li>";
                    o += "</" + p + ">";
                    var q = "";
                    for (q += "<" + p + ">", i = l + 1; i < m.length; i++)
                        q += "<li>" + m[i].innerHTML + "</li>";
                    q += "</" + p + ">",
                        a.after(angular.element(q)), a.after(h), a.after(angular.element(o)), a.remove(),
                        b.setSelectionToElementEnd(h[0]);
                }
                else
                    d.remove(), a.after(h), b.setSelectionToElementEnd(h[0]);
            }, g = function (a, d, e, f, g) {
                var h, i, j, k, l, m = a.find("li"), n = [];
                for (i = 0; i < m.length; i++)
                    for (j = 0; j < d.length; j++)
                        m[i].isEqualNode(d[j]) && (n[j] = i);
                n[0] > 0 && (k = m[n[0] - 1]), n[d.length - 1] + 1 < m.length && (l = m[n[d.length - 1] + 1]);
                var o = "";
                if (f)
                    for (j = 0; j < d.length; j++)
                        o += "<" + g + ">" + d[j].innerHTML + "</" + g + ">", d[j].remove();
                else {
                    for (o += "<" + c(e) + ">", j = 0; j < d.length; j++)
                        o += d[j].outerHTML, d[j].remove();
                    o += "</" + c(e) + ">";
                }
                if (h = angular.element(o), !k)
                    return a.after(angular.element(a[0].outerHTML)), a.after(h), a.remove(), void b.setSelectionToElementEnd(h[0]);
                if (!l)
                    return a.after(h), void b.setSelectionToElementEnd(h[0]);
                var p = "", q = a[0].nodeName.toLowerCase();
                for (p += "<" + q + ">", i = 0; i < n[0]; i++)
                    p += "<li>" + m[i].innerHTML + "</li>";
                p += "</" + q + ">";
                var r = "";
                for (r += "<" + q + ">", i = n[d.length - 1] + 1; i < m.length; i++)
                    r += "<li>" + m[i].innerHTML + "</li>";
                r += "</" + q + ">", a.after(angular.element(r)), a.after(h), a.after(angular.element(p)), a.remove(),
                    b.setSelectionToElementEnd(h[0]);
            }, h = function (a) { /(<br(|\/)>)$/i.test(a.innerHTML.trim()) ? b.setSelectionBeforeElement(angular.element(a).find("br")[0]) : b.setSelectionToElementEnd(a); }, k = function (a, b) { var c = angular.element("<" + b + ">" + a[0].innerHTML + "</" + b + ">"); a.after(c), a.remove(), h(c.find("li")[0]); }, l = function (a, b, d) { for (var e = "", f = 0; f < a.length; f++)
                e += "<" + c("li") + ">" + a[f].innerHTML + "</" + c("li") + ">"; var g = angular.element("<" + d + ">" + e + "</" + d + ">"); b.after(g), b.remove(), h(g.find("li")[0]); }, m = function (a, b) {
                for (var c = 0; c < a.childNodes.length; c++) {
                    var d = a.childNodes[c];
                    d.tagName && d.tagName.match(i) && m(d, b);
                }
                if (null === a.parentNode)
                    return a;
                if ("<br>" === b)
                    return a;
                var e = angular.element(b);
                return e[0].innerHTML = a.innerHTML, a.parentNode.insertBefore(e[0], a), a.parentNode.removeChild(a), e;
            };
            return function (h, n) {
                return h = c(h), function (o, p, q, r) {
                    var s, t, u, v, w, x, y, z, A = angular.element("<" + h + ">");
                    try {
                        b.getSelection && (z = b.getSelection()), y = b.getSelectionElement();
                        var B, C;
                        void 0 !== y.tagName && ("div" === y.tagName.toLowerCase() && /taTextElement.+/.test(y.id) && z && z.start && 1 === z.start.offset && 1 === z.end.offset ? (B = y.innerHTML, /<br>/i.test(B) && (B = B.replace(/<br>/i, "&#8203;")), /<br\/>/i.test(B) && (B = B.replace(/<br\/>/i, "&#8203;")),
                            /<span>(<span>)+/i.test(B) && (B = __.replace(/<span>(<span>)+/i, "<span>")),
                            /<\/span>(<\/span>)+/i.test(B) && (B = __.replace(/<\/span>(<\/span>)+/i, "</span>")), /<span><\/span>/i.test(B) && (B = B.replace(/<span><\/span>/i, "")),
                            C = "<div>" + B + "</div>", y.innerHTML = C, b.setSelectionToElementEnd(y.childNodes[0]), y = b.getSelectionElement()) : "span" === y.tagName.toLowerCase() && z && z.start && 1 === z.start.offset && 1 === z.end.offset ? (B = y.innerHTML, /<br>/i.test(B) && (B = B.replace(/<br>/i, "&#8203;")), /<br\/>/i.test(B) && (B = B.replace(/<br\/>/i, "&#8203;")),
                            /<span>(<span>)+/i.test(B) && (B = __.replace(/<span>(<span>)+/i, "<span>")),
                            /<\/span>(<\/span>)+/i.test(B) && (B = __.replace(/<\/span>(<\/span>)+/i, "</span>")), /<span><\/span>/i.test(B) && (B = B.replace(/<span><\/span>/i, "")),
                            C = "<div>" + B + "</div>", y.innerHTML = C, b.setSelectionToElementEnd(y.childNodes[0]), y = b.getSelectionElement()) : "p" === y.tagName.toLowerCase() && z && z.start && 1 === z.start.offset && 1 === z.end.offset ? (B = y.innerHTML, /<br>/i.test(B) && (B = B.replace(/<br>/i, "&#8203;"),
                            y.innerHTML = B)) : "li" === y.tagName.toLowerCase() && z && z.start && z.start.offset === z.end.offset && (B = y.innerHTML, /<br>/i.test(B) && (B = B.replace(/<br>/i, ""),
                            y.innerHTML = B)));
                    }
                    catch (a) { }
                    if (y) {
                        var D = angular.element(y), E = y && y.tagName && y.tagName.toLowerCase() ||
                            "";
                        if ("insertorderedlist" === o.toLowerCase() || "insertunorderedlist" === o.toLowerCase()) {
                            var F = c("insertorderedlist" === o.toLowerCase() ? "ol" : "ul"), G = b.getOnlySelectedElements();
                            if (G.length > 1 && ("ol" === E || "ul" === E))
                                return g(D, G, F, F === E, h);
                            if (E === F)
                                return D[0].childNodes.length !== G.length && 1 === G.length ? (D = angular.element(G[0]), f(D.parent(), D, F, !0, h)) : e(D, h);
                            if ("li" === E && D.parent()[0].tagName.toLowerCase() === F && 1 === D.parent().children().length)
                                return e(D.parent(), h);
                            if ("li" === E && D.parent()[0].tagName.toLowerCase() !== F && 1 === D.parent().children().length)
                                return k(D.parent(), F);
                            if (E.match(i) && !D.hasClass("ta-bind")) {
                                if (G.length && D[0].childNodes.length !== G.length && 1 === G.length)
                                    return D = angular.element(G[0]), f(D.parent(), D, F, F === E, h);
                                if ("ol" === E || "ul" === E)
                                    return k(D, F);
                                var H = !1;
                                return angular.forEach(D.children(), function (a) { a.tagName.match(i) && (H = !0); }), H ? l(D.children(), D, F) : l([angular.element("<div>" + y.innerHTML + "</div>")[0]], D, F);
                            }
                            if (E.match(i)) {
                                if (v = b.getOnlySelectedElements(), 0 === v.length)
                                    t = angular.element("<" + F + "><li>" + y.innerHTML + "</li></" + F + ">"), D.html(""), D.append(t);
                                else {
                                    if (1 === v.length && ("ol" === v[0].tagName.toLowerCase() || "ul" === v[0].tagName.toLowerCase()))
                                        return v[0].tagName.toLowerCase() === F ? e(angular.element(v[0]), h) : k(angular.element(v[0]), F);
                                    u = "";
                                    var I = [];
                                    for (s = 0; s < v.length; s++)
                                        if (3 !== v[s].nodeType) {
                                            var J = angular.element(v[s]);
                                            if ("li" === v[s].tagName.toLowerCase())
                                                continue;
                                            u += "ol" === v[s].tagName.toLowerCase() || "ul" === v[s].tagName.toLowerCase() ? J[0].innerHTML : "span" !== v[s].tagName.toLowerCase() || "ol" !== v[s].childNodes[0].tagName.toLowerCase() && "ul" !== v[s].childNodes[0].tagName.toLowerCase() ? "<" + c("li") + ">" + J[0].innerHTML + "</" + c("li") + ">" : J[0].childNodes[0].innerHTML, I.unshift(J);
                                        }
                                    t = angular.element("<" + F + ">" + u + "</" + F + ">"), I.pop().replaceWith(t), angular.forEach(I, function (a) { a.remove(); });
                                }
                                return void b.setSelectionToElementEnd(t[0]);
                            }
                        }
                        else {
                            if ("formatblock" === o.toLowerCase()) {
                                for (x = q.toLowerCase().replace(/[<>]/gi, ""), "default" === x.trim() && (x = h, q = "<" + h + ">"), t = "li" === E ? D.parent() : D; !t[0].tagName || !t[0].tagName.match(i) && !t.parent().attr("contenteditable");)
                                    t = t.parent(),
                                        E = (t[0].tagName || "").toLowerCase();
                                if (E === x) {
                                    v = t.children();
                                    var K = !1;
                                    for (s = 0; s < v.length; s++)
                                        K = K || v[s].tagName.match(i);
                                    K ? (t.after(v), w = t.next(), t.remove(), t = w) : (A.append(t[0].childNodes), t.after(A), t.remove(), t = A);
                                }
                                else if (t.parent()[0].tagName.toLowerCase() !== x || t.parent().hasClass("ta-bind"))
                                    if (E.match(j))
                                        t.wrap(q);
                                    else {
                                        for (v = b.getOnlySelectedElements(), 0 === v.length && (v = [t[0]]), s = 0; s < v.length; s++)
                                            if (3 === v[s].nodeType || !v[s].tagName.match(i))
                                                for (; 3 === v[s].nodeType || !v[s].tagName || !v[s].tagName.match(i);)
                                                    v[s] = v[s].parentNode;
                                        if (v = v.filter(function (a, b, c) { return c.indexOf(a) === b; }),
                                            v.length > 1 && (v = v.filter(function (a, b, c) { return !("div" === a.nodeName.toLowerCase() && /^taTextElement/.test(a.id)); })), angular.element(v[0]).hasClass("ta-bind"))
                                            t = angular.element(q), t[0].innerHTML = v[0].innerHTML, v[0].innerHTML = t[0].outerHTML;
                                        else if ("blockquote" === x) {
                                            for (u = "", s = 0; s < v.length; s++)
                                                u += v[s].outerHTML;
                                            for (t = angular.element(q), t[0].innerHTML = u, v[0].parentNode.insertBefore(t[0], v[0]), s = v.length - 1; s >= 0; s--)
                                                v[s].parentNode && v[s].parentNode.removeChild(v[s]);
                                        }
                                        else if ("pre" === x && b.getStateShiftKey()) {
                                            for (u = "", s = 0; s < v.length; s++)
                                                u += v[s].outerHTML;
                                            for (t = angular.element(q), t[0].innerHTML = u, v[0].parentNode.insertBefore(t[0], v[0]), s = v.length - 1; s >= 0; s--)
                                                v[s].parentNode && v[s].parentNode.removeChild(v[s]);
                                        }
                                        else
                                            for (s = 0; s < v.length; s++) {
                                                var L = m(v[s], q);
                                                v[s] === t[0] && (t = angular.element(L));
                                            }
                                    }
                                else {
                                    var M = t.parent(), N = M.contents();
                                    for (s = 0; s < N.length; s++)
                                        M.parent().hasClass("ta-bind") && 3 === N[s].nodeType && (A = angular.element("<" + h + ">"), A[0].innerHTML = N[s].outerHTML, N[s] = A[0]), M.parent()[0].insertBefore(N[s], M[0]);
                                    M.remove();
                                }
                                return b.setSelectionToElementEnd(t[0]), void t[0].focus();
                            }
                            if ("createlink" === o.toLowerCase()) {
                                if ("a" === E)
                                    return void (b.getSelectionElement().href = q);
                                var O = '<a href="' + q + '" target="' + (r.a.target ? r.a.target : "") + '">', P = "</a>", Q = b.getSelection();
                                if (Q.collapsed)
                                    b.insertHtml(O + q + P, n);
                                else if (a.getSelection().getRangeAt(0).canSurroundContents()) {
                                    var R = angular.element(O + P)[0];
                                    a.getSelection().getRangeAt(0).surroundContents(R);
                                }
                                return;
                            }
                            if ("inserthtml" === o.toLowerCase())
                                return void b.insertHtml(q, n);
                        }
                        try {
                            d[0].execCommand(o, p, q);
                        }
                        catch (a) { }
                    }
                };
            };
        }]).service("taSelection", ["$document", "taDOM", "$log",
        function (b, c, d) {
            var e, f = b[0], g = function (a, b) {
                return a.tagName && a.tagName.match(/^br$/i) && 0 === b && !a.previousSibling ? { element: a.parentNode, offset: 0 } : { element: a, offset: b };
            }, h = { getSelection: function () {
                    var b;
                    try {
                        b = a.getSelection().getRangeAt(0);
                    }
                    catch (a) {
                        return;
                    }
                    var c = b.commonAncestorContainer, d = { start: g(b.startContainer, b.startOffset), end: g(b.endContainer, b.endOffset), collapsed: b.collapsed };
                    return 3 === c.nodeType && ("div" === c.parentNode.nodeName.toLowerCase() && /^taTextElement/.test(c.parentNode.id) || (c = c.parentNode)), "div" === c.nodeName.toLowerCase() && /^taTextElement/.test(c.id) ? (d.start.element = c.childNodes[d.start.offset], d.end.element = c.childNodes[d.end.offset], d.container = c) : c.parentNode === d.start.element || c.parentNode === d.end.element ? d.container = c.parentNode : d.container = c, d;
                },
                updateLeftArrowKey: function (b) {
                    var c = a.getSelection().getRangeAt(0);
                    if (c && c.collapsed) {
                        var d = h.getFlattenedDom(c);
                        if (!d.findIndex)
                            return;
                        var e, f, g = c.startContainer, i = d.findIndex(function (a, b) { if (a.node === g)
                            return !0; var c = a.parents.indexOf(g); return c !== -1; });
                        if (d.forEach(function (a, b) {
                            a.parents.forEach(function (a, b) { });
                        }), i + 1 < d.length && (f = d[i + 1].node), f && f.textContent && (e = /^\ufeff([^\ufeff]*)$/.exec(f.textContent)))
                            return;
                        var j;
                        if (i > 0 && (j = d[i - 1].node), 0 === c.startOffset && j && (e = /^\ufeff([^\ufeff]*)$/.exec(j.textContent)))
                            return void h.setSelectionToElementEnd(j);
                    }
                },
                updateRightArrowKey: function (a) { }, getFlattenedDom: function (a) {
                    function b(a) {
                        if (a.node.childNodes.length) {
                            var c = Array.prototype.slice.call(a.node.childNodes);
                            c.forEach(function (c) { var d = a.parents.slice(); d.slice(-1)[0] !== a.node && d.push(a.node), b({ parents: d, node: c }); });
                        }
                        else
                            d.push({ parents: a.parents, node: a.node });
                    }
                    var c = a.commonAncestorContainer.parentNode;
                    if (!c)
                        return a.commonAncestorContainer.childNodes;
                    var d = Array.prototype.slice.call(c.childNodes), e = d.indexOf(a.startContainer);
                    return e + 1 < d.length && e > 0 || c.parentNode && (c = c.parentNode), d = [], b({ parents: [c], node: c }), d;
                }, getOnlySelectedElements: function () {
                    var b = a.getSelection().getRangeAt(0), c = b.commonAncestorContainer;
                    return c = 3 === c.nodeType ? c.parentNode : c, b.getNodes([1], function (a) { return a.parentNode === c; });
                },
                getAllSelectedElements: function () {
                    var b = a.getSelection().getRangeAt(0), c = b.commonAncestorContainer;
                    c = 3 === c.nodeType ? c.parentNode : c;
                    var d = b.getNodes([1], function (a) { return a.parentNode === c; }), e = c.innerHTML;
                    if (e = e.replace(/<span id=.selectionBoundary[^>]+>\ufeff?<\/span>/gi, ""), e === b.toHtml() && ("div" !== c.nodeName.toLowerCase() || !/^taTextElement/.test(c.id))) {
                        for (var f = [], g = d.length; g--; f.unshift(d[g]))
                            ;
                        d = f, d.push(c);
                    }
                    return d;
                },
                getSelectionElement: function () { var a = h.getSelection(); return a ? h.getSelection().container : void 0; }, setSelection: function (b, c, d, e) { var f = a.createRange(); f.setStart(b, d), f.setEnd(c, e), a.getSelection().setSingleRange(f); }, setSelectionBeforeElement: function (b) { var c = a.createRange(); c.selectNode(b), c.collapse(!0), a.getSelection().setSingleRange(c); }, setSelectionAfterElement: function (b) { var c = a.createRange(); c.selectNode(b), c.collapse(!1), a.getSelection().setSingleRange(c); }, setSelectionToElementStart: function (b) { var c = a.createRange(); c.selectNodeContents(b), c.collapse(!0), a.getSelection().setSingleRange(c); }, setSelectionToElementEnd: function (b) { var c = a.createRange(); c.selectNodeContents(b), c.collapse(!1), b.childNodes && b.childNodes[b.childNodes.length - 1] && "br" === b.childNodes[b.childNodes.length - 1].nodeName && (c.startOffset = c.endOffset = c.startOffset - 1), a.getSelection().setSingleRange(c); }, setStateShiftKey: function (a) { e = a; }, getStateShiftKey: function () { return e; },
                insertHtml: function (b, d) {
                    var e, g, j, l, m, n, o, p = angular.element("<div>" + b + "</div>"), q = a.getSelection().getRangeAt(0), r = f.createDocumentFragment(), s = p[0].childNodes, t = !0;
                    if (s.length > 0) {
                        for (l = [], j = 0; j < s.length; j++) {
                            var u = s[j];
                            "p" === u.nodeName.toLowerCase() && "" === u.innerHTML.trim() || (t = t && !i.test(u.nodeName), l.push(u));
                        }
                        for (var v = 0; v < l.length; v++)
                            n = r.appendChild(l[v]);
                        !t && q.collapsed && /^(|<br(|\/)>)$/i.test(q.startContainer.innerHTML) && q.selectNode(q.startContainer);
                    }
                    else
                        t = !0,
                            n = r = f.createTextNode(b);
                    if (t)
                        q.deleteContents();
                    else if (q.collapsed && q.startContainer !== d)
                        if (q.startContainer.innerHTML && q.startContainer.innerHTML.match(/^<[^>]*>$/i))
                            e = q.startContainer, 1 === q.startOffset ? (q.setStartAfter(e), q.setEndAfter(e)) : (q.setStartBefore(e), q.setEndBefore(e));
                        else {
                            if (3 === q.startContainer.nodeType && q.startContainer.parentNode !== d)
                                for (e = q.startContainer.parentNode, g = e.cloneNode(),
                                    c.splitNodes(e.childNodes, e, g, q.startContainer, q.startOffset); !k.test(e.nodeName);) {
                                    angular.element(e).after(g), e = e.parentNode;
                                    var w = g;
                                    g = e.cloneNode(),
                                        c.splitNodes(e.childNodes, e, g, w);
                                }
                            else
                                e = q.startContainer, g = e.cloneNode(), c.splitNodes(e.childNodes, e, g, void 0, void 0, q.startOffset);
                            if (angular.element(e).after(g),
                                q.setStartAfter(e), q.setEndAfter(e), /^(|<br(|\/)>)$/i.test(e.innerHTML.trim()) && (q.setStartBefore(e), q.setEndBefore(e), angular.element(e).remove()), /^(|<br(|\/)>)$/i.test(g.innerHTML.trim()) && angular.element(g).remove(), "li" === e.nodeName.toLowerCase()) {
                                for (o = f.createDocumentFragment(), m = 0; m < r.childNodes.length; m++)
                                    p = angular.element("<li>"), c.transferChildNodes(r.childNodes[m], p[0]), c.transferNodeAttributes(r.childNodes[m], p[0]), o.appendChild(p[0]);
                                r = o, n && (n = r.childNodes[r.childNodes.length - 1], n = n.childNodes[n.childNodes.length - 1]);
                            }
                        }
                    else
                        q.deleteContents();
                    q.insertNode(r), n && h.setSelectionToElementEnd(n);
                } };
            return h;
        }]).service("taDOM", function () {
        var a = {
            getByAttribute: function (b, c) { var d = [], e = b.children(); return e.length && angular.forEach(e, function (b) { d = d.concat(a.getByAttribute(angular.element(b), c)); }), void 0 !== b.attr(c) && d.push(b), d; }, transferChildNodes: function (a, b) {
                for (b.innerHTML = ""; a.childNodes.length > 0;)
                    b.appendChild(a.childNodes[0]);
                return b;
            }, splitNodes: function (b, c, d, e, f, g) {
                if (!e && isNaN(g))
                    throw new Error("taDOM.splitNodes requires a splitNode or splitIndex");
                for (var h = document.createDocumentFragment(), i = document.createDocumentFragment(), j = 0; b.length > 0 && (isNaN(g) || g !== j) && b[0] !== e;)
                    h.appendChild(b[0]),
                        j++;
                for (!isNaN(f) && f >= 0 && b[0] && (h.appendChild(document.createTextNode(b[0].nodeValue.substring(0, f))), b[0].nodeValue = b[0].nodeValue.substring(f)); b.length > 0;)
                    i.appendChild(b[0]);
                a.transferChildNodes(h, c), a.transferChildNodes(i, d);
            }, transferNodeAttributes: function (a, b) { for (var c = 0; c < a.attributes.length; c++)
                b.setAttribute(a.attributes[c].name, a.attributes[c].value); return b; }
        };
        return a;
    }), angular.module("textAngular.validators", []).directive("taMaxText", function () { return { restrict: "A", require: "ngModel", link: function (a, b, c, d) { var e = parseInt(a.$eval(c.taMaxText)); if (isNaN(e))
            throw "Max text must be an integer"; c.$observe("taMaxText", function (a) { if (e = parseInt(a), isNaN(e))
            throw "Max text must be an integer"; d.$dirty && d.$validate(); }), d.$validators.taMaxText = function (a) { var b = angular.element("<div/>"); return b.html(a), b.text().length <= e; }; } }; }).directive("taMinText", function () { return { restrict: "A", require: "ngModel", link: function (a, b, c, d) { var e = parseInt(a.$eval(c.taMinText)); if (isNaN(e))
            throw "Min text must be an integer"; c.$observe("taMinText", function (a) { if (e = parseInt(a), isNaN(e))
            throw "Min text must be an integer"; d.$dirty && d.$validate(); }), d.$validators.taMinText = function (a) { var b = angular.element("<div/>"); return b.html(a), !b.text().length || b.text().length >= e; }; } }; }), angular.module("textAngular.taBind", ["textAngular.factories", "textAngular.DOM"]).service("_taBlankTest", [function () {
            return function (a) {
                if (!a)
                    return !0;
                var b = d(a);
                return "" === b && !/<img[^>]+>/.test(a);
            };
        }]).directive("taButton", [function () {
            return { link: function (a, b, c) {
                    b.attr("unselectable", "on"), b.on("mousedown", function (a, b) {
                        return b && angular.extend(a, b), a.preventDefault(), !1;
                    });
                } };
        }]).directive("taBind", ["taSanitize", "$timeout", "$document", "taFixChrome", "taBrowserTag", "taSelection", "taSelectableElements", "taApplyCustomRenderers", "taOptions", "_taBlankTest", "$parse", "taDOM", "textAngularManager", function (b, c, d, e, f, h, j, l, o, p, q, r, s) {
            return { priority: 2,
                require: ["ngModel", "?ngModelOptions"], link: function (f, r, u, v) {
                    function w(a) { var b; return V.forEach(function (c) { if (c.keyCode === a.keyCode) {
                        var d = (a.metaKey ? N : 0) + (a.ctrlKey ? M : 0) + (a.shiftKey ? P : 0) + (a.altKey ? O : 0);
                        if (c.forbiddenModifiers & d)
                            return;
                        c.mustHaveModifiers.every(function (a) { return d & a; }) && (b = c.specialKey);
                    } }), b; }
                    var x, y, z, A, B = v[0], C = v[1] || {}, D = void 0 !== r.attr("contenteditable") && r.attr("contenteditable"), E = D || "textarea" === r[0].tagName.toLowerCase() || "input" === r[0].tagName.toLowerCase(), F = !1, G = !1, H = !1, I = u.taUnsafeSanitizer || o.disableSanitizer, J = u.taKeepStyles || o.keepStyles, K = /^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i, L = /^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i, M = 1, N = 2, O = 4, P = 8, Q = 13, R = 16, S = 9, T = 37, U = 39, V = [
                        { specialKey: "UndoKey", forbiddenModifiers: O + P, mustHaveModifiers: [N + M], keyCode: 90 },
                        { specialKey: "RedoKey", forbiddenModifiers: O, mustHaveModifiers: [N + M, P], keyCode: 90 },
                        { specialKey: "RedoKey", forbiddenModifiers: O + P, mustHaveModifiers: [N + M], keyCode: 89 },
                        { specialKey: "TabKey", forbiddenModifiers: N + P + O + M, mustHaveModifiers: [], keyCode: S },
                        { specialKey: "ShiftTabKey", forbiddenModifiers: N + O + M, mustHaveModifiers: [P], keyCode: S }
                    ];
                    void 0 === u.taDefaultWrap && (u.taDefaultWrap = "p"),
                        "" === u.taDefaultWrap ? (z = "", A = void 0 === g.ie ? "<div><br></div>" : g.ie >= 11 ? "<p><br></p>" : g.ie <= 8 ? "<P>&nbsp;</P>" : "<p>&nbsp;</p>") : (z = void 0 === g.ie || g.ie >= 11 ? "br" === u.taDefaultWrap.toLowerCase() ? "<BR><BR>" : "<" + u.taDefaultWrap + "><br></" + u.taDefaultWrap + ">" : g.ie <= 8 ? "<" + u.taDefaultWrap.toUpperCase() + "></" + u.taDefaultWrap.toUpperCase() + ">" : "<" + u.taDefaultWrap + "></" + u.taDefaultWrap + ">", A = void 0 === g.ie || g.ie >= 11 ? "br" === u.taDefaultWrap.toLowerCase() ? "<br><br>" : "<" + u.taDefaultWrap + "><br></" + u.taDefaultWrap + ">" : g.ie <= 8 ? "<" + u.taDefaultWrap.toUpperCase() + ">&nbsp;</" + u.taDefaultWrap.toUpperCase() + ">" : "<" + u.taDefaultWrap + ">&nbsp;</" + u.taDefaultWrap + ">"),
                        C.$options || (C.$options = {});
                    var W = function (a) {
                        if (p(a))
                            return a;
                        var b = angular.element("<div>" + a + "</div>");
                        if (0 === b.children().length)
                            a = "<" + u.taDefaultWrap + ">" + a + "</" + u.taDefaultWrap + ">";
                        else {
                            var c, d = b[0].childNodes, e = !1;
                            for (c = 0; c < d.length && !(e = d[c].nodeName.toLowerCase().match(i)); c++)
                                ;
                            if (e)
                                for (a = "", c = 0; c < d.length; c++) {
                                    var f = d[c], g = f.nodeName.toLowerCase();
                                    if ("#comment" === g)
                                        a += "<!--" + f.nodeValue + "-->";
                                    else if ("#text" === g) {
                                        var h = f.textContent;
                                        a += h.trim() ? "<" + u.taDefaultWrap + ">" + h + "</" + u.taDefaultWrap + ">" : h;
                                    }
                                    else if (g.match(i))
                                        a += f.outerHTML;
                                    else {
                                        var j = f.outerHTML || f.nodeValue;
                                        a += "" !== j.trim() ? "<" + u.taDefaultWrap + ">" + j + "</" + u.taDefaultWrap + ">" : j;
                                    }
                                }
                            else
                                a = "<" + u.taDefaultWrap + ">" + a + "</" + u.taDefaultWrap + ">";
                        }
                        return a;
                    };
                    u.taPaste && (y = q(u.taPaste)), r.addClass("ta-bind");
                    var X;
                    f["$undoManager" + (u.id || "")] = B.$undoManager = { _stack: [], _index: 0, _max: 1e3, push: function (a) { return "undefined" == typeof a || null === a || "undefined" != typeof this.current() && null !== this.current() && a === this.current() ? a : (this._index < this._stack.length - 1 && (this._stack = this._stack.slice(0, this._index + 1)), this._stack.push(a), X && c.cancel(X), this._stack.length > this._max && this._stack.shift(), this._index = this._stack.length - 1, a); }, undo: function () { return this.setToIndex(this._index - 1); }, redo: function () { return this.setToIndex(this._index + 1); }, setToIndex: function (a) { if (!(a < 0 || a > this._stack.length - 1))
                            return this._index = a, this.current(); }, current: function () { return this._stack[this._index]; } };
                    var Y, Z = function () { if (D)
                        return r[0].innerHTML; if (E)
                        return r.val(); throw "textAngular Error: attempting to update non-editable taBind"; }, $ = function (a) {
                        return f.$emit("ta-element-select", this), a.preventDefault(), !1;
                    }, _ = f["reApplyOnSelectorHandlers" + (u.id || "")] = function () {
                        F || angular.forEach(j, function (a) {
                            r.find(a).off("click", $).on("click", $);
                        });
                    }, aa = function (a, b, c) {
                        H = c || !1, "undefined" != typeof b && null !== b || (b = D),
                            "undefined" != typeof a && null !== a || (a = Z()), p(a) ? ("" !== B.$viewValue && B.$setViewValue(""), b && "" !== B.$undoManager.current() && B.$undoManager.push("")) : (_(), B.$viewValue !== a && (B.$setViewValue(a), b && B.$undoManager.push(a))), B.$render();
                    }, ba = function (a) { r[0].innerHTML = a; }, ca = f["$undoTaBind" + (u.id || "")] = function () {
                        if (!F && D) {
                            var a = B.$undoManager.undo();
                            "undefined" != typeof a && null !== a && (ba(a), aa(a, !1), Y && c.cancel(Y), Y = c(function () { r[0].focus(), h.setSelectionToElementEnd(r[0]); }, 1));
                        }
                    }, da = f["$redoTaBind" + (u.id || "")] = function () {
                        if (!F && D) {
                            var a = B.$undoManager.redo();
                            "undefined" != typeof a && null !== a && (ba(a), aa(a, !1),
                                Y && c.cancel(Y), Y = c(function () { r[0].focus(), h.setSelectionToElementEnd(r[0]); }, 1));
                        }
                    };
                    f["updateTaBind" + (u.id || "")] = function () { F || aa(void 0, void 0, !0); };
                    var ea = function (a) { return B.$oldViewValue = b(e(a, J), B.$oldViewValue, I); };
                    if (r.attr("required") && (B.$validators.required = function (a, b) { return !p(a || b); }),
                        B.$parsers.push(ea), B.$parsers.unshift(W),
                        B.$formatters.push(ea), B.$formatters.unshift(W), B.$formatters.unshift(function (a) { return B.$undoManager.push(a || ""); }), E)
                        if (f.events = {}, D) {
                            var fa = !1, ga = function (a) {
                                var d = void 0 !== a && a.match(/content=["']*OneNote.File/i);
                                if (a && a.trim().length) {
                                    if (a.match(/class=["']*Mso(Normal|List)/i) || a.match(/content=["']*Word.Document/i) || a.match(/content=["']*OneNote.File/i)) {
                                        var e = a.match(/<!--StartFragment-->([\s\S]*?)<!--EndFragment-->/i);
                                        e = e ? e[1] : a, e = e.replace(/<o:p>[\s\S]*?<\/o:p>/gi, "").replace(/class=(["']|)MsoNormal(["']|)/gi, "");
                                        var g = angular.element("<div>" + e + "</div>"), i = angular.element("<div></div>"), j = { element: null, lastIndent: [], lastLi: null, isUl: !1 };
                                        j.lastIndent.peek = function () { var a = this.length; if (a > 0)
                                            return this[a - 1]; };
                                        for (var k = function (a) { j.isUl = a, j.element = angular.element(a ? "<ul>" : "<ol>"), j.lastIndent = [], j.lastIndent.peek = function () { var a = this.length; if (a > 0)
                                            return this[a - 1]; }, j.lastLevelMatch = null; }, l = 0; l <= g[0].childNodes.length; l++)
                                            if (g[0].childNodes[l] && "#text" !== g[0].childNodes[l].nodeName) {
                                                var m = g[0].childNodes[l].tagName.toLowerCase();
                                                if ("p" === m || "ul" === m || "h1" === m || "h2" === m || "h3" === m || "h4" === m || "h5" === m || "h6" === m || "table" === m) {
                                                    var n = angular.element(g[0].childNodes[l]), o = (n.attr("class") || "").match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);
                                                    if (o) {
                                                        if (n[0].childNodes.length < 2 || n[0].childNodes[1].childNodes.length < 1)
                                                            continue;
                                                        var p = "bullet" === o[1].toLowerCase() || "number" !== o[1].toLowerCase() && !(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].innerHTML) || /^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].childNodes[0].innerHTML)), q = (n.attr("style") || "").match(/margin-left:([\-\.0-9]*)/i), s = parseFloat(q ? q[1] : 0), t = (n.attr("style") || "").match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);
                                                        if (t && t[2] && (s = parseInt(t[2])), t && (!j.lastLevelMatch || t[1] !== j.lastLevelMatch[1]) || !o[3] || "first" === o[3].toLowerCase() || null === j.lastIndent.peek() || j.isUl !== p && j.lastIndent.peek() === s)
                                                            k(p), i.append(j.element);
                                                        else if (null != j.lastIndent.peek() && j.lastIndent.peek() < s)
                                                            j.element = angular.element(p ? "<ul>" : "<ol>"), j.lastLi.append(j.element);
                                                        else if (null != j.lastIndent.peek() && j.lastIndent.peek() > s) {
                                                            for (; null != j.lastIndent.peek() && j.lastIndent.peek() > s;)
                                                                if ("li" !== j.element.parent()[0].tagName.toLowerCase()) {
                                                                    if (!/[uo]l/i.test(j.element.parent()[0].tagName.toLowerCase()))
                                                                        break;
                                                                    j.element = j.element.parent(), j.lastIndent.pop();
                                                                }
                                                                else
                                                                    j.element = j.element.parent();
                                                            j.isUl = "ul" === j.element[0].tagName.toLowerCase(), p !== j.isUl && (k(p), i.append(j.element));
                                                        }
                                                        j.lastLevelMatch = t, s !== j.lastIndent.peek() && j.lastIndent.push(s), j.lastLi = angular.element("<li>"), j.element.append(j.lastLi), j.lastLi.html(n.html().replace(/<!(--|)\[if !supportLists\](--|)>[\s\S]*?<!(--|)\[endif\](--|)>/gi, "")), n.remove();
                                                    }
                                                    else
                                                        k(!1), i.append(n);
                                                }
                                            }
                                        var u = function (a) { a = angular.element(a); for (var b = a[0].childNodes.length - 1; b >= 0; b--)
                                            a.after(a[0].childNodes[b]); a.remove(); };
                                        angular.forEach(i.find("span"), function (a) { a.removeAttribute("lang"), a.attributes.length <= 0 && u(a); }), angular.forEach(i.find("font"), u), a = i.html(), d && (a = i.html() || g.html()),
                                            a = a.replace(/\n/g, " ");
                                    }
                                    else {
                                        if (a = a.replace(/<(|\/)meta[^>]*?>/gi, ""), a.match(/<[^>]*?(ta-bind)[^>]*?>/)) {
                                            if (a.match(/<[^>]*?(text-angular)[^>]*?>/)) {
                                                var v = angular.element("<div>" + a + "</div>");
                                                v.find("textarea").remove();
                                                for (var w = 0; w < binds.length; w++) {
                                                    for (var x = binds[w][0].parentNode.parentNode, z = 0; z < binds[w][0].childNodes.length; z++)
                                                        x.parentNode.insertBefore(binds[w][0].childNodes[z], x);
                                                    x.parentNode.removeChild(x);
                                                }
                                                a = v.html().replace('<br class="Apple-interchange-newline">', "");
                                            }
                                        }
                                        else
                                            a.match(/^<span/) && (a.match(/<span class=(\"Apple-converted-space\"|\'Apple-converted-space\')>.<\/span>/gi) || (a = a.replace(/<(|\/)span[^>]*?>/gi, "")));
                                        a = a.replace(/<br class="Apple-interchange-newline"[^>]*?>/gi, "").replace(/<span class="Apple-converted-space">( |&nbsp;)<\/span>/gi, "&nbsp;");
                                    }
                                    /<li(\s.*)?>/i.test(a) && /(<ul(\s.*)?>|<ol(\s.*)?>).*<li(\s.*)?>/i.test(a) === !1 && (a = a.replace(/<li(\s.*)?>.*<\/li(\s.*)?>/i, "<ul>$&</ul>")),
                                        a = a.replace(/^[ |\u00A0]+/gm, function (a) { for (var b = "", c = 0; c < a.length; c++)
                                            b += "&nbsp;"; return b; }).replace(/\n|\r\n|\r/g, "<br />").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;"), y && (a = y(f, { $html: a }) || a),
                                        a = a.replace(/<span style=("|')([^<]*?)vertical-align\s*:\s*super;?([^>]*?)("|')>([^<]+?)<\/span>/g, "<sup style='$2$3'>$5</sup>"), a = b(a, "", I),
                                        h.insertHtml(a, r[0]), c(function () { B.$setViewValue(Z()), fa = !1, r.removeClass("processing-paste"); }, 0);
                                }
                                else
                                    fa = !1, r.removeClass("processing-paste");
                            };
                            r.on("paste", f.events.paste = function (b, e) {
                                if (e && angular.extend(b, e), F || fa)
                                    return b.stopPropagation(), b.preventDefault(), !1;
                                fa = !0, r.addClass("processing-paste");
                                var f, g = (b.originalEvent || b).clipboardData;
                                if (!g && window.clipboardData && window.clipboardData.getData)
                                    return f = window.clipboardData.getData("Text"), ga(f), b.stopPropagation(), b.preventDefault(), !1;
                                if (g && g.getData && g.types.length > 0) {
                                    for (var h = "", i = 0; i < g.types.length; i++)
                                        h += " " + g.types[i];
                                    return /text\/html/i.test(h) ? f = g.getData("text/html") : /text\/plain/i.test(h) && (f = g.getData("text/plain")), ga(f), b.stopPropagation(), b.preventDefault(), !1;
                                }
                                var j = a.saveSelection(), k = angular.element('<div class="ta-hidden-input" contenteditable="true"></div>');
                                d.find("body").append(k), k[0].focus(), c(function () {
                                    a.restoreSelection(j), ga(k[0].innerHTML), r[0].focus(), k.remove();
                                }, 0);
                            }), r.on("cut", f.events.cut = function (a) {
                                F ? a.preventDefault() : c(function () { B.$setViewValue(Z()); }, 0);
                            }), r.on("keydown", f.events.keydown = function (a, b) {
                                b && angular.extend(a, b), a.keyCode === R ? h.setStateShiftKey(!0) : h.setStateShiftKey(!1), a.specialKey = w(a);
                                var c;
                                if (o.keyMappings.forEach(function (b) {
                                    a.specialKey === b.commandKeyCode && (a.specialKey = void 0), b.testForKey(a) && (c = b.commandKeyCode), "UndoKey" !== b.commandKeyCode && "RedoKey" !== b.commandKeyCode || b.enablePropagation || a.preventDefault();
                                }),
                                    "undefined" != typeof c && (a.specialKey = c),
                                    "undefined" == typeof a.specialKey || "UndoKey" === a.specialKey && "RedoKey" === a.specialKey || (a.preventDefault(), s.sendKeyCommand(f, a)), !(F || ("UndoKey" === a.specialKey && (ca(), a.preventDefault()), "RedoKey" === a.specialKey && (da(), a.preventDefault()), a.keyCode !== Q || a.shiftKey || a.ctrlKey || a.metaKey || a.altKey))) {
                                    var d, e = function (a, b) { for (var c = 0; c < a.length; c++)
                                        if (a[c] === b)
                                            return !0; return !1; }, g = h.getSelectionElement();
                                    if (!g.nodeName.match(k))
                                        return;
                                    var i = angular.element(z), j = ["blockquote", "ul", "ol"];
                                    if (e(j, g.parentNode.tagName.toLowerCase())) {
                                        if (/^<br(|\/)>$/i.test(g.innerHTML.trim()) && !g.nextSibling) {
                                            d = angular.element(g);
                                            var l = d.parent();
                                            l.after(i), d.remove(), 0 === l.children().length && l.remove(), h.setSelectionToElementStart(i[0]), a.preventDefault();
                                        }
                                        /^<[^>]+><br(|\/)><\/[^>]+>$/i.test(g.innerHTML.trim()) && (d = angular.element(g), d.after(i), d.remove(), h.setSelectionToElementStart(i[0]), a.preventDefault());
                                    }
                                }
                            });
                            var ha;
                            r.on("keyup", f.events.keyup = function (a, b) {
                                if (b && angular.extend(a, b), h.setStateShiftKey(!1), a.keyCode === S) {
                                    var d = h.getSelection();
                                    return void (d.start.element === r[0] && r.children().length && h.setSelectionToElementStart(r.children()[0]));
                                }
                                if (a.keyCode !== T || a.shiftKey || h.updateLeftArrowKey(r),
                                    a.keyCode !== U || a.shiftKey || h.updateRightArrowKey(r), X && c.cancel(X), !F && !K.test(a.keyCode))
                                    if (a.keyCode === Q && (a.ctrlKey || a.metaKey || a.altKey))
                                        ;
                                    else {
                                        if ("" !== z && "<BR><BR>" !== z && a.keyCode === Q && !a.ctrlKey && !a.metaKey && !a.altKey) {
                                            for (var e = h.getSelectionElement(); !e.nodeName.match(k) && e !== r[0];)
                                                e = e.parentNode;
                                            if (a.shiftKey) {
                                                var f = e.tagName.toLowerCase();
                                                if ((f === u.taDefaultWrap || "li" === f || "pre" === f || "div" === f) && !/.+<br><br>/.test(e.innerHTML.trim())) {
                                                    var g = e.previousSibling;
                                                    g && (g.innerHTML = g.innerHTML + "<br><br>", angular.element(e).remove(), h.setSelectionToElementEnd(g));
                                                }
                                            }
                                            else if (e.tagName.toLowerCase() !== u.taDefaultWrap && "li" !== e.nodeName.toLowerCase() && ("" === e.innerHTML.trim() || "<br>" === e.innerHTML.trim())) {
                                                var i = angular.element(z);
                                                angular.element(e).replaceWith(i), h.setSelectionToElementStart(i[0]);
                                            }
                                        }
                                        var j = Z();
                                        "" === z || "" !== j.trim() && "<br>" !== j.trim() ? "<" !== j.substring(0, 1) && "" !== u.taDefaultWrap : (ba(z), h.setSelectionToElementStart(r.children()[0]));
                                        var l = x !== a.keyCode && L.test(a.keyCode);
                                        ha && c.cancel(ha), ha = c(function () { aa(j, l, !0); }, C.$options.debounce || 400), l || (X = c(function () { B.$undoManager.push(j); }, 250)), x = a.keyCode;
                                    }
                            });
                            var ia;
                            if (r.on("input", function () {
                                Z() !== B.$viewValue && (ia && c.cancel(ia),
                                    ia = c(function () {
                                        var b = a.saveSelection(), c = Z();
                                        c !== B.$viewValue &&
                                            aa(c, !0),
                                            0 !== B.$viewValue.length && a.restoreSelection(b);
                                    }, 1e3));
                            }), r.on("blur", f.events.blur = function () {
                                G = !1,
                                    F ? (H = !0,
                                        B.$render()) : aa(void 0, void 0, !0);
                            }), u.placeholder && (g.ie > 8 || void 0 === g.ie)) {
                                var ja;
                                if (!u.id)
                                    throw "textAngular Error: An unique ID is required for placeholders to work";
                                ja = m("#" + u.id + ".placeholder-text:before", 'content: "' + u.placeholder + '"'), f.$on("$destroy", function () { n(ja); });
                            }
                            r.on("focus", f.events.focus = function () { G = !0, r.removeClass("placeholder-text"), _(); }), r.on("mouseup", f.events.mouseup = function () { var a = h.getSelection(); a && a.start.element === r[0] && r.children().length && h.setSelectionToElementStart(r.children()[0]); }),
                                r.on("mousedown", f.events.mousedown = function (a, b) {
                                    b && angular.extend(a, b), a.stopPropagation();
                                });
                        }
                        else {
                            r.on("change blur", f.events.change = f.events.blur = function () { F || B.$setViewValue(Z()); }), r.on("keydown", f.events.keydown = function (a, b) {
                                if (b && angular.extend(a, b), a.keyCode === S) {
                                    var c = this.selectionStart, d = this.selectionEnd, e = r.val();
                                    if (a.shiftKey) {
                                        var f = e.lastIndexOf("\n", c), g = e.lastIndexOf("\t", c);
                                        g !== -1 && g >= f && (r.val(e.substring(0, g) + e.substring(g + 1)),
                                            this.selectionStart = this.selectionEnd = c - 1);
                                    }
                                    else
                                        r.val(e.substring(0, c) + "\t" + e.substring(d)),
                                            this.selectionStart = this.selectionEnd = c + 1;
                                    a.preventDefault();
                                }
                            });
                            var ka = function (a, b) { for (var c = "", d = 0; d < b; d++)
                                c += a; return c; }, la = function (a, b, c) { for (var d = 0; d < a.length; d++)
                                b.call(c, d, a[d]); }, ma = function (a, b) {
                                var c = "", d = a.childNodes;
                                return b++, c += ka("\t", b - 1) + a.outerHTML.substring(0, 4), la(d, function (a, d) {
                                    var e = d.nodeName.toLowerCase();
                                    return "#comment" === e ? void (c += "<!--" + d.nodeValue + "-->") : "#text" === e ? void (c += d.textContent) : void (d.outerHTML && (c += "ul" === e || "ol" === e ? "\n" + ma(d, b) : "\n" + ka("\t", b) + d.outerHTML));
                                }), c += "\n" + ka("\t", b - 1) + a.outerHTML.substring(a.outerHTML.lastIndexOf("<"));
                            };
                            B.$formatters.unshift(function (a) {
                                var b = angular.element("<div>" + a + "</div>")[0].childNodes;
                                return b.length > 0 && (a = "", la(b, function (b, c) {
                                    var d = c.nodeName.toLowerCase();
                                    return "#comment" === d ? void (a += "<!--" + c.nodeValue + "-->") : "#text" === d ? void (a += c.textContent) : void (c.outerHTML && (a.length > 0 && (a += "\n"), a += "ul" === d || "ol" === d ? "" + ma(c, 0) : "" + c.outerHTML));
                                })), a;
                            });
                        }
                    var na, oa = function (a, b) {
                        if (b && angular.extend(a, b), !t && !F) {
                            t = !0;
                            var d;
                            d = a.originalEvent ? a.originalEvent.dataTransfer : a.dataTransfer, f.$emit("ta-drop-event", this, a, d), c(function () { t = !1, aa(void 0, void 0, !0); }, 100);
                        }
                    }, pa = !1;
                    B.$render = function () {
                        if (!pa) {
                            pa = !0;
                            var a = B.$viewValue || "";
                            H || (D && G && (r.removeClass("placeholder-text"),
                                na && c.cancel(na), na = c(function () {
                                G || (r[0].focus(), h.setSelectionToElementEnd(r.children()[r.children().length - 1])), na = void 0;
                            }, 1)), D ? (ba(u.placeholder ? "" === a ? z : a : "" === a ? z : a),
                                F ? r.off("drop", oa) : (_(), r.on("drop", oa))) : "textarea" !== r[0].tagName.toLowerCase() && "input" !== r[0].tagName.toLowerCase() ?
                                ba(l(a)) :
                                r.val(a)), D && u.placeholder && ("" === a ? G ? r.removeClass("placeholder-text") : r.addClass("placeholder-text") : r.removeClass("placeholder-text")), pa = H = !1;
                        }
                    }, u.taReadonly && (F = f.$eval(u.taReadonly), F ? (r.addClass("ta-readonly"),
                        "textarea" !== r[0].tagName.toLowerCase() && "input" !== r[0].tagName.toLowerCase() || r.attr("disabled", "disabled"), void 0 !== r.attr("contenteditable") && r.attr("contenteditable") && r.removeAttr("contenteditable")) : (r.removeClass("ta-readonly"),
                        "textarea" === r[0].tagName.toLowerCase() || "input" === r[0].tagName.toLowerCase() ? r.removeAttr("disabled") : D && r.attr("contenteditable", "true")),
                        f.$watch(u.taReadonly, function (a, b) {
                            b !== a && (a ? (r.addClass("ta-readonly"),
                                "textarea" !== r[0].tagName.toLowerCase() && "input" !== r[0].tagName.toLowerCase() || r.attr("disabled", "disabled"), void 0 !== r.attr("contenteditable") && r.attr("contenteditable") && r.removeAttr("contenteditable"),
                                angular.forEach(j, function (a) { r.find(a).on("click", $); }), r.off("drop", oa)) : (r.removeClass("ta-readonly"),
                                "textarea" === r[0].tagName.toLowerCase() || "input" === r[0].tagName.toLowerCase() ? r.removeAttr("disabled") : D && r.attr("contenteditable", "true"),
                                angular.forEach(j, function (a) { r.find(a).off("click", $); }), r.on("drop", oa)), F = a);
                        })),
                        D && !F && (angular.forEach(j, function (a) { r.find(a).on("click", $); }), r.on("drop", oa));
                } };
        }]);
    var t = !1, u = angular.module("textAngular", ["ngSanitize", "textAngularSetup", "textAngular.factories", "textAngular.DOM", "textAngular.validators", "textAngular.taBind"]);
    return u.config([function () {
            angular.forEach(e, function (a, b) { delete e[b]; });
        }]), u.directive("textAngular", ["$compile", "$timeout", "taOptions", "taSelection", "taExecCommand", "textAngularManager", "$document", "$animate", "$log", "$q", "$parse", function (b, c, d, e, f, g, h, i, j, k, l) {
            return { require: "?ngModel", scope: {}, restrict: "EA", priority: 2,
                link: function (m, n, o, p) {
                    var q, r, s, t, u, v, w, x, y, z, A, B, C = o.serial ? o.serial : Math.floor(1e16 * Math.random());
                    m._name = o.name ? o.name : "textAngularEditor" + C;
                    var D = function (a, b, d) { c(function () { a.one(b, d); }, 100); };
                    if (y = f(o.taDefaultWrap),
                        angular.extend(m, angular.copy(d), {
                            wrapSelection: function (a, b, c) {
                                "undo" === a.toLowerCase() ? m["$undoTaBindtaTextElement" + C]() : "redo" === a.toLowerCase() ? m["$redoTaBindtaTextElement" + C]() : (y(a, !1, b, m.defaultTagAttributes), c &&
                                    m["reApplyOnSelectorHandlerstaTextElement" + C](),
                                    m.displayElements.text[0].focus());
                            }, showHtml: m.$eval(o.taShowHtml) || !1
                        }),
                        o.taFocussedClass && (m.classes.focussed = o.taFocussedClass), o.taTextEditorClass && (m.classes.textEditor = o.taTextEditorClass), o.taHtmlEditorClass && (m.classes.htmlEditor = o.taHtmlEditorClass), o.taDefaultTagAttributes)
                        try {
                            angular.extend(m.defaultTagAttributes, angular.fromJson(o.taDefaultTagAttributes));
                        }
                        catch (a) {
                            j.error(a);
                        }
                    o.taTextEditorSetup && (m.setup.textEditorSetup = m.$parent.$eval(o.taTextEditorSetup)), o.taHtmlEditorSetup && (m.setup.htmlEditorSetup = m.$parent.$eval(o.taHtmlEditorSetup)),
                        o.taFileDrop ? m.fileDropHandler = m.$parent.$eval(o.taFileDrop) : m.fileDropHandler = m.defaultFileDropHandler, w = n[0].innerHTML,
                        n[0].innerHTML = "",
                        m.displayElements = {
                            forminput: angular.element("<input type='hidden' tabindex='-1' style='display: none;'>"), html: angular.element("<textarea></textarea>"), text: angular.element("<div></div>"),
                            scrollWindow: angular.element("<div class='ta-scroll-window'></div>"), popover: angular.element('<div class="popover fade bottom" style="max-width: none; width: 305px;"></div>'), popoverArrow: angular.element('<div class="arrow"></div>'), popoverContainer: angular.element('<div class="popover-content"></div>'), resize: { overlay: angular.element('<div class="ta-resizer-handle-overlay"></div>'), background: angular.element('<div class="ta-resizer-handle-background"></div>'), anchors: [angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tl"></div>'), angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tr"></div>'), angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-bl"></div>'), angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-br"></div>')], info: angular.element('<div class="ta-resizer-handle-info"></div>') }
                        },
                        m.displayElements.popover.append(m.displayElements.popoverArrow), m.displayElements.popover.append(m.displayElements.popoverContainer), m.displayElements.scrollWindow.append(m.displayElements.popover), m.displayElements.popover.on("mousedown", function (a, b) {
                        return b && angular.extend(a, b), a.preventDefault(), !1;
                    }),
                        m.handlePopoverEvents = function () {
                            "block" === m.displayElements.popover.css("display") && (B && c.cancel(B), B = c(function () {
                                m.reflowPopover(m.resizeElement), m.reflowResizeOverlay(m.resizeElement);
                            }, 100));
                        },
                        angular.element(window).on("resize", m.handlePopoverEvents),
                        angular.element(window).on("scroll", m.handlePopoverEvents);
                    var E = function (a) {
                        var b, c = { vertical: !1, horizontal: !1 };
                        try {
                            if (b = window.getComputedStyle(a), null === b)
                                return c;
                        }
                        catch (a) {
                            return c;
                        }
                        var d = b["overflow-y"], e = b["overflow-x"];
                        return { vertical: ("scroll" === d || "auto" === d) &&
                                a.scrollHeight > a.clientHeight, horizontal: ("scroll" === e || "auto" === e) &&
                                a.scrollWidth > a.clientWidth };
                    };
                    m.getScrollTop = function (a, b) {
                        var c = a.scrollTop;
                        return "undefined" == typeof c && (c = 0), b && E(a).vertical && (a.removeEventListener("scroll", m._scrollListener, !1), a.addEventListener("scroll", m._scrollListener, !1)), 0 !== c ? { node: a.nodeName, top: c } : a.parentNode ? m.getScrollTop(a.parentNode, b) : { node: "<none>", top: 0 };
                    },
                        m.showPopover = function (a) {
                            m.getScrollTop(m.displayElements.scrollWindow[0], !0), m.displayElements.popover.css("display", "block"),
                                c(function () { m.displayElements.resize.overlay.css("display", "block"); }), m.resizeElement = a, m.reflowPopover(a), i.addClass(m.displayElements.popover, "in"), D(h.find("body"), "click keyup", function () { m.hidePopover(); });
                        },
                        m._scrollListener = function (a, b) { m.handlePopoverEvents(); }, m.reflowPopover = function (a) {
                        var b = m.getScrollTop(m.displayElements.scrollWindow[0], !1), c = a[0].offsetTop - b.top;
                        c < 51 ? (m.displayElements.popover.css("top", a[0].offsetTop + a[0].offsetHeight + m.displayElements.scrollWindow[0].scrollTop + "px"), m.displayElements.popover.removeClass("top").addClass("bottom")) : (m.displayElements.popover.css("top", a[0].offsetTop - 54 + m.displayElements.scrollWindow[0].scrollTop + "px"), m.displayElements.popover.removeClass("bottom").addClass("top"));
                        var d = m.displayElements.text[0].offsetWidth - m.displayElements.popover[0].offsetWidth, e = a[0].offsetLeft + a[0].offsetWidth / 2 - m.displayElements.popover[0].offsetWidth / 2, f = Math.max(0, Math.min(d, e)), g = Math.min(e, Math.max(0, e - d)) - 11;
                        f += window.scrollX, g -= window.scrollX, m.displayElements.popover.css("left", f + "px"), m.displayElements.popoverArrow.css("margin-left", g + "px");
                    }, m.hidePopover = function () { m.displayElements.popover.css("display", "none"), m.displayElements.popoverContainer.attr("style", ""), m.displayElements.popoverContainer.attr("class", "popover-content"), m.displayElements.popover.removeClass("in"), m.displayElements.resize.overlay.css("display", "none"); },
                        m.displayElements.resize.overlay.append(m.displayElements.resize.background), angular.forEach(m.displayElements.resize.anchors, function (a) { m.displayElements.resize.overlay.append(a); }), m.displayElements.resize.overlay.append(m.displayElements.resize.info), m.displayElements.scrollWindow.append(m.displayElements.resize.overlay),
                        m.displayElements.resize.background.on("click", function (a) { m.displayElements.text[0].focus(); }),
                        m.reflowResizeOverlay = function (a) { a = angular.element(a)[0], m.displayElements.resize.overlay.css({ display: "block", left: a.offsetLeft - 5 + "px", top: a.offsetTop - 5 + "px", width: a.offsetWidth + 10 + "px", height: a.offsetHeight + 10 + "px" }), m.displayElements.resize.info.text(a.offsetWidth + " x " + a.offsetHeight); },
                        m.showResizeOverlay = function (a) {
                            var b = h.find("body");
                            z = function (c) {
                                var d = { width: parseInt(a.attr("width")), height: parseInt(a.attr("height")), x: c.clientX, y: c.clientY };
                                (void 0 === d.width || isNaN(d.width)) && (d.width = a[0].offsetWidth), (void 0 === d.height || isNaN(d.height)) && (d.height = a[0].offsetHeight), m.hidePopover();
                                var e = d.height / d.width, f = function (b) {
                                    function c(a) { return Math.round(Math.max(0, a)); }
                                    var f = { x: Math.max(0, d.width + (b.clientX - d.x)), y: Math.max(0, d.height + (b.clientY - d.y)) }, g = void 0 !== o.taResizeForceAspectRatio, h = o.taResizeMaintainAspectRatio, i = g || h && !b.shiftKey;
                                    if (i) {
                                        var j = f.y / f.x;
                                        f.x = e > j ? f.x : f.y / e, f.y = e > j ? f.x * e : f.y;
                                    }
                                    var k = angular.element(a);
                                    k.css("height", c(f.y) + "px"), k.css("width", c(f.x) + "px"),
                                        m.reflowResizeOverlay(a);
                                };
                                b.on("mousemove", f), D(b, "mouseup", function (a) {
                                    a.preventDefault(), a.stopPropagation(), b.off("mousemove", f),
                                        m.$apply(function () { m.hidePopover(), m.updateTaBindtaTextElement(); }, 100);
                                }), c.stopPropagation(), c.preventDefault();
                            }, m.displayElements.resize.anchors[3].off("mousedown"), m.displayElements.resize.anchors[3].on("mousedown", z), m.reflowResizeOverlay(a), D(b, "click", function () { m.hideResizeOverlay(); });
                        },
                        m.hideResizeOverlay = function () { m.displayElements.resize.anchors[3].off("mousedown", z), m.displayElements.resize.overlay.css("display", "none"); },
                        m.setup.htmlEditorSetup(m.displayElements.html), m.setup.textEditorSetup(m.displayElements.text), m.displayElements.html.attr({ id: "taHtmlElement" + C, "ng-show": "showHtml", "ta-bind": "ta-bind", "ng-model": "html", "ng-model-options": n.attr("ng-model-options") }), m.displayElements.text.attr({ id: "taTextElement" + C, contentEditable: "true", "ta-bind": "ta-bind", "ng-model": "html", "ng-model-options": n.attr("ng-model-options") }), m.displayElements.scrollWindow.attr({ "ng-hide": "showHtml" }), o.taDefaultWrap &&
                        m.displayElements.text.attr("ta-default-wrap", o.taDefaultWrap), o.taUnsafeSanitizer && (m.displayElements.text.attr("ta-unsafe-sanitizer", o.taUnsafeSanitizer), m.displayElements.html.attr("ta-unsafe-sanitizer", o.taUnsafeSanitizer)), o.taKeepStyles && (m.displayElements.text.attr("ta-keep-styles", o.taKeepStyles), m.displayElements.html.attr("ta-keep-styles", o.taKeepStyles)),
                        m.displayElements.scrollWindow.append(m.displayElements.text), n.append(m.displayElements.scrollWindow), n.append(m.displayElements.html), m.displayElements.forminput.attr("name", m._name), n.append(m.displayElements.forminput), o.tabindex && (n.removeAttr("tabindex"), m.displayElements.text.attr("tabindex", o.tabindex), m.displayElements.html.attr("tabindex", o.tabindex)), o.placeholder && (m.displayElements.text.attr("placeholder", o.placeholder), m.displayElements.html.attr("placeholder", o.placeholder)), o.taDisabled && (m.displayElements.text.attr("ta-readonly", "disabled"), m.displayElements.html.attr("ta-readonly", "disabled"), m.disabled = m.$parent.$eval(o.taDisabled), m.$parent.$watch(o.taDisabled, function (a) { m.disabled = a, m.disabled ? n.addClass(m.classes.disabled) : n.removeClass(m.classes.disabled); })), o.taPaste && (m._pasteHandler = function (a) { return l(o.taPaste)(m.$parent, { $html: a }); }, m.displayElements.text.attr("ta-paste", "_pasteHandler($html)")),
                        b(m.displayElements.scrollWindow)(m), b(m.displayElements.html)(m), m.updateTaBindtaTextElement = m["updateTaBindtaTextElement" + C], m.updateTaBindtaHtmlElement = m["updateTaBindtaHtmlElement" + C],
                        n.addClass("ta-root"), m.displayElements.scrollWindow.addClass("ta-text ta-editor " + m.classes.textEditor), m.displayElements.html.addClass("ta-html ta-editor " + m.classes.htmlEditor);
                    var F = function (a, b) {
                        b !== h[0].queryCommandState(a) && h[0].execCommand(a, !1, null);
                    };
                    m._actionRunning = !1;
                    var G = !1;
                    if (m.startAction = function () {
                        var b = !1, c = !1, d = !1, e = !1;
                        return m._actionRunning = !0, b = h[0].queryCommandState("bold"), c = h[0].queryCommandState("italic"), d = h[0].queryCommandState("underline"), e = h[0].queryCommandState("strikeThrough"), G = a.saveSelection(), F("bold", b), F("italic", c), F("underline", d), F("strikeThrough", e), function () { G && a.restoreSelection(G); };
                    }, m.endAction = function () {
                        m._actionRunning = !1, G && (m.showHtml ? m.displayElements.html[0].focus() : m.displayElements.text[0].focus(),
                            a.removeMarkers(G)), G = !1, m.updateSelectedStyles(),
                            m.showHtml || m["updateTaBindtaTextElement" + C]();
                    },
                        u = function (a) {
                            m.focussed = !0, n.addClass(m.classes.focussed),
                                x.focus(), n.triggerHandler("focus"),
                                m.updateSelectedStyles && !m._bUpdateSelectedStyles &&
                                    c(function () { m.updateSelectedStyles(); }, 0);
                        }, m.displayElements.html.on("focus", u), m.displayElements.text.on("focus", u), v = function (a) {
                        return m._actionRunning || h[0].activeElement === m.displayElements.html[0] || h[0].activeElement === m.displayElements.text[0] || (n.removeClass(m.classes.focussed), x.unfocus(), c(function () { m._bUpdateSelectedStyles = !1, n.triggerHandler("blur"), m.focussed = !1; }, 0)), a.preventDefault(), !1;
                    }, m.displayElements.html.on("blur", v), m.displayElements.text.on("blur", v), m.displayElements.text.on("paste", function (a) { n.triggerHandler("paste", a); }),
                        m.queryFormatBlockState = function (a) {
                            return !m.showHtml && a.toLowerCase() === h[0].queryCommandValue("formatBlock").toLowerCase();
                        }, m.queryCommandState = function (a) {
                        return m.showHtml ? "" : h[0].queryCommandState(a);
                    }, m.switchView = function () {
                        m.showHtml = !m.showHtml, i.enabled(!1, m.displayElements.html), i.enabled(!1, m.displayElements.text),
                            m.showHtml ?
                                c(function () {
                                    return i.enabled(!0, m.displayElements.html), i.enabled(!0, m.displayElements.text), m.displayElements.html[0].focus();
                                }, 100) :
                                c(function () {
                                    return i.enabled(!0, m.displayElements.html), i.enabled(!0, m.displayElements.text), m.displayElements.text[0].focus();
                                }, 100);
                    }, o.ngModel) {
                        var H = !0;
                        p.$render = function () {
                            if (H) {
                                H = !1;
                                var a = m.$parent.$eval(o.ngModel);
                                void 0 !== a && null !== a || !w || "" === w ||
                                    p.$setViewValue(w);
                            }
                            m.displayElements.forminput.val(p.$viewValue),
                                m.html = p.$viewValue || "";
                        },
                            n.attr("required") && (p.$validators.required = function (a, b) { var c = a || b; return !(!c || "" === c.trim()); });
                    }
                    else
                        m.displayElements.forminput.val(w), m.html = w;
                    if (m.$watch("html", function (a, b) { a !== b && (o.ngModel && p.$viewValue !== a && p.$setViewValue(a), m.displayElements.forminput.val(a)); }), o.taTargetToolbars)
                        x = g.registerEditor(m._name, m, o.taTargetToolbars.split(","));
                    else {
                        var I = angular.element('<div text-angular-toolbar name="textAngularToolbar' + C + '">');
                        o.taToolbar && I.attr("ta-toolbar", o.taToolbar), o.taToolbarClass && I.attr("ta-toolbar-class", o.taToolbarClass), o.taToolbarGroupClass && I.attr("ta-toolbar-group-class", o.taToolbarGroupClass), o.taToolbarButtonClass && I.attr("ta-toolbar-button-class", o.taToolbarButtonClass), o.taToolbarActiveButtonClass && I.attr("ta-toolbar-active-button-class", o.taToolbarActiveButtonClass), o.taFocussedClass && I.attr("ta-focussed-class", o.taFocussedClass), n.prepend(I), b(I)(m.$parent), x = g.registerEditor(m._name, m, ["textAngularToolbar" + C]);
                    }
                    m.$on("$destroy", function () { g.unregisterEditor(m._name), angular.element(window).off("blur"), angular.element(window).off("resize", m.handlePopoverEvents), angular.element(window).off("scroll", m.handlePopoverEvents); }),
                        m.$on("ta-element-select", function (a, b) { x.triggerElementSelect(a, b) && m["reApplyOnSelectorHandlerstaTextElement" + C](); }),
                        m.$on("ta-drop-event", function (a, b, d, f) {
                            f && f.files && f.files.length > 0 ? (m.displayElements.text[0].focus(),
                                e.setSelectionToElementEnd(d.target), angular.forEach(f.files, function (a) {
                                try {
                                    k.when(m.fileDropHandler(a, m.wrapSelection) || m.fileDropHandler !== m.defaultFileDropHandler && k.when(m.defaultFileDropHandler(a, m.wrapSelection))).then(function () { m["updateTaBindtaTextElement" + C](); });
                                }
                                catch (a) {
                                    j.error(a);
                                }
                            }), d.preventDefault(), d.stopPropagation()) : c(function () { m["updateTaBindtaTextElement" + C](); }, 0);
                        }),
                        m._bUpdateSelectedStyles = !1,
                        angular.element(window).on("blur", function () { m._bUpdateSelectedStyles = !1, m.focussed = !1; }),
                        m.updateSelectedStyles = function () {
                            var a;
                            A && c.cancel(A),
                                void 0 !== (a = e.getSelectionElement()) && a.parentNode !== m.displayElements.text[0] ? x.updateSelectedStyles(angular.element(a)) : x.updateSelectedStyles(),
                                m._bUpdateSelectedStyles && (A = c(m.updateSelectedStyles, 200));
                        },
                        q = function () {
                            return m.focussed ? void (m._bUpdateSelectedStyles || (m._bUpdateSelectedStyles = !0, m.$apply(function () { m.updateSelectedStyles(); }))) : void (m._bUpdateSelectedStyles = !1);
                        }, m.displayElements.html.on("keydown", q), m.displayElements.text.on("keydown", q),
                        r = function () { m._bUpdateSelectedStyles = !1; }, m.displayElements.html.on("keyup", r), m.displayElements.text.on("keyup", r),
                        s = function (a, b) {
                            if (e.getSelection) {
                                var c = e.getSelection();
                                e.getSelectionElement() && "a" === e.getSelectionElement().nodeName.toLowerCase() && (3 === c.start.element.nodeType && c.start.element.textContent.length === c.end.offset &&
                                    e.setSelectionAfterElement(e.getSelectionElement()), 3 === c.start.element.nodeType && 0 === c.start.offset &&
                                    e.setSelectionBeforeElement(e.getSelectionElement()));
                            }
                            b && angular.extend(a, b), m.$apply(function () {
                                if (x.sendKeyCommand(a))
                                    return m._bUpdateSelectedStyles || m.updateSelectedStyles(), a.preventDefault(), !1;
                            });
                        }, m.displayElements.html.on("keypress", s), m.displayElements.text.on("keypress", s),
                        t = function () {
                            m._bUpdateSelectedStyles = !1,
                                c(function () { m.updateSelectedStyles(); }, 0);
                        }, m.displayElements.html.on("mouseup", t), m.displayElements.text.on("mouseup", t);
                } };
        }]), u.service("textAngularManager", ["taToolExecuteAction", "taTools", "taRegisterTool", "$interval", "$rootScope", "$log", function (a, b, c, d, e, g) {
            var h, i = {}, j = {}, k = 0, l = function (a) { angular.forEach(j, function (b) { b.editorFunctions.updateSelectedStyles(a); }); }, m = 50, n = function () {
                k = Date.now(),
                    h = d(function () { l(), h = void 0; }, m, 1);
            };
            e.$on("destroy", function () { h && (d.cancel(h), h = void 0); });
            var o = function () {
                Math.abs(Date.now() - k) > m &&
                    n();
            };
            return {
                registerEditor: function (c, d, e) {
                    if (!c || "" === c)
                        throw "textAngular Error: An editor requires a name";
                    if (!d)
                        throw "textAngular Error: An editor requires a scope";
                    if (j[c])
                        throw 'textAngular Error: An Editor with name "' + c + '" already exists';
                    return j[c] = { scope: d, toolbars: e,
                        toolbarScopes: [], _registerToolbarScope: function (a) {
                            this.toolbars.indexOf(a.name) >= 0 &&
                                this.toolbarScopes.push(a);
                        },
                        editorFunctions: { disable: function () {
                                angular.forEach(j[c].toolbarScopes, function (a) { a.disabled = !0; });
                            }, enable: function () {
                                angular.forEach(j[c].toolbarScopes, function (a) { a.disabled = !1; });
                            }, focus: function () {
                                angular.forEach(j[c].toolbarScopes, function (a) { a._parent = d, a.disabled = !1, a.focussed = !0; }), d.focussed = !0;
                            }, unfocus: function () {
                                angular.forEach(j[c].toolbarScopes, function (a) { a.disabled = !0, a.focussed = !1; }), d.focussed = !1;
                            }, updateSelectedStyles: function (a) {
                                angular.forEach(j[c].toolbarScopes, function (b) {
                                    angular.forEach(b.tools, function (c) {
                                        c.activeState && (b._parent = d,
                                            c.active = c.activeState(a));
                                    });
                                });
                            }, sendKeyCommand: function (e) {
                                var f = !1;
                                return (e.ctrlKey || e.metaKey || e.specialKey) && angular.forEach(b, function (b, g) { if (b.commandKeyCode && (b.commandKeyCode === e.which || b.commandKeyCode === e.specialKey))
                                    for (var h = 0; h < j[c].toolbarScopes.length; h++)
                                        if (void 0 !== j[c].toolbarScopes[h].tools[g]) {
                                            a.call(j[c].toolbarScopes[h].tools[g], d), f = !0;
                                            break;
                                        } }), f;
                            }, triggerElementSelect: function (a, e) {
                                var f = function (a, b) { for (var c = !0, d = 0; d < b.length; d++)
                                    c = c && a.attr(b[d]); return c; }, g = [], h = {}, i = !1;
                                e = angular.element(e);
                                var k = !1;
                                if (angular.forEach(b, function (a, b) {
                                    a.onElementSelect && a.onElementSelect.element && a.onElementSelect.element.toLowerCase() === e[0].tagName.toLowerCase() && (!a.onElementSelect.filter || a.onElementSelect.filter(e)) && (k = k || angular.isArray(a.onElementSelect.onlyWithAttrs) && f(e, a.onElementSelect.onlyWithAttrs), a.onElementSelect.onlyWithAttrs && !f(e, a.onElementSelect.onlyWithAttrs) || (h[b] = a));
                                }),
                                    k ? (angular.forEach(h, function (a, b) { a.onElementSelect.onlyWithAttrs && f(e, a.onElementSelect.onlyWithAttrs) && g.push({ name: b, tool: a }); }),
                                        g.sort(function (a, b) { return b.tool.onElementSelect.onlyWithAttrs.length - a.tool.onElementSelect.onlyWithAttrs.length; })) : angular.forEach(h, function (a, b) { g.push({ name: b, tool: a }); }), g.length > 0)
                                    for (var l = 0; l < g.length; l++) {
                                        for (var m = g[l].tool, n = g[l].name, o = 0; o < j[c].toolbarScopes.length; o++)
                                            if (void 0 !== j[c].toolbarScopes[o].tools[n]) {
                                                m.onElementSelect.action.call(j[c].toolbarScopes[o].tools[n], a, e, d), i = !0;
                                                break;
                                            }
                                        if (i)
                                            break;
                                    }
                                return i;
                            } } }, angular.forEach(e, function (a) { i[a] && j[c].toolbarScopes.push(i[a]); }), o(), j[c].editorFunctions;
                },
                retrieveEditor: function (a) { return j[a]; }, unregisterEditor: function (a) { delete j[a], o(); },
                registerToolbar: function (a) {
                    if (!a)
                        throw "textAngular Error: A toolbar requires a scope";
                    if (!a.name || "" === a.name)
                        throw "textAngular Error: A toolbar requires a name";
                    if (i[a.name])
                        throw 'textAngular Error: A toolbar with name "' + a.name + '" already exists';
                    i[a.name] = a,
                        angular.forEach(j, function (b) { b._registerToolbarScope(a); }), o();
                },
                retrieveToolbar: function (a) { return i[a]; },
                retrieveToolbarsViaEditor: function (a) { var b = [], c = this; return angular.forEach(this.retrieveEditor(a).toolbars, function (a) { b.push(c.retrieveToolbar(a)); }), b; }, unregisterToolbar: function (a) { delete i[a], o(); },
                updateToolsDisplay: function (a) {
                    var b = this;
                    angular.forEach(a, function (a, c) { b.updateToolDisplay(c, a); });
                },
                resetToolsDisplay: function () { var a = this; angular.forEach(b, function (b, c) { a.resetToolDisplay(c); }), o(); },
                updateToolDisplay: function (a, b) { var c = this; angular.forEach(i, function (d, e) { c.updateToolbarToolDisplay(e, a, b); }), o(); },
                resetToolDisplay: function (a) { var b = this; angular.forEach(i, function (c, d) { b.resetToolbarToolDisplay(d, a); }), o(); },
                updateToolbarToolDisplay: function (a, b, c) { if (!i[a])
                    throw 'textAngular Error: No Toolbar with name "' + a + '" exists'; i[a].updateToolDisplay(b, c); },
                resetToolbarToolDisplay: function (a, c) { if (!i[a])
                    throw 'textAngular Error: No Toolbar with name "' + a + '" exists'; i[a].updateToolDisplay(c, b[c], !0); },
                removeTool: function (a) { delete b[a], angular.forEach(i, function (b) { delete b.tools[a]; for (var c = 0; c < b.toolbar.length; c++) {
                    for (var d, e = 0; e < b.toolbar[c].length; e++) {
                        if (b.toolbar[c][e] === a) {
                            d = { group: c, index: e };
                            break;
                        }
                        if (void 0 !== d)
                            break;
                    }
                    void 0 !== d && (b.toolbar[d.group].slice(d.index, 1), b._$element.children().eq(d.group).children().eq(d.index).remove());
                } }), o(); },
                addTool: function (a, b, d, e) { c(a, b), angular.forEach(i, function (c) { c.addTool(a, b, d, e); }), o(); },
                addToolToToolbar: function (a, b, d, e, f) { c(a, b), i[d].addTool(a, b, e, f), o(); },
                refreshEditor: function (a) {
                    if (!j[a])
                        throw 'textAngular Error: No Editor with name "' + a + '" exists';
                    j[a].scope.updateTaBindtaTextElement(),
                        j[a].scope.$$phase || j[a].scope.$digest(), o();
                },
                sendKeyCommand: function (a, b) {
                    var c = j[a._name];
                    if (c && c.editorFunctions.sendKeyCommand(b))
                        return a._bUpdateSelectedStyles || a.updateSelectedStyles(), b.preventDefault(), !1;
                },
                updateStyles: l,
                getVersion: function () { return f; },
                getToolbarScopes: function () { var a = []; return angular.forEach(j, function (b) { a = a.concat(b.toolbarScopes); }), a; }
            };
        }]), u.directive("textAngularToolbar", ["$compile", "textAngularManager", "taOptions", "taTools", "taToolExecuteAction", "$window", function (a, b, c, d, e, f) {
            return { scope: { name: "@" }, restrict: "EA", link: function (g, h, i) {
                    if (!g.name || "" === g.name)
                        throw "textAngular Error: A toolbar requires a name";
                    angular.extend(g, angular.copy(c)), i.taToolbar && (g.toolbar = g.$parent.$eval(i.taToolbar)), i.taToolbarClass && (g.classes.toolbar = i.taToolbarClass), i.taToolbarGroupClass && (g.classes.toolbarGroup = i.taToolbarGroupClass), i.taToolbarButtonClass && (g.classes.toolbarButton = i.taToolbarButtonClass), i.taToolbarActiveButtonClass && (g.classes.toolbarButtonActive = i.taToolbarActiveButtonClass), i.taFocussedClass && (g.classes.focussed = i.taFocussedClass), g.disabled = !0, g.focussed = !1, g._$element = h, h[0].innerHTML = "", h.addClass("ta-toolbar " + g.classes.toolbar), g.$watch("focussed", function () { g.focussed ? h.addClass(g.classes.focussed) : h.removeClass(g.classes.focussed); });
                    var j = function (b, c) {
                        var d;
                        if (d = b && b.display ? angular.element(b.display) : angular.element("<button type='button'>"), b && b.class ? d.addClass(b.class) : d.addClass(g.classes.toolbarButton), d.attr("name", c.name),
                            d.attr("ta-button", "ta-button"), d.attr("ng-disabled", "isDisabled()"), d.attr("tabindex", "-1"), d.attr("ng-click", "executeAction()"), d.attr("ng-class", "displayActiveToolClass(active)"), b && b.tooltiptext && d.attr("title", b.tooltiptext), b && !b.display && !c._display && (d[0].innerHTML = "",
                            b.buttontext && (d[0].innerHTML = b.buttontext), b.iconclass)) {
                            var e = angular.element("<i>"), f = d[0].innerHTML;
                            e.addClass(b.iconclass), d[0].innerHTML = "", d.append(e), f && "" !== f && d.append("&nbsp;" + f);
                        }
                        return c._lastToolDefinition = angular.copy(b), a(d)(c);
                    };
                    g.tools = {},
                        g._parent = { disabled: !0, showHtml: !1, queryFormatBlockState: function () { return !1; }, queryCommandState: function () { return !1; } };
                    var k = { $window: f, $editor: function () {
                            return g._parent;
                        }, isDisabled: function () {
                            return ("html" !== this.name || !g._parent.startAction) && ("function" != typeof this.$eval("disabled") && this.$eval("disabled") || this.$eval("disabled()") || "html" !== this.name && this.$editor().showHtml || this.$parent.disabled || this.$editor().disabled);
                        }, displayActiveToolClass: function (a) { return a ? g.classes.toolbarButtonActive : ""; }, executeAction: e };
                    angular.forEach(g.toolbar, function (a) {
                        var b = angular.element("<div>");
                        b.addClass(g.classes.toolbarGroup), angular.forEach(a, function (a) {
                            g.tools[a] = angular.extend(g.$new(!0), d[a], k, { name: a }), g.tools[a].$element = j(d[a], g.tools[a]),
                                b.append(g.tools[a].$element);
                        }),
                            h.append(b);
                    }),
                        g.updateToolDisplay = function (a, b, c) {
                            var d = g.tools[a];
                            if (d) {
                                if (d._lastToolDefinition && !c && (b = angular.extend({}, d._lastToolDefinition, b)), null === b.buttontext && null === b.iconclass && null === b.display)
                                    throw 'textAngular Error: Tool Definition for updating "' + a + '" does not have a valid display/iconclass/buttontext value';
                                null === b.buttontext && delete b.buttontext, null === b.iconclass && delete b.iconclass, null === b.display && delete b.display;
                                var e = j(b, d);
                                d.$element.replaceWith(e), d.$element = e;
                            }
                        },
                        g.addTool = function (a, b, c, e) { g.tools[a] = angular.extend(g.$new(!0), d[a], k, { name: a }), g.tools[a].$element = j(d[a], g.tools[a]); var f; void 0 === c && (c = g.toolbar.length - 1), f = angular.element(h.children()[c]), void 0 === e ? (f.append(g.tools[a].$element), g.toolbar[c][g.toolbar[c].length - 1] = a) : (f.children().eq(e).after(g.tools[a].$element), g.toolbar[c][e] = a); }, b.registerToolbar(g), g.$on("$destroy", function () { b.unregisterToolbar(g.name); });
                } };
        }]), u.directive("textAngularVersion", ["textAngularManager", function (a) { var b = a.getVersion(); return { restrict: "EA", link: function (a, c, d) { c.html(b); } }; }]), u.name;
});
!function () { var n = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global || this || {}, r = n._, e = Array.prototype, o = Object.prototype, s = "undefined" != typeof Symbol ? Symbol.prototype : null, u = e.push, c = e.slice, p = o.toString, i = o.hasOwnProperty, t = Array.isArray, a = Object.keys, l = Object.create, f = function () { }, h = function (n) { return n instanceof h ? n : this instanceof h ? void (this._wrapped = n) : new h(n); }; "undefined" == typeof exports || exports.nodeType ? n._ = h : ("undefined" != typeof module && !module.nodeType && module.exports && (exports = module.exports = h), exports._ = h), h.VERSION = "1.9.0"; var v, y = function (u, i, n) { if (void 0 === i)
    return u; switch (null == n ? 3 : n) {
    case 1: return function (n) { return u.call(i, n); };
    case 3: return function (n, r, t) { return u.call(i, n, r, t); };
    case 4: return function (n, r, t, e) { return u.call(i, n, r, t, e); };
} return function () { return u.apply(i, arguments); }; }, d = function (n, r, t) { return h.iteratee !== v ? h.iteratee(n, r) : null == n ? h.identity : h.isFunction(n) ? y(n, r, t) : h.isObject(n) && !h.isArray(n) ? h.matcher(n) : h.property(n); }; h.iteratee = v = function (n, r) { return d(n, r, 1 / 0); }; var g = function (u, i) { return i = null == i ? u.length - 1 : +i, function () { for (var n = Math.max(arguments.length - i, 0), r = Array(n), t = 0; t < n; t++)
    r[t] = arguments[t + i]; switch (i) {
    case 0: return u.call(this, r);
    case 1: return u.call(this, arguments[0], r);
    case 2: return u.call(this, arguments[0], arguments[1], r);
} var e = Array(i + 1); for (t = 0; t < i; t++)
    e[t] = arguments[t]; return e[i] = r, u.apply(this, e); }; }, m = function (n) { if (!h.isObject(n))
    return {}; if (l)
    return l(n); f.prototype = n; var r = new f; return f.prototype = null, r; }, b = function (r) { return function (n) { return null == n ? void 0 : n[r]; }; }, j = function (n, r) { for (var t = r.length, e = 0; e < t; e++) {
    if (null == n)
        return;
    n = n[r[e]];
} return t ? n : void 0; }, x = Math.pow(2, 53) - 1, _ = b("length"), A = function (n) { var r = _(n); return "number" == typeof r && 0 <= r && r <= x; }; h.each = h.forEach = function (n, r, t) { var e, u; if (r = y(r, t), A(n))
    for (e = 0, u = n.length; e < u; e++)
        r(n[e], e, n);
else {
    var i = h.keys(n);
    for (e = 0, u = i.length; e < u; e++)
        r(n[i[e]], i[e], n);
} return n; }, h.map = h.collect = function (n, r, t) { r = d(r, t); for (var e = !A(n) && h.keys(n), u = (e || n).length, i = Array(u), o = 0; o < u; o++) {
    var a = e ? e[o] : o;
    i[o] = r(n[a], a, n);
} return i; }; var w = function (c) { return function (n, r, t, e) { var u = 3 <= arguments.length; return function (n, r, t, e) { var u = !A(n) && h.keys(n), i = (u || n).length, o = 0 < c ? 0 : i - 1; for (e || (t = n[u ? u[o] : o], o += c); 0 <= o && o < i; o += c) {
    var a = u ? u[o] : o;
    t = r(t, n[a], a, n);
} return t; }(n, y(r, e, 4), t, u); }; }; h.reduce = h.foldl = h.inject = w(1), h.reduceRight = h.foldr = w(-1), h.find = h.detect = function (n, r, t) { var e = (A(n) ? h.findIndex : h.findKey)(n, r, t); if (void 0 !== e && -1 !== e)
    return n[e]; }, h.filter = h.select = function (n, e, r) { var u = []; return e = d(e, r), h.each(n, function (n, r, t) { e(n, r, t) && u.push(n); }), u; }, h.reject = function (n, r, t) { return h.filter(n, h.negate(d(r)), t); }, h.every = h.all = function (n, r, t) { r = d(r, t); for (var e = !A(n) && h.keys(n), u = (e || n).length, i = 0; i < u; i++) {
    var o = e ? e[i] : i;
    if (!r(n[o], o, n))
        return !1;
} return !0; }, h.some = h.any = function (n, r, t) { r = d(r, t); for (var e = !A(n) && h.keys(n), u = (e || n).length, i = 0; i < u; i++) {
    var o = e ? e[i] : i;
    if (r(n[o], o, n))
        return !0;
} return !1; }, h.contains = h.includes = h.include = function (n, r, t, e) { return A(n) || (n = h.values(n)), ("number" != typeof t || e) && (t = 0), 0 <= h.indexOf(n, r, t); }, h.invoke = g(function (n, t, e) { var u, i; return h.isFunction(t) ? i = t : h.isArray(t) && (u = t.slice(0, -1), t = t[t.length - 1]), h.map(n, function (n) { var r = i; if (!r) {
    if (u && u.length && (n = j(n, u)), null == n)
        return;
    r = n[t];
} return null == r ? r : r.apply(n, e); }); }), h.pluck = function (n, r) { return h.map(n, h.property(r)); }, h.where = function (n, r) { return h.filter(n, h.matcher(r)); }, h.findWhere = function (n, r) { return h.find(n, h.matcher(r)); }, h.max = function (n, e, r) { var t, u, i = -1 / 0, o = -1 / 0; if (null == e || "number" == typeof e && "object" != typeof n[0] && null != n)
    for (var a = 0, c = (n = A(n) ? n : h.values(n)).length; a < c; a++)
        null != (t = n[a]) && i < t && (i = t);
else
    e = d(e, r), h.each(n, function (n, r, t) { u = e(n, r, t), (o < u || u === -1 / 0 && i === -1 / 0) && (i = n, o = u); }); return i; }, h.min = function (n, e, r) { var t, u, i = 1 / 0, o = 1 / 0; if (null == e || "number" == typeof e && "object" != typeof n[0] && null != n)
    for (var a = 0, c = (n = A(n) ? n : h.values(n)).length; a < c; a++)
        null != (t = n[a]) && t < i && (i = t);
else
    e = d(e, r), h.each(n, function (n, r, t) { ((u = e(n, r, t)) < o || u === 1 / 0 && i === 1 / 0) && (i = n, o = u); }); return i; }, h.shuffle = function (n) { return h.sample(n, 1 / 0); }, h.sample = function (n, r, t) { if (null == r || t)
    return A(n) || (n = h.values(n)), n[h.random(n.length - 1)]; var e = A(n) ? h.clone(n) : h.values(n), u = _(e); r = Math.max(Math.min(r, u), 0); for (var i = u - 1, o = 0; o < r; o++) {
    var a = h.random(o, i), c = e[o];
    e[o] = e[a], e[a] = c;
} return e.slice(0, r); }, h.sortBy = function (n, e, r) { var u = 0; return e = d(e, r), h.pluck(h.map(n, function (n, r, t) { return { value: n, index: u++, criteria: e(n, r, t) }; }).sort(function (n, r) { var t = n.criteria, e = r.criteria; if (t !== e) {
    if (e < t || void 0 === t)
        return 1;
    if (t < e || void 0 === e)
        return -1;
} return n.index - r.index; }), "value"); }; var O = function (o, r) { return function (e, u, n) { var i = r ? [[], []] : {}; return u = d(u, n), h.each(e, function (n, r) { var t = u(n, r, e); o(i, n, t); }), i; }; }; h.groupBy = O(function (n, r, t) { h.has(n, t) ? n[t].push(r) : n[t] = [r]; }), h.indexBy = O(function (n, r, t) { n[t] = r; }), h.countBy = O(function (n, r, t) { h.has(n, t) ? n[t]++ : n[t] = 1; }); var k = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g; h.toArray = function (n) { return n ? h.isArray(n) ? c.call(n) : h.isString(n) ? n.match(k) : A(n) ? h.map(n, h.identity) : h.values(n) : []; }, h.size = function (n) { return null == n ? 0 : A(n) ? n.length : h.keys(n).length; }, h.partition = O(function (n, r, t) { n[t ? 0 : 1].push(r); }, !0), h.first = h.head = h.take = function (n, r, t) { if (!(null == n || n.length < 1))
    return null == r || t ? n[0] : h.initial(n, n.length - r); }, h.initial = function (n, r, t) { return c.call(n, 0, Math.max(0, n.length - (null == r || t ? 1 : r))); }, h.last = function (n, r, t) { if (!(null == n || n.length < 1))
    return null == r || t ? n[n.length - 1] : h.rest(n, Math.max(0, n.length - r)); }, h.rest = h.tail = h.drop = function (n, r, t) { return c.call(n, null == r || t ? 1 : r); }, h.compact = function (n) { return h.filter(n, Boolean); }; var S = function (n, r, t, e) { for (var u = (e = e || []).length, i = 0, o = _(n); i < o; i++) {
    var a = n[i];
    if (A(a) && (h.isArray(a) || h.isArguments(a)))
        if (r)
            for (var c = 0, l = a.length; c < l;)
                e[u++] = a[c++];
        else
            S(a, r, t, e), u = e.length;
    else
        t || (e[u++] = a);
} return e; }; h.flatten = function (n, r) { return S(n, r, !1); }, h.without = g(function (n, r) { return h.difference(n, r); }), h.uniq = h.unique = function (n, r, t, e) { h.isBoolean(r) || (e = t, t = r, r = !1), null != t && (t = d(t, e)); for (var u = [], i = [], o = 0, a = _(n); o < a; o++) {
    var c = n[o], l = t ? t(c, o, n) : c;
    r && !t ? (o && i === l || u.push(c), i = l) : t ? h.contains(i, l) || (i.push(l), u.push(c)) : h.contains(u, c) || u.push(c);
} return u; }, h.union = g(function (n) { return h.uniq(S(n, !0, !0)); }), h.intersection = function (n) { for (var r = [], t = arguments.length, e = 0, u = _(n); e < u; e++) {
    var i = n[e];
    if (!h.contains(r, i)) {
        var o;
        for (o = 1; o < t && h.contains(arguments[o], i); o++)
            ;
        o === t && r.push(i);
    }
} return r; }, h.difference = g(function (n, r) { return r = S(r, !0, !0), h.filter(n, function (n) { return !h.contains(r, n); }); }), h.unzip = function (n) { for (var r = n && h.max(n, _).length || 0, t = Array(r), e = 0; e < r; e++)
    t[e] = h.pluck(n, e); return t; }, h.zip = g(h.unzip), h.object = function (n, r) { for (var t = {}, e = 0, u = _(n); e < u; e++)
    r ? t[n[e]] = r[e] : t[n[e][0]] = n[e][1]; return t; }; var M = function (i) { return function (n, r, t) { r = d(r, t); for (var e = _(n), u = 0 < i ? 0 : e - 1; 0 <= u && u < e; u += i)
    if (r(n[u], u, n))
        return u; return -1; }; }; h.findIndex = M(1), h.findLastIndex = M(-1), h.sortedIndex = function (n, r, t, e) { for (var u = (t = d(t, e, 1))(r), i = 0, o = _(n); i < o;) {
    var a = Math.floor((i + o) / 2);
    t(n[a]) < u ? i = a + 1 : o = a;
} return i; }; var F = function (i, o, a) { return function (n, r, t) { var e = 0, u = _(n); if ("number" == typeof t)
    0 < i ? e = 0 <= t ? t : Math.max(t + u, e) : u = 0 <= t ? Math.min(t + 1, u) : t + u + 1;
else if (a && t && u)
    return n[t = a(n, r)] === r ? t : -1; if (r != r)
    return 0 <= (t = o(c.call(n, e, u), h.isNaN)) ? t + e : -1; for (t = 0 < i ? e : u - 1; 0 <= t && t < u; t += i)
    if (n[t] === r)
        return t; return -1; }; }; h.indexOf = F(1, h.findIndex, h.sortedIndex), h.lastIndexOf = F(-1, h.findLastIndex), h.range = function (n, r, t) { null == r && (r = n || 0, n = 0), t || (t = r < n ? -1 : 1); for (var e = Math.max(Math.ceil((r - n) / t), 0), u = Array(e), i = 0; i < e; i++, n += t)
    u[i] = n; return u; }, h.chunk = function (n, r) { if (null == r || r < 1)
    return []; for (var t = [], e = 0, u = n.length; e < u;)
    t.push(c.call(n, e, e += r)); return t; }; var E = function (n, r, t, e, u) { if (!(e instanceof r))
    return n.apply(t, u); var i = m(n.prototype), o = n.apply(i, u); return h.isObject(o) ? o : i; }; h.bind = g(function (r, t, e) { if (!h.isFunction(r))
    throw new TypeError("Bind must be called on a function"); var u = g(function (n) { return E(r, u, t, this, e.concat(n)); }); return u; }), h.partial = g(function (u, i) { var o = h.partial.placeholder, a = function () { for (var n = 0, r = i.length, t = Array(r), e = 0; e < r; e++)
    t[e] = i[e] === o ? arguments[n++] : i[e]; for (; n < arguments.length;)
    t.push(arguments[n++]); return E(u, a, this, this, t); }; return a; }), (h.partial.placeholder = h).bindAll = g(function (n, r) { var t = (r = S(r, !1, !1)).length; if (t < 1)
    throw new Error("bindAll must be passed function names"); for (; t--;) {
    var e = r[t];
    n[e] = h.bind(n[e], n);
} }), h.memoize = function (e, u) { var i = function (n) { var r = i.cache, t = "" + (u ? u.apply(this, arguments) : n); return h.has(r, t) || (r[t] = e.apply(this, arguments)), r[t]; }; return i.cache = {}, i; }, h.delay = g(function (n, r, t) { return setTimeout(function () { return n.apply(null, t); }, r); }), h.defer = h.partial(h.delay, h, 1), h.throttle = function (t, e, u) { var i, o, a, c, l = 0; u || (u = {}); var f = function () { l = !1 === u.leading ? 0 : h.now(), i = null, c = t.apply(o, a), i || (o = a = null); }, n = function () { var n = h.now(); l || !1 !== u.leading || (l = n); var r = e - (n - l); return o = this, a = arguments, r <= 0 || e < r ? (i && (clearTimeout(i), i = null), l = n, c = t.apply(o, a), i || (o = a = null)) : i || !1 === u.trailing || (i = setTimeout(f, r)), c; }; return n.cancel = function () { clearTimeout(i), l = 0, i = o = a = null; }, n; }, h.debounce = function (t, e, u) { var i, o, a = function (n, r) { i = null, r && (o = t.apply(n, r)); }, n = g(function (n) { if (i && clearTimeout(i), u) {
    var r = !i;
    i = setTimeout(a, e), r && (o = t.apply(this, n));
}
else
    i = h.delay(a, e, this, n); return o; }); return n.cancel = function () { clearTimeout(i), i = null; }, n; }, h.wrap = function (n, r) { return h.partial(r, n); }, h.negate = function (n) { return function () { return !n.apply(this, arguments); }; }, h.compose = function () { var t = arguments, e = t.length - 1; return function () { for (var n = e, r = t[e].apply(this, arguments); n--;)
    r = t[n].call(this, r); return r; }; }, h.after = function (n, r) { return function () { if (--n < 1)
    return r.apply(this, arguments); }; }, h.before = function (n, r) { var t; return function () { return 0 < --n && (t = r.apply(this, arguments)), n <= 1 && (r = null), t; }; }, h.once = h.partial(h.before, 2), h.restArguments = g; var N = !{ toString: null }.propertyIsEnumerable("toString"), I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"], T = function (n, r) { var t = I.length, e = n.constructor, u = h.isFunction(e) && e.prototype || o, i = "constructor"; for (h.has(n, i) && !h.contains(r, i) && r.push(i); t--;)
    (i = I[t]) in n && n[i] !== u[i] && !h.contains(r, i) && r.push(i); }; h.keys = function (n) { if (!h.isObject(n))
    return []; if (a)
    return a(n); var r = []; for (var t in n)
    h.has(n, t) && r.push(t); return N && T(n, r), r; }, h.allKeys = function (n) { if (!h.isObject(n))
    return []; var r = []; for (var t in n)
    r.push(t); return N && T(n, r), r; }, h.values = function (n) { for (var r = h.keys(n), t = r.length, e = Array(t), u = 0; u < t; u++)
    e[u] = n[r[u]]; return e; }, h.mapObject = function (n, r, t) { r = d(r, t); for (var e = h.keys(n), u = e.length, i = {}, o = 0; o < u; o++) {
    var a = e[o];
    i[a] = r(n[a], a, n);
} return i; }, h.pairs = function (n) { for (var r = h.keys(n), t = r.length, e = Array(t), u = 0; u < t; u++)
    e[u] = [r[u], n[r[u]]]; return e; }, h.invert = function (n) { for (var r = {}, t = h.keys(n), e = 0, u = t.length; e < u; e++)
    r[n[t[e]]] = t[e]; return r; }, h.functions = h.methods = function (n) { var r = []; for (var t in n)
    h.isFunction(n[t]) && r.push(t); return r.sort(); }; var B = function (c, l) { return function (n) { var r = arguments.length; if (l && (n = Object(n)), r < 2 || null == n)
    return n; for (var t = 1; t < r; t++)
    for (var e = arguments[t], u = c(e), i = u.length, o = 0; o < i; o++) {
        var a = u[o];
        l && void 0 !== n[a] || (n[a] = e[a]);
    } return n; }; }; h.extend = B(h.allKeys), h.extendOwn = h.assign = B(h.keys), h.findKey = function (n, r, t) { r = d(r, t); for (var e, u = h.keys(n), i = 0, o = u.length; i < o; i++)
    if (r(n[e = u[i]], e, n))
        return e; }; var R, q, K = function (n, r, t) { return r in t; }; h.pick = g(function (n, r) { var t = {}, e = r[0]; if (null == n)
    return t; h.isFunction(e) ? (1 < r.length && (e = y(e, r[1])), r = h.allKeys(n)) : (e = K, r = S(r, !1, !1), n = Object(n)); for (var u = 0, i = r.length; u < i; u++) {
    var o = r[u], a = n[o];
    e(a, o, n) && (t[o] = a);
} return t; }), h.omit = g(function (n, t) { var r, e = t[0]; return h.isFunction(e) ? (e = h.negate(e), 1 < t.length && (r = t[1])) : (t = h.map(S(t, !1, !1), String), e = function (n, r) { return !h.contains(t, r); }), h.pick(n, e, r); }), h.defaults = B(h.allKeys, !0), h.create = function (n, r) { var t = m(n); return r && h.extendOwn(t, r), t; }, h.clone = function (n) { return h.isObject(n) ? h.isArray(n) ? n.slice() : h.extend({}, n) : n; }, h.tap = function (n, r) { return r(n), n; }, h.isMatch = function (n, r) { var t = h.keys(r), e = t.length; if (null == n)
    return !e; for (var u = Object(n), i = 0; i < e; i++) {
    var o = t[i];
    if (r[o] !== u[o] || !(o in u))
        return !1;
} return !0; }, R = function (n, r, t, e) { if (n === r)
    return 0 !== n || 1 / n == 1 / r; if (null == n || null == r)
    return !1; if (n != n)
    return r != r; var u = typeof n; return ("function" === u || "object" === u || "object" == typeof r) && q(n, r, t, e); }, q = function (n, r, t, e) { n instanceof h && (n = n._wrapped), r instanceof h && (r = r._wrapped); var u = p.call(n); if (u !== p.call(r))
    return !1; switch (u) {
    case "[object RegExp]":
    case "[object String]": return "" + n == "" + r;
    case "[object Number]": return +n != +n ? +r != +r : 0 == +n ? 1 / +n == 1 / r : +n == +r;
    case "[object Date]":
    case "[object Boolean]": return +n == +r;
    case "[object Symbol]": return s.valueOf.call(n) === s.valueOf.call(r);
} var i = "[object Array]" === u; if (!i) {
    if ("object" != typeof n || "object" != typeof r)
        return !1;
    var o = n.constructor, a = r.constructor;
    if (o !== a && !(h.isFunction(o) && o instanceof o && h.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in r)
        return !1;
} e = e || []; for (var c = (t = t || []).length; c--;)
    if (t[c] === n)
        return e[c] === r; if (t.push(n), e.push(r), i) {
    if ((c = n.length) !== r.length)
        return !1;
    for (; c--;)
        if (!R(n[c], r[c], t, e))
            return !1;
}
else {
    var l, f = h.keys(n);
    if (c = f.length, h.keys(r).length !== c)
        return !1;
    for (; c--;)
        if (l = f[c], !h.has(r, l) || !R(n[l], r[l], t, e))
            return !1;
} return t.pop(), e.pop(), !0; }, h.isEqual = function (n, r) { return R(n, r); }, h.isEmpty = function (n) { return null == n || (A(n) && (h.isArray(n) || h.isString(n) || h.isArguments(n)) ? 0 === n.length : 0 === h.keys(n).length); }, h.isElement = function (n) { return !(!n || 1 !== n.nodeType); }, h.isArray = t || function (n) { return "[object Array]" === p.call(n); }, h.isObject = function (n) { var r = typeof n; return "function" === r || "object" === r && !!n; }, h.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error", "Symbol", "Map", "WeakMap", "Set", "WeakSet"], function (r) { h["is" + r] = function (n) { return p.call(n) === "[object " + r + "]"; }; }), h.isArguments(arguments) || (h.isArguments = function (n) { return h.has(n, "callee"); }); var z = n.document && n.document.childNodes; "function" != typeof /./ && "object" != typeof Int8Array && "function" != typeof z && (h.isFunction = function (n) { return "function" == typeof n || !1; }), h.isFinite = function (n) { return !h.isSymbol(n) && isFinite(n) && !isNaN(parseFloat(n)); }, h.isNaN = function (n) { return h.isNumber(n) && isNaN(n); }, h.isBoolean = function (n) { return !0 === n || !1 === n || "[object Boolean]" === p.call(n); }, h.isNull = function (n) { return null === n; }, h.isUndefined = function (n) { return void 0 === n; }, h.has = function (n, r) { if (!h.isArray(r))
    return null != n && i.call(n, r); for (var t = r.length, e = 0; e < t; e++) {
    var u = r[e];
    if (null == n || !i.call(n, u))
        return !1;
    n = n[u];
} return !!t; }, h.noConflict = function () { return n._ = r, this; }, h.identity = function (n) { return n; }, h.constant = function (n) { return function () { return n; }; }, h.noop = function () { }, h.property = function (r) { return h.isArray(r) ? function (n) { return j(n, r); } : b(r); }, h.propertyOf = function (r) { return null == r ? function () { } : function (n) { return h.isArray(n) ? j(r, n) : r[n]; }; }, h.matcher = h.matches = function (r) { return r = h.extendOwn({}, r), function (n) { return h.isMatch(n, r); }; }, h.times = function (n, r, t) { var e = Array(Math.max(0, n)); r = y(r, t, 1); for (var u = 0; u < n; u++)
    e[u] = r(u); return e; }, h.random = function (n, r) { return null == r && (r = n, n = 0), n + Math.floor(Math.random() * (r - n + 1)); }, h.now = Date.now || function () { return (new Date).getTime(); }; var D = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }, L = h.invert(D), P = function (r) { var t = function (n) { return r[n]; }, n = "(?:" + h.keys(r).join("|") + ")", e = RegExp(n), u = RegExp(n, "g"); return function (n) { return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n; }; }; h.escape = P(D), h.unescape = P(L), h.result = function (n, r, t) { h.isArray(r) || (r = [r]); var e = r.length; if (!e)
    return h.isFunction(t) ? t.call(n) : t; for (var u = 0; u < e; u++) {
    var i = null == n ? void 0 : n[r[u]];
    void 0 === i && (i = t, u = e), n = h.isFunction(i) ? i.call(n) : i;
} return n; }; var W = 0; h.uniqueId = function (n) { var r = ++W + ""; return n ? n + r : r; }, h.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; var C = /(.)^/, J = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" }, U = /\\|'|\r|\n|\u2028|\u2029/g, V = function (n) { return "\\" + J[n]; }; h.template = function (i, n, r) { !n && r && (n = r), n = h.defaults({}, n, h.templateSettings); var t, e = RegExp([(n.escape || C).source, (n.interpolate || C).source, (n.evaluate || C).source].join("|") + "|$", "g"), o = 0, a = "__p+='"; i.replace(e, function (n, r, t, e, u) { return a += i.slice(o, u).replace(U, V), o = u + n.length, r ? a += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : t ? a += "'+\n((__t=(" + t + "))==null?'':__t)+\n'" : e && (a += "';\n" + e + "\n__p+='"), n; }), a += "';\n", n.variable || (a = "with(obj||{}){\n" + a + "}\n"), a = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + a + "return __p;\n"; try {
    t = new Function(n.variable || "obj", "_", a);
}
catch (n) {
    throw n.source = a, n;
} var u = function (n) { return t.call(this, n, h); }, c = n.variable || "obj"; return u.source = "function(" + c + "){\n" + a + "}", u; }, h.chain = function (n) { var r = h(n); return r._chain = !0, r; }; var $ = function (n, r) { return n._chain ? h(r).chain() : r; }; h.mixin = function (t) { return h.each(h.functions(t), function (n) { var r = h[n] = t[n]; h.prototype[n] = function () { var n = [this._wrapped]; return u.apply(n, arguments), $(this, r.apply(h, n)); }; }), h; }, h.mixin(h), h.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (r) { var t = e[r]; h.prototype[r] = function () { var n = this._wrapped; return t.apply(n, arguments), "shift" !== r && "splice" !== r || 0 !== n.length || delete n[0], $(this, n); }; }), h.each(["concat", "join", "slice"], function (n) { var r = e[n]; h.prototype[n] = function () { return $(this, r.apply(this._wrapped, arguments)); }; }), h.prototype.value = function () { return this._wrapped; }, h.prototype.valueOf = h.prototype.toJSON = h.prototype.value, h.prototype.toString = function () { return String(this._wrapped); }, "function" == typeof define && define.amd && define("underscore", [], function () { return h; }); }();
angular.module('ngColorPicker', [])
    .directive('ngColorPicker', function () {
    var defaultColors = [
        '#7bd148',
        '#5484ed',
        '#a4bdfc',
        '#46d6db',
        '#7ae7bf',
        '#51b749',
        '#fbd75b',
        '#ffb878',
        '#ff887c',
        '#dc2127',
        '#dbadff',
        '#e1e1e1'
    ];
    return {
        scope: {
            selected: '=',
            customizedColors: '=colors'
        },
        restrict: 'AE',
        template: '<ul><li ng-repeat="color in colors" ng-class="{selected: (color===selected)}" ng-click="pick(color)" ng-style="{\'background-color\':color};"></li></ul>',
        link: function (scope, element, attr) {
            scope.colors = scope.customizedColors || defaultColors;
            scope.selected = scope.selected || scope.colors[0];
            scope.pick = function (color) {
                scope.selected = color;
            };
        }
    };
});
angular.module('suiviApp', ['ngColorPicker',
    'ngResource',
    'textAngular',
    'ui.bootstrap',
    'ui.router'])
    .constant('DEFAULT_RIGHTS_ONGLET', [
    { "profile_type": "ENS", "read": true, "write": true, "manage": true },
    { "profile_type": "EVS", "read": true, "write": true, "manage": true },
    { "profile_type": "DOC", "read": true, "write": true, "manage": true },
    { "profile_type": "DIR", "read": true, "write": true, "manage": true }
])
    .config(['$httpProvider',
    function ($httpProvider) {
        $httpProvider.defaults.withCredentials = true;
    }])
    .config(['$provide',
    function ($provide) {
        $provide.decorator('taTranslations', ['$delegate',
            function ($delegate) {
                $delegate.html.tooltip = 'Basculer entre les vues HTML et texte enrichi';
                $delegate.justifyLeft.tooltip = 'Justifier à gauche';
                $delegate.justifyCenter.tooltip = 'Centrer';
                $delegate.justifyRight.tooltip = 'Justifier à droite';
                $delegate.bold.tooltip = 'Mettre en gras';
                $delegate.italic.tooltip = 'Mettre en italique';
                $delegate.underline.tooltip = 'Souligner';
                $delegate.insertLink.tooltip = 'Insérer un lien';
                $delegate.insertLink.dialogPrompt = 'Lien à insérer';
                $delegate.editLink.targetToggle.buttontext = 'Le lien s\'ouvrira dans une nouvelle fenêtre';
                $delegate.editLink.reLinkButton.tooltip = 'Éditer le lien';
                $delegate.editLink.unLinkButton.tooltip = 'Enlever le lien';
                $delegate.insertImage.tooltip = 'Insérer une image';
                $delegate.insertImage.dialogPrompt = 'URL de l\'image :';
                $delegate.insertVideo.tooltip = 'Insérer une vidéo';
                $delegate.insertVideo.dialogPrompt = 'URL de la vidéo Youtube :';
                $delegate.clear.tooltip = 'Enlever le formattage';
                $delegate.ul.tooltip = 'Liste';
                $delegate.ol.tooltip = 'Liste numérotée';
                $delegate.quote.tooltip = 'Citation';
                $delegate.undo.tooltip = 'Annuler';
                $delegate.redo.tooltip = 'Rétablir';
                return $delegate;
            }]);
        $provide.decorator('taOptions', ['$delegate', 'taRegisterTool',
            function (taOptions, taRegisterTool) {
                var colorpicker_taTool = function (type) {
                    var style_prefix = (type === 'backcolor') ? 'background-' : '';
                    var couleurs = ['#7bd148', '#5484ed', '#a4bdfc', '#46d6db', '#7ae7bf', '#51b749', '#fbd75b', '#ffb878', '#ff887c', '#dc2127', '#dbadff', '#e1e1e1'];
                    if (type === 'backcolor') {
                        couleurs.push('transparent');
                    }
                    return {
                        couleurs: couleurs,
                        display: '<span uib-dropdown><a uib-dropdown-toggle><i class="fa fa-font" data-ng-style="{\'' + style_prefix + 'color\': selected }"></i> <i class="fa fa-caret-down"></i></a><ng-color-picker uib-dropdown-menu selected="selected" colors="couleurs"></ng-color-picker></span>',
                        action: function () {
                            return (this.selected === 'nil') ? false : this.$editor().wrapSelection(type, this.selected);
                        }
                    };
                };
                taRegisterTool('fontColor', colorpicker_taTool('forecolor'));
                taRegisterTool('table', {
                    columns: {
                        value: 1,
                        hovered: 1
                    },
                    rows: {
                        value: 1,
                        hovered: 1
                    },
                    hover: function (objet, value) {
                        objet.hovered = value;
                    },
                    leave: function (objet) {
                        objet.hovered = objet.value;
                    },
                    tooltiptext: 'insérer un tableau',
                    display: "\n              <span uib-dropdown>\n                <a uib-dropdown-toggle>\n                  <i class=\"fa fa-table\">\n                  </i>\n                  <i class=\"fa fa-caret-down\">\n                  </i>\n                </a>\n                <div uib-dropdown-menu data-ng-click=\"$event.stopPropagation()\">\n                  <label>\n                    <span uib-rating on-hover=\"hover( columns, value )\" on-leave=\"leave( columns )\" ng-model=\"columns.value\" max=\"15\" state-on=\"'glyphicon-stop'\" state-off=\"'glyphicon-unchecked'\">\n                    </span>\n                    <br>{{columns.hovered}} colonnes\n                  </label>\n                  <br>\n                    <label>\n                      <span uib-rating on-hover=\"hover( rows, value )\" on-leave=\"leave( rows )\" ng-model=\"rows.value\" max=\"15\" state-on=\"'glyphicon-stop'\" state-off=\"'glyphicon-unchecked'\">\n                      </span>\n                      <br>{{rows.hovered}} lignes\n                    </label>\n                    <br>\n                      <button class=\"btn btn-success\" data-ng-click=\"insert_table()\">Ins\u00E9rer</button>\n                    </div>\n                  </span>\n",
                    insert_table: function () {
                        var tds = '';
                        _(this.columns.value).times(function (i) { tds = tds + '<td>&nbsp;</td>'; });
                        var trs = '';
                        _(this.rows.value).times(function (j) { trs = trs + '<tr>' + tds + '</tr>'; });
                        this.$editor().wrapSelection('insertHTML', '<table class="table table-bordered">' + trs + '</table>');
                        this.deferration.resolve();
                    },
                    action: function (deferred) {
                        this.deferration = deferred;
                        return false;
                    }
                });
                taOptions.toolbar = [['bold', 'italics', 'underline', 'ul', 'ol', 'quote', 'fontColor', 'justifyLeft', 'justifyCenter', 'justifyRight', 'table', 'insertLink', 'insertImage', 'html', 'undo', 'redo']];
                taOptions.classes = {
                    focussed: 'focussed',
                    toolbar: 'btn-toolbar',
                    toolbarGroup: 'btn-group',
                    toolbarButton: 'btn btn-default',
                    toolbarButtonActive: 'active',
                    disabled: 'disabled',
                    textEditor: 'form-control',
                    htmlEditor: 'form-control'
                };
                return taOptions;
            }]);
        $provide.decorator('taTools', ['$delegate',
            function (taTools) {
                taTools.html.buttontext = 'HTML';
                return taTools;
            }]);
    }]);
angular.module('suiviApp')
    .config(['$stateProvider', '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {
        $urlRouterProvider.otherwise('/');
        $stateProvider
            .state('trombinoscope', {
            url: '/',
            component: 'trombinoscope'
        })
            .state('student', {
            url: '/student/:uids',
            params: { uids: { array: true } },
            component: 'student',
            resolve: {
                uids: ['$transition$',
                    function ($transition$) {
                        return $transition$.params().uids;
                    }]
            }
        });
    }]);
angular.module('suiviApp')
    .component('droits', {
    bindings: {
        uidEleve: '<',
        droits: '=',
        concernedPeople: '<'
    },
    controller: ['Droits', 'APIs', 'Utils', 'UID', 'URL_ENT', 'User',
        function (Droits, APIs, Utils, UID, URL_ENT, User) {
            var ctrl = this;
            ctrl.sharing_enabled = false;
            ctrl.groups = [];
            var maybe_init_dirtiness = function (droit) {
                if (droit.dirty == undefined) {
                    droit.dirty = {
                        uid: false,
                        profile_type: false,
                        group_id: false,
                        sharable_id: false,
                        read: false,
                        write: false,
                        manage: false
                    };
                }
            };
            ctrl.add = function (droit) {
                droit.new = true;
                maybe_init_dirtiness(droit);
                ctrl.droits.push(new Droits(droit));
            };
            ctrl.add_sharable = function (droit) {
                droit.sharable_id = Utils.gen_pseudo_UUID();
                ctrl.add(droit);
            };
            ctrl.set_read = function (droit) {
                maybe_init_dirtiness(droit);
                droit.dirty.read = true;
                if (!droit.read && droit.write) {
                    droit.write = false;
                    droit.dirty.write = true;
                }
                if (!droit.read && droit.manage) {
                    droit.manage = false;
                    droit.dirty.manage = true;
                }
            };
            ctrl.set_write = function (droit) {
                maybe_init_dirtiness(droit);
                droit.dirty.write = true;
                if (droit.write && !droit.read) {
                    droit.read = true;
                    droit.dirty.read = true;
                }
                if (!droit.write && droit.manage) {
                    droit.manage = false;
                    droit.dirty.manage = true;
                }
            };
            ctrl.set_manage = function (droit) {
                maybe_init_dirtiness(droit);
                droit.dirty.manage = true;
                if (droit.manage && !droit.write) {
                    droit.write = true;
                    droit.dirty.write = true;
                }
                if (droit.manage && !droit.read) {
                    droit.read = true;
                    droit.dirty.read = true;
                }
            };
            ctrl.update_deletabilities = function () {
                ctrl.droits.forEach(function (droit) {
                    droit.deletable = droit.uid != UID;
                    if (ctrl.uidEleve != undefined) {
                        droit.deletable = droit.deletable && droit.uid != ctrl.uidEleve;
                    }
                });
            };
            ctrl.$onInit = function () {
                ctrl.update_deletabilities();
                APIs.query_profiles_types()
                    .then(function success(response) {
                    ctrl.profils = response.data;
                }, function error(response) { });
                User.get({ id: UID }).$promise
                    .then(function success(current_user) {
                    return current_user.get_actual_groups();
                })
                    .then(function success(response) {
                    ctrl.groups = response
                        .filter(function (group) { return group.type == "GPL"; })
                        .map(function (group) {
                        var pretty_types = { CLS: "Classes", GRP: "Groupes d'élèves", GPL: "Groupes libres" };
                        group.pretty_type = pretty_types[group.type];
                        return group;
                    });
                }, function error(response) { });
                if (ctrl.concernedPeople == undefined) {
                    ctrl.concernedPeople = [];
                }
                var concernedPeople_ids = ctrl.concernedPeople.map(function (people) { return people.id; });
                APIs.get_users(ctrl.droits
                    .filter(function (droit) { return droit.uid != undefined && !concernedPeople_ids.includes(droit.uid); })
                    .map(function (droit) { return droit.uid; }))
                    .then(function (response) {
                    ctrl.concernedPeople = ctrl.concernedPeople.concat(response.data);
                });
            };
        }],
    template: "\n                     <div>\n                       <label>Gestion des droits</label>\n                       <table style=\"width: 100%;\">\n                         <tr style=\"text-align: right;\"\n                             ng:repeat=\"droit in $ctrl.droits\"\n                             ng:if=\"ctrl.sharing_enabled || !droit.sharable_id\">\n                           <td>\n                             <label ng:if=\"droit.uid\">Personne :\n                               <select style=\"width: 250px;\"\n                                       ng:model=\"droit.uid\"\n                                       ng:change=\"droit.dirty.uid = true\"\n                                       ng:disabled=\"droit.to_delete\"\n                                       ng:options=\"people.id as people.firstname + ' ' + people.lastname group by people.type for people in $ctrl.concernedPeople\">\n                               </select>\n                             </label>\n\n                             <label ng:if=\"droit.profile_type\">Profil :\n                               <select style=\"width: 250px;\"\n                                       ng:model=\"droit.profile_type\"\n                                       ng:change=\"droit.dirty.profile_type = true\"\n                                       ng:disabled=\"droit.to_delete\">\n                                 <option ng:repeat=\"profil in $ctrl.profils track by profil.id\"\n                                         ng:value=\"profil.id\">{{profil.name}}</option>\n                               </select>\n                             </label>\n\n                             <label ng:if=\"droit.group_id\">Groupe :\n                               <select style=\"width: 250px;\"\n                                       ng:model=\"droit.group_id\"\n                                       ng:change=\"droit.dirty.group_id = true\"\n                                       ng:disabled=\"droit.to_delete\"\n                                       ng:options=\"group.id as group.name group by group.pretty_type for group in $ctrl.groups\">\n                               </select>\n                             </label>\n\n                             <label ng:if=\"droit.sharable_id\">Partage :\n                               <input style=\"width: 250px;\"\n                                      type=\"text\"\n                                      ng:model=\"droit.sharable_id\"\n                                      ng:change=\"droit.dirty.sharable_id = true\"\n                                      ng:disabled=\"droit.to_delete\" />\n                             </label>\n                           </td>\n                           <td>\n                             <button type=\"button\" class=\"btn\"\n                                     ng:class=\"{'btn-default': !droit.read, 'btn-success': droit.read}\"\n                                     ng:model=\"droit.read\"\n                                     ng:change=\"$ctrl.set_read( droit )\"\n                                     ng:disabled=\"droit.to_delete || droit.sharable_id\"\n                                     uib:btn-checkbox\n                                     btn-checkbox-true=\"true\"\n                                     btn-checkbox-false=\"false\"\n                                     uib:tooltip=\"droit de lecture\">\n                               <span class=\"glyphicon glyphicon-eye-open\"></span>\n                             </button>\n                           </td>\n                           <td>\n                             <button type=\"button\" class=\"btn\"\n                                     ng:class=\"{'btn-default': !droit.write, 'btn-success': droit.write}\"\n                                     ng:model=\"droit.write\"\n                                     ng:change=\"$ctrl.set_write( droit )\"\n                                     ng:disabled=\"droit.to_delete || droit.sharable_id\"\n                                     uib:btn-checkbox\n                                     btn-checkbox-true=\"true\"\n                                     btn-checkbox-false=\"false\"\n                                     uib:tooltip=\"droit d'\u00E9criture\">\n                               <span class=\"glyphicon glyphicon-edit\"></span>\n                             </button>\n                           </td>\n                           <td>\n                             <button type=\"button\" class=\"btn\"\n                                     ng:class=\"{'btn-default': !droit.manage, 'btn-success': droit.manage}\"\n                                     ng:model=\"droit.manage\"\n                                     ng:change=\"$ctrl.set_manage( droit )\"\n                                     ng:disabled=\"droit.to_delete || droit.sharable_id\"\n                                     uib:btn-checkbox\n                                     btn-checkbox-true=\"true\"\n                                     btn-checkbox-false=\"false\"\n                                     uib:tooltip=\"droit d'administration\">\n                               <span class=\"glyphicon glyphicon-cog\"></span>\n                             </button>\n                           </td>\n                           <td>\n                             <button type=\"button\" class=\"btn\"\n                                     ng:class=\"{'btn-default': !droit.to_delete, 'btn-warning': droit.to_delete}\"\n                                     ng:disabled=\"!droit.deletable && !droit.to_delete\"\n                                     ng:model=\"droit.to_delete\"\n                                     ng:change=\"$ctrl.update_deletabilities()\"\n                                     uib:btn-checkbox\n                                     btn-checkbox-true=\"true\"\n                                     btn-checkbox-false=\"false\">\n                               <span class=\"glyphicon glyphicon-trash\"></span>\n                             </button>\n                           </td>\n                         </tr>\n                         <tfoot>\n                           <td colspan=\"3\">\n                             <button class=\"btn btn-default\"\n                                     ng:click=\"$ctrl.add({ uid: '...', read: true, write: true })\">\n                               <span class=\"glyphicon glyphicon-plus-sign\"></span> par personne\n                             </button>\n\n                             <button class=\"btn btn-default\"\n                                     ng:click=\"$ctrl.add({ profile_type: '...', read: true, write: false })\">\n                               <span class=\"glyphicon glyphicon-plus-sign\"></span> par profil\n                             </button>\n\n                             <button class=\"btn btn-default\"\n                                     ng:click=\"$ctrl.add({ group_id: '...', read: true, write: false })\"\n                                     ng:if=\"$ctrl.groups.length > 0\">\n                               <span class=\"glyphicon glyphicon-plus-sign\"></span> par groupe\n                             </button>\n\n                             <button class=\"btn btn-warning pull-right\"\n                                     ng:if=\"ctrl.sharing_enabled\"\n                                     ng:click=\"$ctrl.add_sharable({ read: true, write: false })\">\n                               <span class=\"glyphicon glyphicon-plus-sign\"></span> partage\n                             </button>\n                           </td>\n                         </tfoot>\n                       </table>\n                     </div>\n"
});
angular.module('suiviApp')
    .config(['$compileProvider',
    function ($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|javascript|blob|data):/);
    }])
    .component('onglet', {
    bindings: {
        uids: '<',
        onglets: '<',
        onglet: '='
    },
    controller: ['$uibModal', '$state', '$q', '$window', '$sce', '$location', 'Saisies',
        function ($uibModal, $state, $q, $window, $sce, $location, Saisies) {
            var ctrl = this;
            ctrl.order_by = {
                field: 'date',
                reverse: true
            };
            ctrl.callback_popup_onglet = function (onglet) {
                if (onglet.action == 'deleted') {
                    $state.go('student', { uids: ctrl.uids }, { reload: true });
                }
            };
            ctrl.saisie_callback = function (saisie) {
                switch (saisie.action) {
                    case 'created':
                        ctrl.saisies.push(saisie);
                        init_new_saisie();
                        break;
                    case 'deleted':
                        ctrl.saisies = ctrl.saisies.filter(function (s) { return s.id != saisie.id; });
                        break;
                    case 'updated':
                        var index = ctrl.saisies.findIndex(function (s) { return s.id == saisie.id; });
                        ctrl.saisies[index] = saisie;
                        break;
                    default:
                        console.log('What to do with this?');
                        console.log(saisie);
                }
            };
            var init_new_saisie = function () {
                ctrl.new_saisie = ctrl.onglet.writable ? { create_me: true } : null;
            };
            var filter_on_pin = function (pinned) {
                return function () {
                    return function (saisie) {
                        return saisie.pinned == pinned;
                    };
                };
            };
            ctrl.filter_pinned = filter_on_pin(true);
            ctrl.filter_unpinned = filter_on_pin(false);
            ctrl.$onInit = function () {
                init_new_saisie();
                Saisies.query({
                    "onglets_ids[]": ctrl.onglet.ids
                }).$promise
                    .then(function success(response) {
                    ctrl.saisies = response;
                }, function error(response) { });
            };
        }],
    template: "\n                  <saisie class=\"col-md-12\" style=\"display: inline-block;\"\n                          ng:repeat=\"saisie in $ctrl.saisies | filter:$ctrl.filter_pinned() | orderBy:$ctrl.order_by.field:$ctrl.order_by.reverse\"\n                          onglet=\"$ctrl.onglet\"\n                          saisie=\"saisie\"\n                          callback=\"$ctrl.saisie_callback( saisie )\"></saisie>\n\n                  <saisie class=\"col-md-12\"\n                          style=\"display: inline-block;\"\n                          ng:if=\"$ctrl.new_saisie\"\n                          onglet=\"$ctrl.onglet\"\n                          saisie=\"$ctrl.new_saisie\"\n                          callback=\"$ctrl.saisie_callback( $ctrl.new_saisie )\"></saisie>\n\n                  <div class=\"col-md-12\" style=\"margin-bottom: 10px;\">\n                    <button class=\"btn btn-sm btn-primary pull-right\"\n                            ng:click=\"$ctrl.order_by.reverse = !$ctrl.order_by.reverse\"\n                            ng:if=\"$ctrl.saisies.length > 1\">\n                      <span class=\"glyphicon\"\n                            ng:class=\"{'glyphicon-sort-by-order': $ctrl.order_by.reverse, 'glyphicon-sort-by-order-alt': !$ctrl.order_by.reverse}\"></span>\n                      Trier par la date de publication la plus <span ng:if=\"$ctrl.order_by.reverse\">r\u00E9cente</span><span ng:if=\"!$ctrl.order_by.reverse\">ancienne</span>.\n                    </button>\n                  </div>\n\n                  <div class=\"col-md-12 saisies\" style=\"overflow-y: auto;\">\n\n                    <saisie class=\"col-md-12\" style=\"display: inline-block;\"\n                            ng:repeat=\"saisie in $ctrl.saisies | filter:$ctrl.filter_unpinned() | orderBy:$ctrl.order_by.field:$ctrl.order_by.reverse\"\n                            onglet=\"$ctrl.onglet\"\n                            saisie=\"saisie\"\n                            callback=\"$ctrl.saisie_callback( saisie )\"></saisie>\n                  </div>\n"
});
angular.module('suiviApp')
    .component('onglets', {
    bindings: {
        uids: '<'
    },
    controller: ['$uibModal', 'Onglets', 'Popups', 'APIs', 'User', 'UID',
        function ($uibModal, Onglets, Popups, APIs, User, UID) {
            var ctrl = this;
            ctrl.popup_onglet = Popups.onglet;
            ctrl.callback_popup_onglet = function (treated_onglets) {
                if (treated_onglets.action == "created") {
                    treated_onglets = _(treated_onglets).groupBy('name');
                    ctrl.onglets = ctrl.onglets.concat(Object.keys(treated_onglets)
                        .map(function (key) {
                        return {
                            name: key,
                            ids: treated_onglets[key].map(function (onglet) { return onglet.id; }),
                            writable: treated_onglets[key].reduce(function (memo, onglet) { return memo && onglet.writable; }, true),
                            manageable: treated_onglets[key].reduce(function (memo, onglet) { return memo && onglet.manageable; }, true)
                        };
                    }));
                }
                if (treated_onglets.deleted) {
                    ctrl.onglets = ctrl.onglets.filter(function (onglet) { return onglet.name != treated_onglets.name; });
                }
                if (Array.isArray(treated_onglets) && treated_onglets[0].deleted) {
                    ctrl.onglets = ctrl.onglets.filter(function (onglet) { return onglet.name != treated_onglets[0].name; });
                }
            };
            ctrl.$onInit = function () {
                if (ctrl.uids.length == 1) {
                    Popups.loading_window("Chargement des onglets", "", function () {
                        return Onglets.query({ "uids[]": ctrl.uids }).$promise
                            .then(function success(response) {
                            ctrl.onglets = _(response).map(function (onglet) {
                                onglet.ids = [onglet.id];
                                return onglet;
                            });
                        }, function error(response) { });
                    });
                }
                else {
                    Popups.loading_window("Chargement des onglets communs", "", function () {
                        return APIs.query_common_onglets_of(ctrl.uids)
                            .then(function (response) {
                            ctrl.onglets = Object.keys(response).map(function (key) {
                                return {
                                    name: key,
                                    ids: response[key].map(function (onglet) { return onglet.id; }),
                                    writable: response[key].reduce(function (memo, onglet) { return memo && onglet.writable; }, true),
                                    manageable: response[key].reduce(function (memo, onglet) { return memo && onglet.manageable; }, true)
                                };
                            });
                        });
                    });
                }
                User.get({ id: UID }).$promise
                    .then(function (response) {
                    ctrl.current_user = response;
                    ctrl.can_add_tab = ctrl.current_user.can_add_tab(ctrl.uids);
                });
            };
        }],
    template: "\n  <style>\n    .manage-onglet { margin-top: -16px; margin-right: -16px; height: 28px; border-radius: 0 0 0 12px; }\n  </style>\n  <uib-tabset>\n    <uib-tab ng:repeat=\"onglet in $ctrl.onglets track by $index\">\n      <uib-tab-heading> {{onglet.name}}\n        <button class=\"btn btn-warning manage-onglet\"\n                ng:if=\"onglet.manageable\"\n                ng:click=\"$ctrl.popup_onglet( $ctrl.uids, onglet, $ctrl.onglets, $ctrl.callback_popup_onglet )\">\n          <span class=\"glyphicon glyphicon-cog\"></span>\n        </button>\n      </uib-tab-heading>\n\n      <onglet uids=\"$ctrl.uids\"\n              onglets=\"$ctrl.onglets\"\n              onglet=\"onglet\">\n      </onglet>\n    </uib-tab>\n\n    <li>\n      <a href\n         class=\"bleu add-onglet\"\n         ng:click=\"$ctrl.popup_onglet( $ctrl.uids, null, $ctrl.onglets, $ctrl.callback_popup_onglet )\"\n         ng:if=\"$ctrl.can_add_tab\">\n        <span class=\"glyphicon glyphicon-plus\">\n        </span>\n      </a>\n    </li>\n  </uib-tabset>\n"
});
angular.module('suiviApp')
    .component('saisie', {
    bindings: {
        onglet: '<',
        saisie: '=',
        callback: '&'
    },
    controller: ['$sce', 'Saisies', 'APIs', 'User', 'UID',
        function ($sce, Saisies, APIs, User, UID) {
            var ctrl = this;
            ctrl.toggle_edit = function () {
                ctrl.edition = !ctrl.edition;
                if (!ctrl.edition) {
                    ctrl.saisie.trusted_content = $sce.trustAsHtml(ctrl.saisie.content);
                }
                else {
                    ctrl.previous_content = ctrl.saisie.content;
                }
            };
            ctrl.cancel = function () {
                ctrl.saisie.content = ctrl.previous_content;
                ctrl.toggle_edit();
            };
            ctrl.save = function () {
                ctrl.saisie.pinned = ctrl.saisie.tmp_pinned || false;
                if (!_(ctrl.saisie).has('$save')) {
                    ctrl.saisie.onglets_ids = ctrl.onglet.ids;
                    ctrl.saisie = new Saisies(ctrl.saisie);
                }
                var promise = ctrl.new_saisie ? ctrl.saisie.$save() : ctrl.saisie.$update();
                promise.then(function success(response) {
                    if (!ctrl.new_saisie) {
                        ctrl.toggle_edit();
                    }
                    ctrl.saisie.action = ctrl.new_saisie ? 'created' : 'updated';
                    ctrl.callback();
                }, function error(response) { console.log(response); });
            };
            ctrl.delete = function () {
                swal({
                    title: 'Êtes-vous sur ?',
                    text: "La saisie sera définitivement supprimée !",
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#3085d6',
                    confirmButtonText: 'Oui, je confirme !',
                    cancelButtonText: 'Annuler'
                })
                    .then(function (response) {
                    if (response.dismiss != "cancel") {
                        Saisies.delete({
                            id: ctrl.saisie.id,
                            "onglets_ids[]": ctrl.onglet.ids
                        }).$promise
                            .then(function () {
                            ctrl.saisie.action = 'deleted';
                            ctrl.callback();
                        });
                    }
                });
            };
            ctrl.$onInit = function () {
                ctrl.edition = ctrl.saisie.create_me;
                if (ctrl.saisie.create_me) {
                    ctrl.new_saisie = true;
                    ctrl.saisie.content = '';
                    ctrl.saisie.tmp_pinned = false;
                }
                else {
                    ctrl.saisie = new Saisies(ctrl.saisie);
                    ctrl.saisie.tmp_pinned = ctrl.saisie.pinned;
                }
                ctrl.saisie.trusted_content = $sce.trustAsHtml(ctrl.saisie.content);
                User.get({ id: UID }).$promise
                    .then(function (current_user) {
                    ctrl.current_user = current_user;
                    ctrl.editable = ctrl.new_saisie ||
                        (_(ctrl).has('onglet') && (ctrl.onglet.manageable || (ctrl.onglet.writable && ctrl.saisie.uid_author == ctrl.current_user.id))) ||
                        ctrl.current_user.is_admin();
                });
                ctrl.toolbar_id = ctrl.new_saisie ? (Math.random() * 2048) + "" : ctrl.saisie.id;
            };
            ctrl.$onChanges = function (changes) {
                ctrl.saisie.trusted_content = $sce.trustAsHtml(ctrl.saisie.content);
            };
        }],
    template: "\n                   <div class=\"panel panel-default saisie-display\" ng:class=\"{'new-saisie': $ctrl.new_saisie}\">\n                     <span style=\"position: absolute; top: 0; right: 15px;height: 0;width: 0;text-align: center; color: #fff; border-color: transparent #fa0 transparent transparent;border-style: solid;border-width: 0 50px 50px 0; z-index: 1;\"\n                           ng:if=\"$ctrl.saisie.tmp_pinned\">\n                       <span class=\"glyphicon glyphicon-pushpin\" style=\"margin-left: 25px;font-size: 22px;margin-top: 3px;\"></span>\n                     </span>\n\n                     <div class=\"panel-heading\" ng:if=\"$ctrl.saisie.id && !$ctrl.saisie.tmp_pinned\">\n                       <user-details class=\"col-md-4\"\n                                     ng:if=\"!$ctrl.saisie.new_saisie\"\n                                     uid=\"$ctrl.saisie.uid_author\"\n                                     small=\"true\"\n                                     show-avatar=\"true\"></user-details>\n                       {{$ctrl.saisie.ctime | date:'medium'}}\n                       <div class=\"clearfix\"></div>\n                     </div>\n\n                     <div class=\"panel-body\" ng:style=\"{'padding': $ctrl.new_saisie ? 0 : 'inherit', 'border': $ctrl.new_saisie ? 0 : 'inherit'}\">\n\n                       <div class=\"col-md-12\"\n                            ta-bind\n                            ng:model=\"$ctrl.saisie.trusted_content\"\n                            ng:if=\"!$ctrl.edition\"></div>\n\n                       <div class=\"col-md-12\"\n                            ng:style=\"{'padding': $ctrl.new_saisie ? 0 : 'inherit'}\"\n                            ng:if=\"$ctrl.edition\">\n                         <text-angular ta:target-toolbars=\"main-ta-toolbar-{{$ctrl.toolbar_id}}\"\n                                       ng:model=\"$ctrl.saisie.content\"\n                                       ng:change=\"$ctrl.dirty = true\"></text-angular>\n                         <div class=\"suivi-ta-toolbar gris2-moins\">\n                           <text-angular-toolbar class=\"pull-left\"\n                                                 style=\"margin-left: 0;\"\n                                                 name=\"main-ta-toolbar-{{$ctrl.toolbar_id}}\"></text-angular-toolbar>\n\n                           <button class=\"btn\" style=\"margin-left: 6px;\"\n                                   ng:model=\"$ctrl.saisie.tmp_pinned\"\n                                   ng:change=\"$ctrl.dirty = true\"\n                                   ng:class=\"{'btn-warning': $ctrl.saisie.tmp_pinned, 'btn-default': !$ctrl.saisie.tmp_pinned}\"\n                                   uib:btn-checkbox\n                                   btn:checkbox-true=\"true\"\n                                   btn:checkbox-false=\"false\">\n                             <span class=\"glyphicon glyphicon-pushpin\" ></span> \u00C9pingler\n                           </button>\n\n                           <button class=\"btn btn-success pull-right\"\n                                   ng:disabled=\"!$ctrl.dirty || !$ctrl.onglet\"\n                                   ng:click=\"$ctrl.save()\">\n                             <span class=\"glyphicon glyphicon-save\" ></span> Publier\n                           </button>\n                           <button class=\"btn btn-default pull-right\"\n                                   ng:click=\"$ctrl.cancel()\"\n                                   ng:if=\"$ctrl.saisie.id\">\n                             <span class=\"glyphicon glyphicon-edit\" ></span> Annuler\n                           </button>\n\n                           <button class=\"btn btn-danger pull-right\"\n                                   ng:click=\"$ctrl.delete()\"\n                                   ng:if=\"$ctrl.saisie.id && ( $ctrl.editable || $ctrl.onglet.manageable || $ctrl.current_user.is_admin() )\">\n                             <span class=\"glyphicon glyphicon-trash\"></span> Supprimer\n                           </button>\n                           <div class=\"clearfix\"></div>\n                         </div>\n                       </div>\n                     </div>\n\n                     <div class=\"panel-footer\" ng:if=\"!$ctrl.edition\">\n                       <div class=\"pull-right buttons\">\n                         <button class=\"btn btn-default\"\n                                 ng:click=\"$ctrl.toggle_edit()\"\n                                 ng:if=\"$ctrl.editable\">\n                           <span class=\"glyphicon glyphicon-edit\" ></span> \u00C9diter\n                         </button>\n                       </div>\n                       <div class=\"clearfix\"></div>\n                     </div>\n                   </div>\n\n"
});
angular.module('suiviApp')
    .component('student', {
    bindings: {
        uids: '<'
    },
    template: "\n               <div class=\"col-md-4 gris1-moins aside aside-student\">\n                 <a class=\"col-md-12 btn btn-lg noir-moins go-back\" ui:sref=\"trombinoscope()\"> \u21B0 Retour au trombinoscope </a>\n\n                 <user-details class=\"user-details eleve\"\n                               uid=\"$ctrl.uids[0]\"\n                               show-avatar=\"true\"\n                               show-emails=\"true\"\n                               show-classe=\"true\"\n                               show-birthdate=\"true\"\n                               show-address=\"true\"\n                               show-concerned-people=\"true\"\n                               ng:if=\"$ctrl.uids.length == 1\"></user-details>\n\n                 <ul ng:if=\"$ctrl.uids.length > 1\">\n                   <li style=\"list-style-type: none;\"\n                       ng:repeat=\"uid in $ctrl.uids\">\n                     <a class=\"eleve\"\n                        ui:sref=\"student({uids: [uid]})\">\n                       <user-details class=\"user-details eleve\"\n                                     uid=\"uid\"\n                                     small=\"true\"\n                                     show-avatar=\"true\"\n                                     show-classe=\"true\"></user-details>\n                     </a>\n                   </li>\n                 </ul>\n               </div>\n\n               <onglets class=\"col-md-8 student\"\n                        uids=\"$ctrl.uids\"></onglets>\n"
});
angular.module('suiviApp')
    .component('trombinoscope', {
    controller: ['$filter', '$q', 'URL_ENT', 'APIs', 'Popups', 'User', 'UID',
        function ($filter, $q, URL_ENT, APIs, Popups, User, UID) {
            var ctrl = this;
            ctrl.pretty_labels = {
                "CLS": "classe",
                "GRP": "groupe d'élèves",
                "GPL": "groupe libre"
            };
            ctrl.popup_onglet_batch = Popups.onglet_batch;
            ctrl.popup_batch = Popups.batch;
            ctrl.popup_onglet_batch_callback = function (feedback) { console.log(feedback); };
            ctrl.popup_publish_batch = Popups.publish_batch;
            ctrl.filters = {
                text: '',
                groups: [],
                grades: []
            };
            ctrl.only_display_relevant_to = false;
            ctrl.eleves = [];
            ctrl.groups = [];
            ctrl.structures = [];
            var fix_avatar_url = function (avatar_url) {
                return (_(avatar_url.match(/^(user|http)/)).isNull() ? URL_ENT + "/" : '') + avatar_url;
            };
            ctrl.apply_filters = function () {
                var selected_structures_ids = _.chain(ctrl.structures).where({ selected: true }).pluck('id').value();
                var selected_groups_ids = _.chain(ctrl.groups).where({ selected: true }).pluck('id').value();
                var selected_grades_ids = _.chain(ctrl.grades).where({ selected: true }).pluck('id').value();
                var grades_ids_from_groups_ids = function (groups_ids) {
                    return _.chain(ctrl.groups)
                        .select(function (group) { return _(groups_ids).contains(group.id); })
                        .pluck("grades")
                        .flatten()
                        .pluck("grade_id")
                        .uniq()
                        .value();
                };
                var structures_ids_from_groups_ids = function (groups_ids) {
                    return _.chain(ctrl.groups)
                        .select(function (group) { return _(groups_ids).contains(group.id); })
                        .pluck("structure_id")
                        .uniq()
                        .value();
                };
                return function (pupil) {
                    return ("" + pupil.firstname + pupil.lastname).toLocaleLowerCase().includes(ctrl.filters.text.toLocaleLowerCase())
                        && (selected_structures_ids.length == 0 || _(selected_structures_ids).intersection(structures_ids_from_groups_ids(_(pupil.groups).pluck('group_id'))).length > 0)
                        && (selected_groups_ids.length == 0 || _(selected_groups_ids).intersection(_(pupil.groups).pluck('group_id')).length > 0)
                        && (selected_grades_ids.length == 0 || _(selected_grades_ids).intersection(grades_ids_from_groups_ids(_(pupil.groups).pluck('group_id'))).length > 0)
                        && (!ctrl.only_display_relevant_to || pupil.relevant);
                };
            };
            ctrl.clear_filters = function (type) {
                if (_(['CLS', 'GRP', 'GPL']).contains(type)) {
                    _.chain(ctrl['groups']).select(function (item) { return item.selected && item.type == type; }).each(function (item) { item.selected = false; });
                }
                else {
                    _(ctrl[type]).each(function (item) { item.selected = false; });
                }
            };
            ctrl.pluck_selected_uids = function () {
                var filter = ctrl.apply_filters();
                return _.chain(ctrl.eleves)
                    .select(function (pupil) { return filter(pupil); })
                    .reject(function (pupil) { return pupil.excluded; })
                    .pluck('id')
                    .value();
            };
            ctrl.pluriel = function (item_count, character) {
                return item_count > 1 ? character : '';
            };
            User.get({ id: UID }).$promise
                .then(function (response) {
                ctrl.current_user = response;
                ctrl.current_user.avatar = fix_avatar_url(ctrl.current_user.avatar);
                return APIs.query_relevant_students(ctrl.current_user.id);
            }, function error(response) { })
                .then(function success(response) {
                ctrl.relevant_to = response.data;
                return ctrl.current_user.get_actual_groups();
            }, function error(response) { })
                .then(function (groups) {
                var users_ids = [];
                var promises = [];
                var process_groups = function (groups) {
                    ctrl.groups = ctrl.groups.concat(_(groups).select(function (group) { return group.type == "GPL" || _(group.users).findWhere({ type: "ELV" }) != undefined; }));
                    ctrl.groups = _(ctrl.groups).uniq(function (group) { return group.id; });
                    APIs.get_grades(_.chain(ctrl.groups)
                        .pluck('grades')
                        .flatten()
                        .pluck('grade_id')
                        .value())
                        .then(function success(response) {
                        ctrl.grades = response.data;
                    }, function error(response) { });
                    users_ids = users_ids.concat(_.chain(groups)
                        .pluck("users")
                        .flatten()
                        .compact()
                        .select(function (user) { return user.type == "ELV"; })
                        .pluck("user_id")
                        .value());
                };
                var process_structures_ids = function (structures_ids) {
                    if (structures_ids.length > 1) {
                        APIs.get_structures(structures_ids).then(function (response) {
                            ctrl.structures = ctrl.structures.concat(response.data);
                            ctrl.structures = _(ctrl.structures).uniq(function (structure) { return structure.id; });
                        });
                    }
                };
                if (_.chain(ctrl.current_user.profiles).pluck("type").contains("ELV").value()) {
                    users_ids.push(ctrl.current_user.id);
                }
                users_ids = users_ids.concat(_(ctrl.current_user.children).pluck('child_id'));
                var groups_ids = _.chain(groups)
                    .reject(function (group) { return _(["ELV"]).contains(group.type); })
                    .pluck("id")
                    .value();
                if (groups_ids.length > 0) {
                    promises.push(APIs.get_groups(groups_ids)
                        .then(function (response) {
                        process_structures_ids(_.chain(response.data)
                            .pluck("structure_id")
                            .uniq()
                            .value());
                        process_groups(response.data);
                    }));
                }
                var structures_ids = _.chain(ctrl.current_user.profiles)
                    .select(function (profile) { return _(["ADM", "DIR", "DOC", "ETA", "EVS", "ORI"]).contains(profile.type); })
                    .pluck("structure_id")
                    .uniq()
                    .value();
                if (!_(structures_ids).isEmpty()) {
                    process_structures_ids(structures_ids);
                    promises.push(APIs.get_groups_of_structures(structures_ids)
                        .then(function (response) {
                        process_groups(response.data);
                    }));
                }
                $q.all(promises).then(function () {
                    users_ids = _(users_ids).uniq();
                    while (users_ids.length > 0) {
                        APIs.get_users(users_ids.splice(0, 200))
                            .then(function (users) {
                            ctrl.eleves = ctrl.eleves.concat(_(users.data).map(function (eleve) {
                                eleve.avatar = fix_avatar_url(eleve.avatar);
                                eleve.excluded = false;
                                eleve.relevant = _(ctrl.relevant_to).contains(eleve.id);
                                var classe = _.chain(eleve.groups)
                                    .map(function (group) {
                                    return _(ctrl.groups).findWhere({ id: group.group_id, type: "CLS" });
                                })
                                    .compact()
                                    .first()
                                    .value();
                                if (classe != undefined) {
                                    eleve.regroupement = {
                                        id: classe.id,
                                        name: classe.name,
                                        type: classe.type
                                    };
                                    eleve.etablissement = classe.structure_id;
                                    eleve.enseignants = classe.profs;
                                }
                                return eleve;
                            }));
                            ctrl.eleves = _(ctrl.eleves).uniq(function (eleve) { return eleve.id; });
                        });
                    }
                });
            });
        }],
    template: "\n<style>\n  .trombinoscope .petite.case { border: 1px solid transparent; }\n  .filter .panel-body { max-height: 380px; overflow-y: auto; }\n  .trombinoscope .excluded .eleve { opacity: 0.8; }\n  .regroupement {background-color: rgba(240, 240, 240, 0.66);}\n  .trombinoscope .excluded .eleve .full-name { color: lightgray; text-decoration: double line-through; }\n</style>\n<div class=\"col-md-4 gris1-moins aside trombinoscope-aside\" style=\"padding: 0;\">\n  <div class=\"panel panel-default gris1-moins\">\n    <div class=\"panel-heading\" style=\"text-align: right; \">\n      <h3>\n        {{$ctrl.pluck_selected_uids().length}} \u00E9l\u00E8ve{{$ctrl.pluriel($ctrl.pluck_selected_uids().length, 's')}}<span ng:if=\"$ctrl.current_user.can_do_batch\"> s\u00E9lectionn\u00E9{{$ctrl.pluriel($ctrl.filtered.length, 's')}}</span>\n\n        <a class=\"btn btn-primary\"\n           title=\"Gestion des onglets communs\"\n           ng:if=\"$ctrl.current_user.can_do_batch\"\n           ui:sref=\"student({uids: $ctrl.pluck_selected_uids()})\">\n          <span class=\"glyphicon glyphicon-user\"></span>\n          <span class=\"glyphicon glyphicon-user\" style=\"font-size: 125%; margin-left: -11px; margin-right: -11px;\"></span>\n          <span class=\"glyphicon glyphicon-user\"></span>\n        </a>\n      </h3>\n    </div>\n    <div class=\"panel-body\">\n\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <input class=\"form-control input-lg\"\n                 style=\"display: inline; background-color: rgba(240, 240, 240, 0.66);\"\n                 type=\"text\" name=\"search\"\n                 ng:model=\"$ctrl.filters.text\" />\n          <button class=\"btn btn-xs\" style=\"color: green; margin-left: -44px; margin-top: -4px;\"\n                  ng:click=\"$ctrl.filters.text = ''\"\n                  ng:disabled=\"$ctrl.filters.text.length == 0\">\n            <span class=\"glyphicon glyphicon-remove\"></span>\n          </button>\n        </div>\n      </div>\n\n      <div class=\"row\" style=\"margin-top: 14px;\">\n        <div class=\"col-md-6 filter\"\n             ng:repeat=\"grp_type in ['CLS', 'GRP', 'GPL']\"\n             ng:if=\"$ctrl.groups.length > 0\">\n          <div class=\"panel panel-default\">\n            <div class=\"panel-heading\">\n              Filtrage par {{$ctrl.pretty_labels[grp_type]}}\n\n              <button class=\"btn btn-xs pull-right\" style=\"color: green;\"\n                      ng:click=\"$ctrl.clear_filters( grp_type )\">\n                <span class=\"glyphicon glyphicon-remove\">\n                </span>\n              </button>\n              <div class=\"clearfix\"></div>\n            </div>\n\n            <div class=\"panel-body\">\n              <div class=\"btn-group\">\n                <button class=\"btn btn-sm\" style=\"margin: 2px; font-weight: bold; color: #fff;\"\n                        ng:repeat=\"group in $ctrl.groups | filter:{type: grp_type} | orderBy:['name']\"\n                        ng:class=\"{'vert-plus': group.selected, 'vert-moins': !group.selected}\"\n                        ng:model=\"group.selected\"\n                        uib:btn-checkbox>\n                  {{group.name}}\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"col-md-6 filter\" ng:if=\"$ctrl.grades.length > 1\">\n          <div class=\"panel panel-default\">\n            <div class=\"panel-heading\">\n              Filtrage par niveau\n\n              <button class=\"btn btn-xs pull-right\" style=\"color: green;\"\n                      ng:click=\"$ctrl.clear_filters('grades')\">\n                <span class=\"glyphicon glyphicon-remove\">\n                </span>\n              </button>\n              <div class=\"clearfix\"></div>\n            </div>\n\n            <div class=\"panel-body\">\n              <div class=\"btn-group\">\n                <button class=\"btn btn-sm\" style=\"margin: 2px; font-weight: bold; color: #fff;\"\n                        ng:repeat=\"grade in $ctrl.grades | orderBy:['name']\"\n                        ng:class=\"{'vert-plus': grade.selected, 'vert-moins': !grade.selected}\"\n                        ng:model=\"grade.selected\"\n                        uib:btn-checkbox>\n                  {{grade.name}}\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"col-md-6 filter\" ng:if=\"$ctrl.structures.length > 1\">\n          <div class=\"panel panel-default\">\n            <div class=\"panel-heading\">\n              Filtrage par \u00E9tablissements\n\n              <button class=\"btn btn-xs pull-right\" style=\"color: green;\"\n                      ng:click=\"$ctrl.clear_filters('structures')\">\n                <span class=\"glyphicon glyphicon-remove\">\n                </span>\n              </button>\n              <div class=\"clearfix\"></div>\n            </div>\n\n            <div class=\"panel-body\">\n              <div class=\"btn-group\">\n                <button class=\"btn btn-sm\" style=\"margin: 2px; font-weight: bold; color: #fff;\"\n                        ng:repeat=\"structure in $ctrl.structures | orderBy:['name']\"\n                        ng:class=\"{'vert-plus': structure.selected, 'vert-moins': !structure.selected}\"\n                        ng:model=\"structure.selected\"\n                        uib:btn-checkbox>\n                  {{structure.name}}\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n</div>\n\n<div class=\"col-md-8 vert-moins damier trombinoscope\">\n  <ul>\n    <li class=\"col-xs-6 col-sm-4 col-md-3 col-lg-2 petite case vert-moins\"\n        style=\"background-repeat: no-repeat; background-attachment: scroll; background-clip: border-box; background-origin: padding-box; background-position-x: center; background-position-y: center; background-size: 100% auto;\"\n        ng:class=\"{'relevant': eleve.relevant, 'excluded': eleve.excluded}\"\n        ng:style=\"{'background-image': 'url( {{eleve.avatar}} )' }\"\n        ng:repeat=\"eleve in $ctrl.filtered = ( $ctrl.eleves | filter:$ctrl.apply_filters() | orderBy:['regroupement.name', 'lastname'] )\">\n      <button class=\"btn btn-danger pull-left\" style=\"height: 10%;\"\n              title=\"exclure de la s\u00E9lection\"\n              ng:style=\"{'opacity': eleve.excluded ? '1' : '0.5'}\"\n              uib:btn-checkbox ng:model=\"eleve.excluded\"\n              ng:if=\"$ctrl.current_user.can_do_batch\">\n        <span class=\"glyphicon glyphicon-ban-circle\"></span>\n      </button>\n      <h5 class=\"regroupement pull-right\" style=\"height: 10%;\">{{eleve.regroupement.name}}</h5>\n      <a class=\"eleve\" style=\"height: 90%; margin-top: 10%;\"\n         ui:sref=\"student({uids: [eleve.id]})\">\n\n        <div class=\"full-name\" title=\"{{eleve.relevant ? 'Vous \u00EAtes contributeur de ce student' : ''}}\">\n          <h4 class=\"first-name\">{{eleve.firstname}}</h4>\n          <h4 class=\"last-name\">{{eleve.lastname}}</h4>\n        </div>\n      </a>\n    </li>\n  </ul>\n</div>\n"
});
angular.module('suiviApp')
    .component('userDetails', {
    bindings: {
        uid: '<',
        small: '<',
        showAvatar: '<',
        showConcernedPeople: '<',
        showPhones: '<',
        showEmails: '<',
        showClasse: '<',
        showAddress: '<',
        showBirthdate: '<'
    },
    controller: ['APIs', 'URL_ENT', 'User',
        function (APIs, URL_ENT, User) {
            var ctrl = this;
            ctrl.URL_ENT = URL_ENT;
            ctrl.$onInit = function () {
                User.get({ id: ctrl.uid }).$promise
                    .then(function success(response) {
                    ctrl.user = response;
                    if (ctrl.showClasse) {
                        ctrl.user.get_actual_groups()
                            .then(function (response) {
                            ctrl.user.actual_groups = response;
                            ctrl.user.actual_groups.forEach(function (group) {
                                APIs.get_structure(group.structure_id)
                                    .then(function (response) {
                                    group.structure = response.data;
                                });
                            });
                        });
                    }
                    if (ctrl.showConcernedPeople) {
                        ctrl.user.query_people_concerned_about()
                            .then(function success(response) {
                            ctrl.concerned_people = _(response).groupBy('type');
                            delete ctrl.concerned_people['Élève'];
                        }, function error(response) { });
                    }
                }, function error(response) { });
            };
        }],
    template: "\n                          <div class=\"col-md-12\">\n                            <div class=\"avatar-container gris4 pull-left\" ng:style=\"{'height': $ctrl.small ? '44px' : '175px', 'width': $ctrl.small ? '44px' : '175px'}\">\n                              <img class=\"avatar noir-moins\"\n                                   ng:style=\"{'max-height': $ctrl.small ? '44px' : '175px', 'max-width': $ctrl.small ? '44px' : '175px'}\"\n                                   ng:src=\"{{$ctrl.URL_ENT + '/' + $ctrl.user.avatar}}\"\n                                   ng:if=\"$ctrl.showAvatar\" />\n                            </div>\n                            <div class=\"col-md-8 details\" ng:style=\"{'min-height': $ctrl.small ? '44px' : '175px'}\">\n                              <div class=\"col-md-12\">\n                                <span class=\"first-name\"\n                                      ng:style=\"{'font-size': $ctrl.small ? '100%' : '150%'}\"> {{$ctrl.user.firstname}}\n                                </span>\n                                <span class=\"last-name\"\n                                      ng:style=\"{'font-size': $ctrl.small ? '100%' : '175%'}\"> {{$ctrl.user.lastname}}\n                                </span>\n                              </div>\n\n                              <span class=\"col-md-12 classe\" ng:if=\"$ctrl.showClasse\">\n                                <span ng:repeat=\"group in $ctrl.user.actual_groups | filter:{type: 'CLS'}\">\n                                  {{group.name}} - {{group.structure.name}}\n                                </span>\n                              </span>\n\n                              <span class=\"col-md-12 birthdate\" ng:if=\"$ctrl.showBirthdate\">\n                                n\u00E9<span ng:if=\"$ctrl.user.gender === 'F'\">e</span> le {{$ctrl.user.birthdate | date}}\n                              </span>\n                              <div class=\"col-md-12 email\"\n                                   ng:repeat=\"email in $ctrl.user.emails\"\n                                   ng:if=\"$ctrl.showEmails\">\n                                <span class=\"glyphicon glyphicon-envelope\">\n                                </span>\n                                <a href=\"mailto:{{email.address}}\">{{email.address}}</a>\n                              </div>\n                              <span class=\"col-md-12 address\"\n                                    ng:if=\"$ctrl.showAddress && $ctrl.user.adresse\">\n                                <span class=\"glyphicon glyphicon-home\">\n                                </span>\n                                <span style=\"display: inline-table;\">\n                                  {{$ctrl.user.address}}\n                                  <br>\n                                  {{$ctrl.user.zipcode}} {{$ctrl.user.city}}\n                                </span>\n                              </span>\n                              <div class=\"col-md-12 phone\"\n                                   ng:repeat=\"phone in $ctrl.user.phones\"\n                                   ng:if=\"$ctrl.showPhones\">\n                                <span class=\"glyphicon\"\n                                      ng:class=\"{'glyphicon-phone': phone.type === 'PORTABLE', 'glyphicon-phone-alt': phone.type !== 'PORTABLE'}\">\n                                  {{phone.type}}: {{phone.number}}\n                                </span>\n                              </div>\n                            </div>\n                          </div>\n\n                          <fieldset class=\"pull-left col-md-12 parents\" ng:if=\"$ctrl.showConcernedPeople\">\n                            <legend>Personnes concern\u00E9es</legend>\n                            <uib-accordion>\n                              <div uib-accordion-group\n                                   class=\"panel-default\"\n                                   ng:repeat=\"(type, peoples) in $ctrl.concerned_people\"\n                                   ng:if=\"type != 'Autre \u00E9l\u00E8ve suivi'\">\n                                <uib-accordion-heading>\n                                  <span class=\"glyphicon\" ng:class=\"{'glyphicon-menu-down': type.is_open, 'glyphicon-menu-right': !type.is_open}\">\n                                  </span> {{type}}\n                                </uib-accordion-heading>\n                                <ul>\n                                  <li ng:repeat=\"people in peoples | orderBy:'lastname'\">\n                                    <span ng:if=\"!people.relevant_to\">{{people.firstname}} {{people.lastname}}</span>\n                                    <span ng:if=\"people.relevant_to\">\n                                      <a ui:sref=\"student({uid_student: people.id})\">{{people.firstname}} {{people.lastname}}</a>\n                                    </span>\n                                    <span ng:if=\"people.prof_principal\"> (enseignant principal)</span>\n                                    <span ng:if=\"people.actual_subjects\">\n                                      <br/>\n                                      <em ng:repeat=\"subject in people.actual_subjects\">\n                                        <span class=\"glyphicon glyphicon-briefcase\">\n                                        </span> {{subject.name}}\n                                      </em>\n                                    </span>\n                                    <span ng:if=\"people.emails.length > 0\">\n                                      <br/>\n                                      <span class=\"glyphicon glyphicon-envelope\">\n                                      </span>\n                                      <a href=\"mailto:{{people.emails[0].address}}\">{{people.emails[0].address}}</a>\n                                    </span>\n                                  </li>\n                                </ul>\n                              </div>\n                            </uib-accordion>\n                          </fieldset>\n"
});
angular.module('suiviApp')
    .factory('Droits', ['$resource', 'APP_PATH',
    function ($resource, APP_PATH) {
        return $resource(APP_PATH + "/api/droits/:id", {
            id: '@id'
        }, {
            save: {
                method: 'POST',
                isArray: true
            },
            update: { method: 'PUT' }
        });
    }]);
angular.module('suiviApp')
    .factory('Onglets', ['$resource', 'APP_PATH',
    function ($resource, APP_PATH) {
        return $resource(APP_PATH + "/api/onglets/:id", {
            id: '@id'
        }, {
            save: {
                method: 'POST',
                isArray: true
            },
            update: {
                method: 'PUT',
                isArray: true
            },
            delete: {
                method: 'DELETE',
                isArray: true
            }
        });
    }]);
angular.module('suiviApp')
    .factory('Saisies', ['$resource', 'APP_PATH',
    function ($resource, APP_PATH) {
        return $resource(APP_PATH + "/api/saisies/:id", {
            id: '@id'
        }, {
            update: { method: 'PUT' }
        });
    }]);
angular.module('suiviApp')
    .factory('User', ['$resource', '$rootScope', '$q', 'APIs', 'URL_ENT',
    function ($resource, $rootScope, $q, APIs, URL_ENT) {
        return $resource(URL_ENT + "/api/users/:id", {
            id: "@id",
            expand: "@expand"
        }, {
            get: {
                cache: false,
                transformResponse: function (response) {
                    var user = angular.fromJson(response);
                    user.is_admin = function () {
                        return user.profiles.length > 0
                            && _(user.profiles).findWhere({ type: 'ADM' }) != undefined;
                    };
                    user.can_do_batch = _(["ADM", "DIR", "DOC", "ENS", "ETA", "EVS", "ORI", "TUT"]).intersection(_(user.profiles).pluck("type")).length > 0;
                    user.can_add_tab = function (uids) {
                        return user.can_do_batch || ((uids.length == 1) && uids[0] == user.id);
                    };
                    user.get_actual_groups = function () {
                        return APIs.get_groups(_(user.groups).pluck('group_id'))
                            .then(function (response) {
                            user.actual_groups = response.data;
                            return $q.resolve(user.actual_groups);
                        });
                    };
                    user.get_actual_subjects = function () {
                        return APIs.get_subjects(_(user.groups).pluck('subject_id'))
                            .then(function (response) {
                            user.actual_subjects = response.data;
                            return $q.resolve(user.actual_subjects);
                        });
                    };
                    user.query_people_concerned_about = _.memoize(function () {
                        var concerned_people = new Array();
                        var profils = new Array();
                        var relevant_to = new Array();
                        var current_user = null;
                        var users = new Array();
                        var personnels = new Array();
                        var pupils = new Array();
                        var teachers = new Array();
                        var main_teachers = new Array();
                        return APIs.query_profiles_types()
                            .then(function success(response) {
                            profils = _(response.data).indexBy('id');
                            if (!_(user.parents).isEmpty()) {
                                return APIs.get_users(_(user.parents).pluck('parent_id'));
                            }
                            else {
                                return $q.resolve({ no_parents: true });
                            }
                        }, function error(response) { return $q.reject(response); })
                            .then(function success(response) {
                            if (_(response).has('data')) {
                                concerned_people.push(_(response.data).map(function (people) {
                                    var pluriel = response.data.length > 1 ? 's' : '';
                                    people.type = "Responsable" + pluriel + " de l'\u00E9l\u00E8ve";
                                    return people;
                                }));
                            }
                            if (user.profiles.length > 0) {
                                return APIs.get_structures(_(user.profiles).pluck("structure_id"));
                            }
                            else {
                                return $q.resolve({ no_profile: true });
                            }
                        }, function error(response) { return $q.reject(response); })
                            .then(function success(response) {
                            if (_(response).has('data')) {
                                personnels = _.chain(response.data)
                                    .pluck("profiles")
                                    .flatten()
                                    .reject(function (user) {
                                    return _(['ELV', 'TUT', 'ENS']).contains(user.type);
                                })
                                    .uniq(function (user) { return user.id; })
                                    .value();
                                return APIs.get_users(_(personnels).pluck('user_id'));
                            }
                            else {
                                return $q.resolve({ no_profile: true });
                            }
                        })
                            .then(function success(response) {
                            if (_(response).has('data')) {
                                personnels = _(personnels).indexBy('user_id');
                                concerned_people.push(_(response.data).map(function (people) {
                                    people.type = profils[personnels[people.id].type].name + " de l'\u00E9l\u00E8ve";
                                    return people;
                                }));
                                var groups_ids = _(user.groups).pluck('group_id');
                                return APIs.get_groups(groups_ids);
                            }
                            else {
                                return $q.resolve({ no_profile: true });
                            }
                        }, function error(response) { return $q.reject(response); })
                            .then(function success(response) {
                            if (_(response).has('data')) {
                                users = _.chain(response.data).pluck('users').flatten().value();
                                pupils = _(users).where({ type: 'ELV' });
                                if (pupils.length > 0) {
                                    return APIs.get_users(_(pupils).pluck('user_id'));
                                }
                                else {
                                    return $q.resolve({ no_pupils: true });
                                }
                            }
                            else {
                                return $q.resolve({ no_profile: true });
                            }
                        }, function error(response) { return $q.reject(response); })
                            .then(function success(response) {
                            pupils = _(pupils).indexBy('user_id');
                            concerned_people.push(_(response.data).map(function (people) {
                                var pluriel = response.data.length > 1 ? 's' : '';
                                people.type = "Autre" + pluriel + " \u00E9l\u00E8ve" + pluriel;
                                return people;
                            }));
                            teachers = _(users).where({ type: 'ENS' });
                            if (teachers.length > 0) {
                                return APIs.get_users(_(teachers).pluck('user_id'));
                            }
                            else {
                            }
                            return $q.resolve();
                        }, function error(response) { return $q.reject(response); })
                            .then(function success(response) {
                            teachers = _(teachers).indexBy('user_id');
                            main_teachers = _(users).where({ type: 'PRI' });
                            concerned_people.push(_(response.data).map(function (people) {
                                people.type = profils[teachers[people.id].type].name + " de l'\u00E9l\u00E8ve";
                                APIs.get_subjects(_(people.groups).pluck('subject_id'))
                                    .then(function (response) {
                                    people.actual_subjects = response.data;
                                });
                                return people;
                            }));
                            return $q.resolve();
                        }, function error(response) { return $q.reject(response); })
                            .then(function () {
                            return $q.resolve(_.chain(concerned_people)
                                .flatten()
                                .uniq(function (people) {
                                return people.id;
                            })
                                .value());
                        });
                    });
                    return user;
                }
            }
        });
    }]);
angular.module('suiviApp')
    .service('APIs', ['$http', '$q', 'Onglets', 'URL_ENT', 'APP_PATH',
    function ($http, $q, Onglets, URL_ENT, APP_PATH) {
        var APIs = this;
        APIs.query_profiles_types = _.memoize(function () {
            return $http.get(URL_ENT + "/api/profiles_types");
        });
        APIs.get_users = _.memoize(function (users_ids) {
            if (_(users_ids).isEmpty()) {
                return $q.resolve({ data: [] });
            }
            else {
                return $http.get(URL_ENT + "/api/users/", { params: { 'id[]': users_ids } });
            }
        });
        APIs.get_group = _.memoize(function (regroupement_id) {
            return $http.get(URL_ENT + "/api/groups/" + regroupement_id);
        });
        APIs.get_groups = _.memoize(function (groups_ids) {
            if (_(groups_ids).isEmpty()) {
                return $q.resolve({ data: [] });
            }
            else {
                return $http.get(URL_ENT + "/api/groups/", { params: { 'id[]': groups_ids } });
            }
        });
        APIs.get_groups_of_structures = _.memoize(function (structures_ids) {
            return $http.get(URL_ENT + "/api/groups/", { params: { 'structure_id[]': structures_ids } });
        });
        APIs.get_grades = _.memoize(function (grades_ids) {
            if (_(grades_ids).isEmpty()) {
                return $q.resolve({ data: [] });
            }
            else {
                return $http.get(URL_ENT + "/api/grades/", { params: { 'id[]': grades_ids } });
            }
        });
        APIs.get_subjects = _.memoize(function (subjects_ids) {
            if (_(subjects_ids).isEmpty()) {
                return $q.resolve({ data: [] });
            }
            else {
                return $http.get(URL_ENT + "/api/subjects/", { params: { 'id[]': subjects_ids } });
            }
        });
        APIs.query_relevant_students = function (uid) {
            return $http.get(APP_PATH + "/api/students/relevant/" + uid);
        };
        APIs.get_structure = _.memoize(function (uai) {
            return $http.get(URL_ENT + "/api/structures/" + uai);
        });
        APIs.get_structures = _.memoize(function (uais) {
            return $http.get(URL_ENT + "/api/structures/", { params: { 'id[]': uais } });
        });
        APIs.query_common_onglets_of = function (uids) {
            return Onglets.query({ "uids[]": uids }).$promise
                .then(function success(response) {
                return $q.resolve(_.chain(response)
                    .groupBy('name')
                    .toArray()
                    .select(function (tabgroup) { return tabgroup.length == uids.length; })
                    .flatten()
                    .groupBy('name')
                    .value());
            }, function error(response) { return $q.resolve({}); });
        };
    }]);
angular.module('suiviApp')
    .service('Popups', ['$uibModal', '$q', 'Onglets', 'Droits', 'Saisies', 'APIs', 'UID', 'User',
    function ($uibModal, $q, Onglets, Droits, Saisies, APIs, UID, User) {
        var Popups = this;
        Popups.loading_window = function (title, text, action) {
            return swal({
                title: title,
                text: text,
                type: "info",
                showLoaderOnConfirm: true,
                onOpen: function () {
                    return swal.clickConfirm();
                },
                preConfirm: function () {
                    return new Promise(function (resolve) {
                        action()
                            .then(function success(response) {
                            swal.closeModal();
                        }, function error(response) {
                            console.log(response);
                            swal.closeModal();
                            swal({
                                title: 'Erreur :(',
                                text: response.data.error,
                                type: 'error'
                            });
                        });
                    });
                },
                allowOutsideClick: false
            });
        };
        Popups.onglet = function (uids, onglet, all_onglets, callback) {
            var parcours_educatifs = [
                "Parcours avenir",
                "Parcours d'éducation artistique et culturelle",
                "Parcours santé",
                "Parcours citoyen"
            ];
            $uibModal.open({
                template: "\n<div class=\"modal-header\">\n  <h3 class=\"modal-title\">\n    Propri\u00E9t\u00E9s de l'onglet\n  </h3>\n</div>\n\n<div class=\"modal-body\">\n  <label>Titre<span ng:if=\"$ctrl.onglet.names\">s</span> :\n    <input\n      type=\"text\"\n      placeholder=\"onglet personnalis\u00E9\"\n      maxlength=\"45\"\n      ng:disabled=\"$ctrl.onglet.names\"\n      ng:model=\"$ctrl.onglet.name\"\n      ng:maxlength=\"45\"\n      ng:change=\"$ctrl.onglet.dirty = true; $ctrl.name_validation()\"\n      ng:if=\"!$ctrl.onglet.names\" />\n    <span class=\"label label-danger\" ng:if=\"!$ctrl.onglet.names && !$ctrl.valid_name\">Un onglet existant porte d\u00E9j\u00E0 ce nom !</span>\n\n    <ul ng:if=\"$ctrl.onglet.names\">\n      <li ng:repeat=\"name in $ctrl.onglet.names\">{{name}}</li>\n    </ul>\n  </label>\n  <button class=\"btn btn-primary\"\n          ng:click=\"$ctrl.parcours();\"\n          ng:if=\"!$ctrl.already_has_parcours && !$ctrl.onglet.names\">Parcours \u00E9ducatifs</button>\n\n  <droits uid-eleve=\"$ctrl.uids\"\n          droits=\"$ctrl.droits\"\n          concerned-people=\"$ctrl.concerned_people\"\n          ng:if=\"$ctrl.droits\"></droits>\n  <span class=\"label label-info\" ng:if=\"$ctrl.uids\">(Par d\u00E9faut l'\u00E9l\u00E8ve aura un acc\u00E8s en lecture/\u00E9criture \u00E0 cet onglet.)</span>\n\n  <div class=\"clearfix\"></div>\n</div>\n\n<div class=\"modal-footer\">\n  <button class=\"btn btn-danger pull-left\"\n          ng:click=\"$ctrl.delete()\"\n          ng:if=\"$ctrl.onglet.id || $ctrl.onglet.ids\">\n    <span class=\"glyphicon glyphicon-trash\"></span>\n    <span> Supprimer l'onglet</span>\n  </button>\n  <button class=\"btn btn-default\"\n          ng:click=\"$ctrl.cancel()\">\n    <span class=\"glyphicon glyphicon-remove-sign\"></span>\n    <span ng:if=\"$ctrl.onglet.name\"> Annuler</span>\n    <span ng:if=\"!$ctrl.onglet.name\"> Fermer</span>\n  </button>\n  <button class=\"btn btn-success\"\n          ng:click=\"$ctrl.ok()\"\n          ng:disabled=\"!$ctrl.onglet.names && (!$ctrl.onglet.name || !$ctrl.valid_name)\">\n    <span class=\"glyphicon glyphicon-ok-sign\"></span> Valider\n  </button>\n</div>\n",
                resolve: {
                    uids: function () { return uids; },
                    onglet: function () { return _(onglet).isNull() ? { name: '' } : onglet; },
                    all_onglets: function () { return all_onglets; }
                },
                controller: ['$scope', '$uibModalInstance', '$q', 'Droits', 'APIs', 'URL_ENT', 'DEFAULT_RIGHTS_ONGLET', 'UID', 'uids', 'onglet', 'all_onglets',
                    function PopupOngletCtrl($scope, $uibModalInstance, $q, Droits, APIs, URL_ENT, DEFAULT_RIGHTS_ONGLET, UID, uids, onglet, all_onglets) {
                        var ctrl = $scope;
                        ctrl.$ctrl = ctrl;
                        ctrl.uids = uids;
                        ctrl.onglet = onglet;
                        ctrl.all_onglets = all_onglets;
                        ctrl.onglet.deleted = false;
                        ctrl.valid_name = true;
                        ctrl.already_has_parcours = _(parcours_educatifs).intersection(ctrl.all_onglets.map(function (onglet) { return onglet.name; })).length == parcours_educatifs.length;
                        if (_(ctrl.onglet).has('id') || _(ctrl.onglet).has('ids')) {
                            Droits.query({
                                onglet_id: ctrl.onglet.id,
                                "onglets_ids[]": ctrl.onglet.ids
                            }).$promise
                                .then(function success(response) {
                                ctrl.droits = _(response).map(function (droit) {
                                    return new Droits(droit);
                                });
                            }, function error(response) { });
                        }
                        else {
                            ctrl.droits = [new Droits({ uid: UID, read: true, write: true, manage: true })];
                            if (uids.length == 1) {
                                ctrl.droits.push(new Droits({ uid: uids[0], read: true, write: true, manage: false }));
                            }
                            ctrl.droits = ctrl.droits.concat(_(DEFAULT_RIGHTS_ONGLET)
                                .map(function (droit) {
                                var proper_droit = new Droits(droit);
                                proper_droit.dirty = { profile_type: true, read: true, write: true, manage: true };
                                return proper_droit;
                            }));
                        }
                        if (uids.length == 1) {
                            User.get({ id: uids[0] }).$promise
                                .then(function success(response) {
                                ctrl.eleve = response;
                                ctrl.eleve.query_people_concerned_about(uids[0])
                                    .then(function success(response) {
                                    ctrl.concerned_people = response;
                                }, function error(response) { });
                            }, function error(response) { });
                        }
                        else {
                            User.get({ id: UID }).$promise
                                .then(function success(response) {
                                ctrl.concerned_people = [response];
                                return APIs.get_users(uids);
                            }, function error(response) { })
                                .then(function success(response) {
                                ctrl.concerned_people = ctrl.concerned_people.concat(response.data);
                            }, function error(response) { });
                        }
                        ctrl.name_validation = function () {
                            var other_onglets_names = _.chain(ctrl.all_onglets)
                                .reject(function (onglet) {
                                return !_(ctrl.onglet).isNull() && ctrl.onglet.id == onglet.id;
                            })
                                .pluck('name')
                                .value();
                            ctrl.valid_name = !_(other_onglets_names).includes(ctrl.onglet.name);
                            return ctrl.valid_name;
                        };
                        ctrl.parcours = function () {
                            ctrl.onglet.name = undefined;
                            ctrl.onglet.names = _(parcours_educatifs).difference(ctrl.all_onglets.map(function (onglet) { return onglet.name; }));
                        };
                        ctrl.ok = function () {
                            $uibModalInstance.close({
                                onglet: ctrl.onglet,
                                droits: ctrl.droits
                            });
                        };
                        ctrl.delete = function () {
                            swal({
                                title: 'Êtes-vous sur ?',
                                text: "L'onglet ainsi que toutes les saisies et droits associés seront définitivement supprimés !",
                                type: 'warning',
                                showCancelButton: true,
                                confirmButtonColor: '#3085d6',
                                confirmButtonText: 'Oui, je confirme !',
                                cancelButtonColor: '#d33',
                                cancelButtonText: 'Annuler'
                            })
                                .then(function (result) {
                                ctrl.onglet.deleted = result.dismiss != "cancel";
                                ctrl.ok();
                            });
                        };
                        ctrl.cancel = function () {
                            $uibModalInstance.dismiss();
                        };
                    }]
            })
                .result.then(function success(response_popup) {
                var promise = null;
                var action = 'rien';
                if (onglet == null) {
                    action = 'created';
                    promise = Onglets.save({
                        uids: uids,
                        names: response_popup.onglet.names == undefined ? [response_popup.onglet.name] : response_popup.onglet.names
                    }).$promise;
                }
                else if (response_popup.onglet.deleted) {
                    action = 'deleted';
                    response_popup.onglet["ids[]"] = response_popup.onglet.ids;
                    delete response_popup.onglet.ids;
                    delete response_popup.onglet.id;
                    promise = Onglets.delete(response_popup.onglet).$promise;
                }
                else if (response_popup.onglet.dirty) {
                    promise = Onglets.update(response_popup.onglet).$promise;
                }
                else {
                    promise = $q.resolve([response_popup.onglet]);
                }
                promise.then(function success(response) {
                    var onglets = response;
                    onglets.action = action;
                    if (action != 'deleted') {
                        _.chain(response_popup.droits)
                            .reject(function (droit) { return action == 'created' && _(droit).has('uid') && (droit.uid == UID || droit.uid == uids); })
                            .each(function (droit) {
                            if (droit.to_delete && (_(droit).has('id') || _(droit).has('ids'))) {
                                Droits.delete(droit);
                            }
                            else if (!droit.to_delete
                                && droit.dirty
                                && (droit.uid != '...' && droit.profile_type != '...' && droit.sharable_id != '...')
                                && _(droit.dirty).reduce(function (memo, value) { return memo || value; }, false)) {
                                droit.onglets_ids = response.map(function (onglet) { return onglet.id; });
                                var promise_1 = ((_(droit).has('id') || _(droit).has('ids')) ? Droits.update(droit) : Droits.save(droit)).$promise;
                                promise_1.then(function (response) { return true; }, function (response) { return false; });
                            }
                        });
                    }
                    callback(onglets);
                }, function error() { });
            }, function error() { });
        };
    }]);
angular.module('suiviApp')
    .service('Utils', [function () {
        var Utils = this;
        Utils.gen_pseudo_UUID = function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };
    }]);
